---
layout: post
title: '[Rust] Rust å­¸ç¿’ç­†è¨˜ - åŸºæœ¬æ¦‚å¿µç¯‡'
comments: true
typora-root-url: 2021-02-23-rust-note-2
typora-copy-images-to: 2021-02-23-rust-note-2
date: 2021-02-23 10:20:10
categories: Rust
tags: Rust
---

ç¹¼ä¸Šç¯‡çŒœæ•¸å­—çš„ç·´ç¿’ç¯„ä¾‹ä¸­ï¼Œå¤§è‡´ä¸Šå¯ä»¥æ„Ÿå—åˆ° Rust é€™èªè¨€çš„å€‹æ€§ï¼Œä½†é‚„æ˜¯å¾—çŸ¥é“èªè¨€çš„å‹åˆ¥ã€èªæ³•åŠæµç¨‹æ§åˆ¶çš„æ–¹æ³•ï¼Œæ‰€ä»¥é€™é‚Šç­†è¨˜æœƒé‡å° [Command Programming Concepts ç« ç¯€](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) çš„å…§å®¹æ“·å–æˆ‘è¦ºå¾—éœ€è¦è¨˜ä¸‹ä¾†çš„é‡é»        

<!-- more -->

# Variables and Mutability

* è®Šæ•¸å®£å‘Šå¾Œï¼Œé è¨­çš†ç‚ºä¸å¯æ”¹è®Šçš„ç‹€æ…‹ (Immutable)ï¼Œå¦‚æœéœ€è¦ä¸€å€‹å¯ä»¥è¢«æ”¹è®Šçš„è®Šæ•¸ï¼Œå¿…é ˆåŠ ä¸Š `mut` çš„é—œéµå­—

  ```rust
  let a = 1; // immutable
  a = 2; // é€™è¡Œæœƒå‡ºéŒ¯
  let mut b = "some text";
  b = "can be changed";
  ```

* è®Šæ•¸çš„å‹åˆ¥å¿…é ˆè¦ä¸€è‡´ï¼Œç›´åˆ°é‡æ–°è¢«å®£å‘Š [(Shadowing)](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing)

  ```rust
  let a = "1";
  let a = a.len(); 
  let mut b = "some text";
  b = b.len(); // å‹åˆ¥ä¸ä¸€è‡´ï¼Œæœƒç™¼ç”ŸéŒ¯èª¤
  ```

* variables èˆ‡ constants çš„å·®ç•°æœ‰ä»¥ä¸‹å¹¾é»

  * constants ä¸èƒ½ä½¿ç”¨ `mut` 
  * constants ä½¿ç”¨ `const` å®£å‘Šè€Œä¸”å¿…é ˆæŒ‡å®šå‹åˆ¥ï¼Œç¯„ä¾‹: `const MAX_POINTS: u32 = 100_000;`
  * constants åªèƒ½è¢«å®£å‘Šä¸€æ¬¡

  

# Data Types

## Scalar Type

Rust çš„æ¨™æº–å‹åˆ¥ (scalar type) æœ‰å››ç¨®: `integers`ã€`floating-point numbers`ã€ `Booleans`ã€`characters`ã€‚

### Integer

* åˆ†ç‚º signed (`i`) å’Œ unsigned (`u`)

* æœ‰ 8-bitã€16-bitã€32-bitã€64-bitã€128-bitã€arch é•·åº¦

* 8 ~ 128 bit çš„ç¯„åœç®—æ³•èªªæ˜å¦‚ä¸‹

  > Each signed variant can store numbers from -(2n - 1) to 2n - 1 - 1 inclusive, where *n* is the number of bits that variant uses. So an `i8` can store numbers from -(27) to 27 - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2n - 1, so a `u8` can store numbers from 0 to 28 - 1, which equals 0 to 255.
  >
  > Additionally, the `isize` and `usize` types depend on the kind of computer your program is running on: 64 bits if youâ€™re on a 64-bit architecture and 32 bits if youâ€™re on a 32-bit architecture.

* å¯ä»¥ä½¿ `_` ä¾†å¢åŠ æ•¸å­—çš„é–±è®€æ€§ï¼Œä¾‹å¦‚: `100_000` ç­‰åŒæ–¼ `100000`

### floating-point

* `f32` å’Œ `f64` å…©ç¨® floating-point type
* æ ¹æ“š `IEEE-754`  æ¨™æº– ([wiki](https://zh.wikipedia.org/wiki/IEEE_754))

### Boolean

* å¦‚ä¸€èˆ¬ä½¿ç”¨ `true` å’Œ `false` å…©ç¨®çµæœï¼Œå¤§å°ç‚º `1 byte`

  ```rust 
  fn main() {
      let t = true;
  
      let f: bool = false; // with explicit type annotation
  }
  ```

### Character 

* åŸºæœ¬æ–‡å­—å‹ä½¿ç”¨é›™å¼•è™ŸåŒ…èµ·ä¾†ï¼Œè€Œ `character` ä½¿ç”¨å–®å¼•è™Ÿï¼Œè·Ÿ C# ä¸€æ¨£

  ```rust
  fn main() {
      let c = 'z';
      let z = 'â„¤';
      let heart_eyed_cat = 'ğŸ˜»';
  }
  ```

## Compound Types

### Tuple

* å®£å‘Šæ–¹å¼ 

  ```rust
  fn main() {
      let tup1 = (500, 6.4, 1);
      let tup2: (i32, f64, u8) = (500, 6.4, 1);
  }
  ```

* è§£æ§‹ tuple

  ```rust
  fn main() {
      let tup = (500, 6.4, 1);
  
      let (x, y, z) = tup;
  
      println!("The value of y is: {}", y);
  }
  ```

* ç›´æ¥ä½¿ç”¨ index è®€å– tuple

  ```rust
  fn main() {
      let x: (i32, f64, u8) = (500, 6.4, 1);
  
      let five_hundred = x.0;
  
      let six_point_four = x.1;
  
      let one = x.2;
  }
  
  ```

  

### Array

* å®£å‘Šæ–¹å¼

  ```rust
  let a = [1, 2, 3, 4];
  let b = [1; 5]; // [1,1,1,1,1]
  ```

* with å‹åˆ¥åŠé•·åº¦å®£å‘Š

  ```rust
  let a: [i32; 5] = [1, 2, 3, 4, 5];
  ```

* å¾ 0 é–‹å§‹ï¼Œè¶…éé™£åˆ—é•·åº¦æœƒé€ æˆéŒ¯èª¤



# Functions

* å®£å‘Šæ–¹å¼: `fn`

* å‘½åæ–¹å¼: `snake case`ï¼Œç¯„ä¾‹: `fn another_function(){ }`

* Function parameters çš„è¨­å®šæ–¹å¼

  ```rust
  fn main() {
      another_function(5);
  }
  
  fn another_function(x: i32) {
      println!("The value of x is: {}", x);
  }
  ```

* Expression in Function

  ```rust
  fn main() {
      let x = 5;
  
      let y = {
          let x = 3;
          x + 1
      };
  
      println!("The value of y is: {}", y);
  }
  ```

  * ä½¿ç”¨ `{ }` ä¾†å»ºç«‹ä¸€å€‹æ–°çš„ scope
  * line 6: æ²’æœ‰åˆ†è™Ÿçµå°¾ï¼Œè¦–ç‚º `expression` æœƒè¢« return

* Function éœ€å›å‚³ `values` æˆ–æ˜¯ `expressions`ï¼Œæ²’æœ‰ `void` çš„æ¦‚å¿µ

  

# Comments

* è¨»è§£ç¬¦è™Ÿç‚º : `//`

  ```rust
  fn main() {
      // Iâ€™m feeling lucky today
      let lucky_number = 7;
  }
  ```

  

# Control Flow

æµç¨‹æ§åˆ¶æœ‰ `if` å’Œ `loops` å…©ç¨®æ–¹æ³•

## if

* èªæ³•ï¼Œ`if` å¾Œé¢çš„æ¢ä»¶ä¸éœ€è¦ä½¿ç”¨ `( )` åŒ…èµ·ä¾†

  ```rust
  fn main() {
      let number = 3;
  
      if number < 5 {
          println!("condition was true");
      } else {
          println!("condition was false");
      }
  }
  ```

* æœ‰ `else if` é€™ç¨®æ±è¥¿

  ```rust
  fn main() {
      let number = 6;
  
      if number % 4 == 0 {
          println!("number is divisible by 4");
      } else if number % 3 == 0 {
          println!("number is divisible by 3");
      } else if number % 2 == 0 {
          println!("number is divisible by 2");
      } else {
          println!("number is not divisible by 4, 3, or 2");
      }
  }
  ```

* å¯ä»¥æ­é… `let` ä½¿ç”¨ï¼Œä½†å›å‚³çš„å‹åˆ¥å¿…é ˆä¸€è‡´

  ```rust
  fn main() {
      let condition = true;
      let number = if condition { 5 } else { 6 };
  
      println!("The value of number is: {}", number);
  }
  ```

  

## loops

æœ‰ä¸‰ç¨® loops çš„æ–¹å¼: `loop`ã€`while`ã€`for`

* loop

  ```rust
  fn main() {
      let mut counter = 0;
  
      let result = loop {
          counter += 1;
  
          if counter == 10 {
              break counter * 2;
          }
      };
  
      println!("The result is {}", result);
  }
  ```

* while

  ```rust
  fn main() {
      let mut number = 3;
  
      while number != 0 {
          println!("{}!", number);
  
          number -= 1;
      }
  
      println!("LIFTOFF!!!");
  }
  ```

* for

  ```rust
  fn main() {
      let a = [10, 20, 30, 40, 50];
  
      for element in a.iter() {
          println!("the value is: {}", element);
      }
  }
  ```



# å°çµ

Rust æ²’æœ‰åƒ C# æ“æœ‰å¾ˆå¤šä¸åŒå‹åˆ¥æˆ–æ˜¯ç¨‹å¼èªæ³•ï¼Œä½†é€™äº›éƒ½ç®—æ˜¯åŸºæœ¬éœ€è¦æŒæ¡çš„ï¼Œå¦‚æœæœ‰åœ°æ–¹ç†è§£éŒ¯èª¤ä¹Ÿè«‹è®“æˆ‘çŸ¥é“ï¼Œæ„Ÿè¬

