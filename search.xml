<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Angular] Angular 在 VSCode Extension (Webview) 內做頁面切換]]></title>
    <url>%2F2021%2F02%2F06%2Fangular-vscode-extension-page-navigate%2F</url>
    <content type="text"><![CDATA[繼上一篇環境基礎設定完成後，這篇先來筆記一下要如何做頁面切換，有哪些地方需要留意的 首先要知道在 VSCode Extension Webview 的環境並不是一個 web server 而是檔案，所以我們就不能使用預設的路由設定模式，而必須改為 hash 模式 (HashLocationStrategy)，設定方式如下 123 RouterModule.forRoot(routes, &#123; useHash: true,&#125;), 在到 index.html 的地方，調整 base 路徑的部分 1&lt;base href="#"&gt; 到這邊基本上 Angular 的路由就可以正常運作了 或許會問說，那 LazyLoading 的部分呢? 很抱歉，在 VSCode Extension Webview 內是不能使用的，所以 loadChildren 的寫法要改成這樣 1&#123; path: 'product', loadChildren: () =&gt; ProductModule &#125;,]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 把 Angular 網站放到 VSCode Extension 內]]></title>
    <url>%2F2021%2F02%2F05%2Fng-vscode-extension-webview%2F</url>
    <content type="text"><![CDATA[前幾天我分享了一個 YouTube 的影片，該影片大致上的內容是如何使用 VSCode Extension 使用 Webview API，既然可以用 webview 的方式來呈現網頁，那顯示一個 Angular App 也是很正常的事情，但環境設定上要怎麼調整呢? 這篇筆記就來整理一下 環境設定 首先先建立一個 Angular 的專案 (這應該不用講要用什麼指令了吧) 打開 package.json，新增以下內容 123456789101112131415161718192021222324"publisher": "publisher-name","engines": &#123; "vscode": "^1.53.0"&#125;,"categories": [ "Other"],"activationEvents": [ "onCommand:angular-webview.start"],"main": "./dist/ext-src/extension.js","contributes": &#123; "commands": [ &#123; "command": "angular-webview.start", "title": "Open Webview", "category": "CK" &#125; ]&#125;,"repository": &#123; "type": "git", "url": "#"&#125; categories 、activationEvents、contributes 的區塊內容請配合 VS Code Extension 開發規範做調整 123456"devDependencies": &#123; ... "@types/vscode": "^1.53.0", "vscode-test": "^1.5.0", "vsce": "^1.83.0"&#125; 修改完後記得要執行 npm install 12345678"scripts": &#123;... // 修改 "build": "ng build --prod --output-hashing none &amp;&amp; tsc -p tsconfig.extension.json", // 新增指令 "package": "vsce package", "vscode:prepublish": "npm run build &amp;&amp; tsc -p tsconfig.extension.json" &#125;, 新增 .vscodeignore 檔案 (可根據狀況調整) 1234567*!dist.vscodee2eext-srcnode_modulessrc 新增 .vscode 資料夾並新增 launch.json 檔案 12345678910111213141516&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Run Extension", "type": "extensionHost", "request": "launch", "args": [ "--extensionDevelopmentPath=$&#123;workspaceFolder&#125;" ], "outFiles": [ "$&#123;workspaceFolder&#125;/out/**/*.js" ], &#125;, ]&#125; 新增 ext-src 資料夾，並在該資料夾下新增 extension.ts 檔案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145import * as fs from 'fs';import * as path from 'path';import * as vscode from 'vscode';/** * Manages webview panels */class WebPanel &#123; /** * Track the currently panel. Only allow a single panel to exist at a time. */ public static currentPanel: WebPanel | undefined; private static readonly viewType = 'angular'; private readonly panel: vscode.WebviewPanel; private readonly extensionPath: string; private readonly builtAppFolder: string; private disposables: vscode.Disposable[] = []; public static createOrShow( extensionPath: string, context: vscode.ExtensionContext ) &#123; const column = vscode.window.activeTextEditor ? vscode.window.activeTextEditor.viewColumn : undefined; // If we already have a panel, show it. // Otherwise, create angular panel. if (WebPanel.currentPanel) &#123; WebPanel.currentPanel.panel.reveal(column); &#125; else &#123; WebPanel.currentPanel = new WebPanel( extensionPath, column || vscode.ViewColumn.One, context ); &#125; return WebPanel.currentPanel; &#125; private constructor( extensionPath: string, column: vscode.ViewColumn, context: vscode.ExtensionContext ) &#123; this.extensionPath = extensionPath; this.builtAppFolder = 'dist/cklab'; // Create and show a new webview panel this.panel = vscode.window.createWebviewPanel( WebPanel.viewType, 'My Angular Webview', column, &#123; // Enable javascript in the webview enableScripts: true, // And restrict the webview to only loading content from our extension's `media` directory. localResourceRoots: [ vscode.Uri.file(path.join(this.extensionPath, this.builtAppFolder)), ], &#125; ); // Set the webview's initial html content this.panel.webview.html = this._getHtmlForWebview(context); // Listen for when the panel is disposed // This happens when the user closes the panel or when the panel is closed programatically this.panel.onDidDispose(() =&gt; this.dispose(), null, this.disposables); // Handle messages from the webview this.panel.webview.onDidReceiveMessage( (message: any) =&gt; &#123; switch (message.command) &#123; case 'alert': vscode.window.showErrorMessage(message.text); return; &#125; &#125;, null, this.disposables ); &#125; public dispose() &#123; WebPanel.currentPanel = undefined; // Clean up our resources this.panel.dispose(); while (this.disposables.length) &#123; const x = this.disposables.pop(); if (x) &#123; x.dispose(); &#125; &#125; &#125; /** * Returns html of the start page (index.html) */ private _getHtmlForWebview(context: vscode.ExtensionContext) &#123; // path to dist folder const appDistPath = path.join(this.extensionPath, this.builtAppFolder); // get path to index.html file from dist folder const indexPath = path.join(appDistPath, 'index.html'); // read index file from file system let indexHtml = fs.readFileSync(indexPath, &#123; encoding: 'utf8' &#125;); // 1. Get all link prefixed by href or src const matchLinks = /(href|src)="([^"]*)"/g; // 2. Transform the result of the regex into a vscode's URI format const toUri = (_: string, prefix: 'href' | 'src', link: string) =&gt; &#123; // For &lt;base href="#" /&gt; if (link === '#') &#123; return `$&#123;prefix&#125;="$&#123;link&#125;"`; &#125; // For scripts &amp; links const _path = path.join(appDistPath, link); const uri = vscode.Uri.file(_path); return `$&#123;prefix&#125;="$&#123;this.panel.webview['asWebviewUri'](uri)&#125;"`; &#125;; // update the base URI tag indexHtml = indexHtml.replace(matchLinks, toUri); return indexHtml; &#125;&#125;export function activate(context: vscode.ExtensionContext) &#123; context.subscriptions.push( vscode.commands.registerCommand('angular-webview.start', () =&gt; &#123; WebPanel.createOrShow(context.extensionPath, context); &#125;) );&#125;// this method is called when your extension is deactivatedexport function deactivate() &#123;&#125; line 49: 請根據自己 Angular 專案輸出資料夾路徑做調整 line 138: 跟著 package.json 的指令註冊一起調整命令名稱 新增 tsconfig.extension.json 檔案 123456789101112131415161718192021&#123; "compilerOptions": &#123; "module": "commonjs", "target": "es6", "outDir": "dist", "lib": [ "es6", "dom" ], "sourceMap": true, "rootDir": ".", "strict": true &#125;, "include": [ "ext-src" ], "exclude": [ "node_modules/*", ".vscode/*" ]&#125; 到這邊應算是完成最基本的 VS Code Extension 環境的設定，如何看是否有設定成功，可以執行以下步驟 開 Terminal 執行 npm run build 按 F5 進入 Debug 模式，這時候會開啟一個新的 VS Code 視窗 執行所設定的啟動指令，以這個範例來說就是 CK: Open Webview 成功後的顯示畫面 至於在 VS Code Webview 的環境下，Angular 開發上有什麼需要注意的事項，這部分就留到下一篇筆記了 打包套件 如果都寫完要發布成可以安裝的擴充套件時，可以執行 npm run package 就會產生一個 VSIX 的安裝檔案 參考資料 How to Code a VSCode Extension VSCode Extension Get Started VSCode Webview API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 設定 Firebase Messaging 功能]]></title>
    <url>%2F2021%2F01%2F13%2Fflutter-firebase-message-setup%2F</url>
    <content type="text"><![CDATA[網路上面關於設定 Flutter 的文章真的很亂，也不知道哪一個版本能用，乾脆自己整理一篇目前可以使用的版本，還好越晚使用，設定步驟就越簡單 設定 Firebase 專案 需要從 Firebase 專案中下載 google-services.json 的檔案，以供後續套件使用，取得步驟如下 進入 Firebase 專案 選擇專案設定 新增應用程式 (Android)後，即可取得 google-services.json 的檔案 將該檔案複製到 Flutter 專案下的 android/app 資料夾下 Flutter Firebase Message 套件 套件安裝 於 pubspec.yaml 檔內新增下列套件 12firebase_core: ^0.7.0firebase_messaging: 8.0.0-dev.13 環境設定 為了要讓 Flutter 在建置時，能載入剛剛下載的 google-services.json 檔案，還需調整以下檔案 android/build.gradle 1234567buildscript &#123; dependencies &#123; // ... other dependencies // 新增這一行 classpath &apos;com.google.gms:google-services:4.3.3&apos; &#125;&#125; /android/app/build.gradle 123apply plugin: &apos;com.android.application&apos;// 新增這一行apply plugin: &apos;com.google.gms.google-services&apos; ※如果 Flutter 專案的 Flutter 版本是 1.12 以上，則不需要額外新增任何檔案，如果是低於該版本，請依此文件說明新增檔案 程式碼設定 Flutter 內的程式碼要增加的項目如下 main.dart 1234567891011121314151617181920212223242526272829void main() async &#123; ... await Firebase.initializeApp(); // Set the background messaging handler early on, as a named top-level function FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler); /// Create an Android Notification Channel. /// 這裡有多使用套件: flutter_local_notifications: ^3.0.3 /// We use this channel in the `AndroidManifest.xml` file to override the /// default FCM channel to enable heads up notifications. await flutterLocalNotificationsPlugin .resolvePlatformSpecificImplementation&lt; AndroidFlutterLocalNotificationsPlugin&gt;() ?.createNotificationChannel(channel); /// Update the iOS foreground notification presentation options to allow /// heads up notifications. await FirebaseMessaging.instance.setForegroundNotificationPresentationOptions( alert: true, badge: true, sound: true, );&#125;Future&lt;void&gt; _firebaseMessagingBackgroundHandler(RemoteMessage message) async &#123; // If you're going to use other Firebase services in the background, such as Firestore, // make sure you call `initializeApp` before using other Firebase services. await Firebase.initializeApp(); print("Handling a background message $&#123;message.messageId&#125;");&#125; 在啟動的第一個 widget 檔案內 1234567891011121314151617181920212223242526272829@overridevoid initState() &#123; super.initState(); // 當 app 處於開啟狀態時，監聽推撥訊息用 FirebaseMessaging.onMessage.listen((RemoteMessage message) async &#123; RemoteNotification notification = message.notification; AndroidNotification android = message.notification?.android; if (notification != null &amp;&amp; android != null) &#123; await flutterLocalNotificationsPlugin.show( notification.hashCode, notification.title, notification.body, NotificationDetails( android: AndroidNotificationDetails( channel.id, channel.name, channel.description, icon: 'launch_background', ), )); &#125; &#125;); FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) &#123; print('A new onMessageOpenedApp event was published!'); // 這邊可以寫在 app 關閉狀態，點通知訊息時，打開 app 後要做的事情 &#125;);&#125; 當然還有其他可以設定的部分，更多細節可以參閱這裡的文件 延伸閱讀 Firebase Cloud Messaging Firebase_messaging_plugin]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Dart] List 的操作 reduce 與 fold]]></title>
    <url>%2F2020%2F12%2F27%2Fdart-reduce-fold%2F</url>
    <content type="text"><![CDATA[每一個語言對於清單的操作，一直都是必須要掌握的能力之一，在 dart 裡面的 List 的操作方法常見又有幾種，而其中的 reduce 與 fold 這兩個操作方式，對我來說是有點特殊的，在此筆記一下 List 的操作 reduce Dart 裡的 reduce 行為跟 JavaScript 的有點差異，先看程式碼再來說明 1234567List&lt;int&gt; list = [1,2,3,4,5]; var result = list.reduce((value, element) &#123; return value + element;&#125;);print(result); reduce 的過程中，資料操作的型別是不能做更換的，表示 value 與 element 的型別會是一致 如果想要操作得資料與想要取的的結果型態不一樣時，要先做轉型後(搭配 map) 再操作 123456789101112131415161718192021void main()&#123; var carts = [ Cart(productName: "蘋果", price: 50, amount: 1), Cart(productName: '蔬菜', price: 20, amount: 2), Cart(productName: '雞肉', price: 60, amount: 3), Cart(productName: '雞蛋', price: 10, amount: 10), ]; var totalPrice = carts.map((element)=&gt; element.amount * element.price) .reduce((value,element)=&gt; value+element); print(totalPrice);&#125;class Cart &#123; String productName; num price; num amount; Cart(&#123;this.productName, this.price, this.amount&#125;);&#125; method 介面 123E reduce( E combine(E value, E element)) fold 上面的第二個範例寫法，如果寫習慣 JavaScript 的人會覺得很囉唆，但其實 JavaScript 的 reduce 等於 Dart 的 fold，一樣先來看程式碼 1234567891011121314151617181920void main()&#123; var carts = [ Cart(productName: "Apple", price: 50, amount: 1), Cart(productName: '蔬菜', price: 20, amount: 2), Cart(productName: '雞肉', price: 60, amount: 3), Cart(productName: '雞蛋', price: 10, amount: 10), ]; var totalPrice = carts.fold(0, (prev, element) =&gt; prev + element.price * element.amount); print(totalPrice);&#125;class Cart &#123; String productName; num price; num amount; Cart(&#123;this.productName, this.price, this.amount&#125;);&#125; fold 的初始值是放在第一個位置 後面的使用方式就和 JavaScript 的 reduce 一樣了 method 介面 1234dynamic fold( initialValue, dynamic combine(previousValue, E element)) 小結 這兩個用法都有他試用的情境，根據情境挑適合的方法使用，可以讓程式碼乾淨許多]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做出自動版號的效果]]></title>
    <url>%2F2020%2F11%2F02%2Fhow-to-auto-version%2F</url>
    <content type="text"><![CDATA[最近再弄一個版號顯示的功能，但我真的好懶得手動去改版號，有什麼自動方便的作法呢? 以下是我找到比較方便的方式 .NET Core 在以往的 .NET 專案 有一個記錄版本的檔案，叫做 Assemblyinfo.cs，裡面會記錄著專案的相關資訊包含作者、公司、產品名稱、及版本資訊等，目前可以透過 IDE 編輯專案屬性 -&gt; 編輯套件資訊 如果要自動編版本號碼，這裡有一個透過編輯 csproj 來動態改變版本 12345&lt;PropertyGroup&gt; &lt;Build&gt;$([System.DateTime]::op_Subtraction($([System.DateTime]::get_Now().get_Date()),$([System.DateTime]::new(2000,1,1))).get_TotalDays())&lt;/Build&gt; &lt;Revision&gt;$([MSBuild]::Divide($([System.DateTime]::get_Now().get_TimeOfDay().get_TotalSeconds()), 2).ToString('F0'))&lt;/Revision&gt; &lt;Version&gt;1.$(Build).$(Revision)&lt;/Version&gt;&lt;/PropertyGroup&gt; &lt;build&gt; 、&lt;Revision&gt; 自定義變數供 &lt;Version&gt; 使用，這邊的規則可以依個人喜好修改 &lt;Version&gt; 設定產品版本 對應產生的 Assemblyinfo.cs 內容為 1234567891011121314151617181920212223//------------------------------------------------------------------------------// &lt;auto-generated&gt;// 這段程式碼是由工具產生的。// 執行階段版本:4.0.30319.42000//// 對這個檔案所做的變更可能會造成錯誤的行為，而且如果重新產生程式碼，// 變更將會遺失。// &lt;/auto-generated&gt;//------------------------------------------------------------------------------using System;using System.Reflection;[assembly: Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute("4a3c5c00-20b2-4c11-90d1-d01d65382565")][assembly: System.Reflection.AssemblyCompanyAttribute("WebApplication4")][assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")][assembly: System.Reflection.AssemblyFileVersionAttribute("1.7611.29271.0")][assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.7611.29271")][assembly: System.Reflection.AssemblyProductAttribute("WebApplication4")][assembly: System.Reflection.AssemblyTitleAttribute("WebApplication4")][assembly: System.Reflection.AssemblyVersionAttribute("1.7611.29271.0")]// 由 MSBuild WriteCodeFragment 類別產生。 Angular 有時候我們也想要在前端網站給予設定版本，除了手動修改外，其實也可以透過 npm version 來完成，雖然有點奇怪，但還是可以運作啦 npm version 這功能原本是用來更新 npm package 版本使用，指令如下 1npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git] 這指令會同步更新 package.json 的 version 欄位值，這邊就快速列出我所使用的 script 12"prebuild": "npm --no-git-tag-version version patch","postversion": "git add package.json package-lock.json &amp;&amp; git commit -mv%npm_package_version%", prebuild 這行為會發生在執行 npm build 之前 --no-git-tag-version 設定 npm version 不要自動 commit 且不要加上 tag npm version patch : 只更新 patch 版號 postversion 這動作會發生在 npm version 之後 加入並 commit 異動檔案 當 package.json 內的 version 處理完後，就可以在 environment.ts 的地方引用 package.json 了 123export const environment = &#123; version: require('../../package.json').version,&#125;; 由於這邊有使用到 node 的 required ，在 tsconfig.app.json 及 tsconfig.spec.json 的 compilerOptions.types 內要加上 node，並安裝 @types/node 的型別定義檔，剩下就跟原來使用 environment 的方式一樣了 小結 目前是我處理自動版號的方式，如果有其他更好的作法，也歡迎分享給我 參考資料 Get App Version in .NET Core npm version]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF Core] 新增一個計算欄位 (Computed Column)]]></title>
    <url>%2F2020%2F09%2F17%2Fefcore-add-computed-column%2F</url>
    <content type="text"><![CDATA[當使用 EF Code First 設計資料表時，如果有一個欄位是要設定計算公式時，程式碼該如何寫呢? 以下幾個步驟 在欄位上標記欄位屬於 computed 性質 1234[DatabaseGenerated(DatabaseGeneratedOption.Computed)]public int CalculatedField &#123; get; private set;&#125; 新增 migration 1add-migration xxxx-xxxx 打開剛建立的 migration 檔案並找到剛剛所指定的欄位 123456789migrationBuilder.CreateTable( name: "Demo", columns: table =&gt; new &#123; // 刪除原本產生的欄位 CalculatedField = table.Column&lt;int&gt;(nullable: false, defaultValue: 0), &#125;,);migrationBuilder.Sql("ALTER TABLE dbo.Demo ADD CalculatedField AS ([你的計算規則])"); 打完收工 以上是我目前的作法，能正常運作。如果有更好的寫法，也歡迎在下面留言分享討論 額外補充 如果想要透過 EF Migration 來新增 Stored Procedure 的話，可以這樣子寫 將 storeㄎ procedure 的 SQL 檔案放在某資料夾下，並將 SQL 檔案設定為 內嵌資源 (EmbeddedResource) 新增一個空的 migration 後加入以下的程式碼 123456789101112131415161718192021protected override void Up(MigrationBuilder migrationBuilder) &#123; var assembly = Assembly.GetExecutingAssembly(); var resourceNames = assembly.GetManifestResourceNames(). Where(str=&gt; str.Contains("[sp file name].sql")); foreach (string resourceName in resourceNames) &#123; using (Stream stream = assembly.GetManifestResourceStream(resourceName)) using (StreamReader reader = new StreamReader(stream)) &#123; string sql = reader.ReadToEnd(); migrationBuilder.Sql(sql); &#125; &#125; &#125; protected override void Down(MigrationBuilder migrationBuilder) &#123; migrationBuilder.Sql("DROP PROCEDURE [SP Name]"); &#125; 當進行 database 更新時，就會將該 SP 新增到資料庫中]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>Entity Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何寫具有非同步驗證的 Angular 自訂表單物件]]></title>
    <url>%2F2020%2F08%2F29%2Fangular-custom-form-control-with-async-valiator%2F</url>
    <content type="text"><![CDATA[前幾天有人在論壇問了一個自訂表單非同步驗證的問題，這問題是當一個自訂表單物件內有非同步驗證時，外部使用者無法正確地取得該表單物件的驗證狀態，這問題我一開始想說應該不難，但也花了我快一天的時間才釐清要怎麼寫一個具有非同步驗證的自訂表單物件，方法如下 同步驗證 我們都知道 Angular FormControl 的驗證有分同步與分同步兩種方式，下面是同步驗證的寫法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Component(&#123; selector: "app-user", templateUrl: "./user.component.html", styleUrls: ["./user.component.css"], providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: UserComponent, multi: true &#125;, &#123; provide: NG_VALIDATORS, useExisting: UserComponent, multi: true &#125; ]&#125;)export class UserComponent implements OnInit, ControlValueAccessor, Validator &#123; firstName = new FormControl("", [Validators.required]); onChange: (e) =&gt; &#123;&#125;; onTouched: () =&gt; &#123;&#125;; constructor() &#123;&#125; ngOnInit() &#123; this.firstName.valueChanges.subscribe(&#123; next: value =&gt; &#123; if (this.onChange) &#123; this.onChange(value); this.onTouched(); &#125; &#125; &#125;); &#125; writeValue(obj: any) &#123; this.firstName.patchValue(obj); &#125; registerOnChange(fn: any) &#123; this.onChange = fn; &#125; registerOnTouched(fn: any) &#123; this.onTouched = fn; &#125; validate() &#123; return this.firstName.errors; &#125;&#125; 分同步驗證 非同步驗證在 FormControl 的驗證狀態是 PENDING &lt;–&gt; VALID/INVALID 間切換，由於非同步與同步要實作的方法都是同一個，所以當非同步與同步驗證同時存在時，要以非同步為準，不然整個驗證都只會取得同步驗證的 1234567891011121314151617181920212223242526272829@Component(&#123; ... providers: [ ... &#123; provide: NG_ASYNC_VALIDATORS, useExisting: UserComponent, multi: true &#125; ]&#125;)export class UserComponent implements OnInit, ControlValueAccessor, Validator &#123; firstName = new FormControl("", [Validators.required], [this.asyncValidator]); onChange: (e) =&gt; &#123;&#125;; onTouched: () =&gt; &#123;&#125;; constructor() &#123;&#125; asyncValidator(c: AbstractControl) &#123; return of(c.value === "123").pipe( delay(500), map(b =&gt; (b ? null : &#123; nomatch: true &#125;)) ); &#125; ... validate() &#123; return this.firstName.errors; &#125;&#125; 一旦註冊成 NG_ASYNC_VALIDATORS 時，外部使用這一個自訂 FormControl 的 status 就會處在 PENDING ，而其原因是因為 validate 的方法沒有回傳一個完成的訊號，基於這一個理由，我們需要調整 validate 的實作方式 1234567validate() &#123; return this.firstName.statusChanges.pipe( filter(status =&gt; status !== "PENDING"), map(status =&gt; this.firstName.errors), first() ); &#125; 完整程式碼如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import &#123; Component, OnInit &#125; from "@angular/core";import &#123; ControlValueAccessor, Validator, NG_VALUE_ACCESSOR, NG_VALIDATORS, NG_ASYNC_VALIDATORS, Validators, AbstractControl&#125; from "@angular/forms";import &#123; FormControl &#125; from "@angular/forms";import &#123; of &#125; from "rxjs";import &#123; filter, tap, map, delay, first &#125; from "rxjs/operators";@Component(&#123; selector: "app-user", templateUrl: "./user.component.html", styleUrls: ["./user.component.css"], providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: UserComponent, multi: true &#125;, &#123; provide: NG_ASYNC_VALIDATORS, useExisting: UserComponent, multi: true &#125; ]&#125;)export class UserComponent implements OnInit, ControlValueAccessor, Validator &#123; firstName = new FormControl("", [Validators.required], [this.asyncValidator]); onChange: (e) =&gt; &#123;&#125;; onTouched: () =&gt; &#123;&#125;; constructor() &#123;&#125; asyncValidator(c: AbstractControl) &#123; return of(c.value === "123").pipe( delay(500), map(b =&gt; (b ? null : &#123; nomatch: true &#125;)) ); &#125; ngOnInit() &#123; this.firstName.valueChanges.subscribe(&#123; next: value =&gt; &#123; if (this.onChange) &#123; this.onChange(value); this.onTouched(); &#125; &#125; &#125;); &#125; writeValue(obj: any) &#123; this.firstName.patchValue(obj); &#125; registerOnChange(fn: any) &#123; this.onChange = fn; &#125; registerOnTouched(fn: any) &#123; this.onTouched = fn; &#125; validate() &#123; return this.firstName.statusChanges.pipe( filter(status =&gt; status !== "PENDING"), map(status =&gt; this.firstName.errors), first() ); &#125;&#125; 參考資料 stackbliz]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[容器] 如何寫 Dockerfile]]></title>
    <url>%2F2020%2F08%2F03%2Fdocker-101-note-3%2F</url>
    <content type="text"><![CDATA[前面兩篇筆記都在整理如何操作 docker container，要怎麼製作最重要的 Image 呢? 我會在這篇整理出來 要建立出一個可以用來執行的 Image，就必須透過 Dockerfile 來設定，Dockerfile 是一個類似文字檔的設定檔，docker 會依 Dockerfile 內的設定建立出一個可以部屬到 Registry 的 Image，其設定內容其實不複雜，以下為簡單語法介紹 Dockerfile 結構與使用語法 如之前所說，Image 所能執行的 OS 必須跟底層 docker server 跑的 OS 一樣或是使用同種 Kernel，所以當 docker server 是跑在 Linux base 上，那 Dockerfile 能跑的環境也只能是 Linux base。下面是一個簡單的範例 1234FROM ubuntu:18.04COPY . /appRUN make /appCMD python /app/app.py FROM Image 將執行的環境，這邊可以使用別人建立好的 Base Image，通常是作業系統，例如 ubuntu, centos 或是 core/aspnet 的執行環境 COPY 複製本機檔案到 Image 裡，本機根目錄的認定為 Dockerfile 所處的目錄 RUN 執行 Linux 指令 CMD 當執行 docker run 時會執行的指令，如果有個 CMD 只有最後一行會生效 如果能看懂跟理解上面的 Dockerfile，那基本上就只是 Dockerfile 語法及環境設定的熟悉度了，下面再列出幾個常用的指令 WORKDIR 設定當前的工作目錄 1WORKDIR /app LABEL Image 的 Metadata 資訊 1LABEL description="這是LABEL的範例" version="1.0" owner="CK's Notepad" ENV 設定環境變數 1ENV &lt;KEY&gt; &lt;Value&gt; ENTRYPOINT 作用跟 CMD 一樣，差異在他不會被 docker run &lt;image&gt; &lt;command&gt; 給覆蓋掉 EXPOSE 宣告 Container 運行時對外有哪些 Port 可以使用 (宣告而已) 實際 Dockerfile 範例 asp.net core 1234567891011121314151617FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS buildWORKDIR /app# copy csproj and restore as distinct layersCOPY *.sln .COPY aspnetapp/*.csproj ./aspnetapp/RUN dotnet restore# copy everything else and build appCOPY aspnetapp/. ./aspnetapp/WORKDIR /app/aspnetappRUN dotnet publish -c Release -o outFROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS runtimeWORKDIR /appCOPY --from=build /app/aspnetapp/out ./ENTRYPOINT ["dotnet", "aspnetapp.dll"] Angular 單純可以執行的 123FROM nginx:alpineCOPY /dist/app-to-run-inside-docker /usr/share/nginx/htmlEXPOSE 80 在 docker 環境內建置部屬 (multiple-stage) 12345678910# stage 1FROM node:alpine AS my-app-buildWORKDIR /appCOPY . .RUN npm install &amp;&amp; npm run build# stage 2FROM nginx:alpineCOPY --from=my-app-build /app/dist/app-to-run-inside-docker /usr/share/nginx/htmlEXPOSE 80 建置 Dockerfile 要建置 Image 透過指令就可以完成了 123docker build [OPTIONS] PATH | URL | -// 範例docker build -t angular-app . -t : 上 Tag]]></content>
      <categories>
        <category>Docker</category>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[容器] 容器技術之 Docker 篇 - 指令操作]]></title>
    <url>%2F2020%2F07%2F31%2Fdocker-101-note-2%2F</url>
    <content type="text"><![CDATA[上一篇整理了概念，這一篇來整理常用的指令，雖然也有 GUI 操作 docker 的服務，但透過指令還是比較快的 Image 相關 列出本機端擁有的 images 1docker images -a：列出完整的映像檔層次資訊。每個映像檔是由不同層次組成的，我們會在稍後說明。 -q：只列出映像檔ID。這在做映像檔批次處理時很方便。 -tree：官方文件已經沒有這個參數，但還是可以用。列出映像檔不同層次之間的樹狀關係。 下載 Image 1docker pull &lt;image name&gt; 刪除 Image 1docker rmi &lt;image name&gt; 幫 Image 上 Tag 1docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] 建置 Image 檔 1docker build 上傳 Image 檔 1docker push Container 相關 執行時的操作指令 建立 Container 並執行指令 12docker create [OPTIONS] IMAGE [COMMAND] [ARG...] // 建立但不會啟動執行 Container docker run [OPTIONS] IMAGE [COMMAND] [ARG...] // 建立且啟動執行 Container -d : 背景執行 -i: 輸入 -t: 輸出 --name: 給 Container 名稱 -p [本機 Port]:[Container 內部 Port]: Port mapping -v: 掛載 volumes -rm: 執行結束後自動移除 相關參數請參閱 Docker docs 刪除執行中的 Container，但 Container 還是存在，只是死了。 1docker kill CONTAINER --signal, -s : 送訊號到 Container 移除 Container(停止或運行中都行)，Container就從這世上消失了 1docker rm CONTAINER --force, -f : 強制移除 --link, -l 移除特定連結 --volumnes, -v 移除掛載在 Container 上的匿名 volumes 暫停執行中的 Container，仍暫有記憶體停，服務不中斷 1docker pause CONTAINER [CONTAINER...] 恢復暫停中的 Container 1docker unpause CONTAINER [CONTAINER...] 停止執行中的 Container，但不暫有記憶體，服務中斷 1docker stop [OPTIONS] CONTAINER [CONTAINER...] --time, -t 幾秒後停止 Container 啟動停止中的 Container 1docker start [OPTIONS] CONTAINER [CONTAINER...] --attach, -a : Attach STDOUT/STDERR and forward signals --interactive, -i: Attach container’s STDIN 重新啟動Container 1docker restart [OPTIONS] CONTAINER [CONTAINER...] --time, -t: 幾秒後重啟 Container 讓 Container 暫停直到 Container 停止為止 1docker wait CONTAINER [CONTAINER...] 更名 Container 1docker rename CONTAINER NEW_NAME 狀態 inspect：檢查 Container 的狀態 stats：查看 Container 的 CPU、記憶體及網路使用 port：查看 Container 的通訊埠使用 ps：查看 Container 使用狀態 -a 列出所有的 Container top：查看 Container 在主系統中的記憶體使用 dpid：查看 Container 的 pid 執行時的操作 attach：連接 Container 的標準輸出輸入端 使用-d或-id參數：離開 Container 時該 Container 停止。 使用-td參數：離開 Container 時該 Container 繼續在背景。 exec：在外部向 Container 內執行指令 denter：進入 Container logs：將 Container 內的輸出顯示到螢幕上 cp: 複製檔案到 Container 1docker cp /path/to/file1 DOCKER_ID:/path/to/file2 Registry 相關 登入 12docker login // 預設指向 public docker hubdocker loing &lt;ip&gt; // 登入私有 docker registry 登出 1docker logout 搜尋 123docker search &lt;search word&gt;// 查詢星星數條件docker search -s &lt;n start&gt; &lt;search word&gt; n 是限定須有幾顆星以上的 image 才會被搜尋出來 參考資料 docker base command]]></content>
      <categories>
        <category>Docker</category>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[容器] 容器技術之 Docker 篇 - 概念整理]]></title>
    <url>%2F2020%2F07%2F30%2Fdocker-101-note-1%2F</url>
    <content type="text"><![CDATA[閃避多年的主題，容器技術，到最後還是閃不到，只好乖乖的面對它。首先先針對比較常見的容器技術 Docker，將一些比較概念性的東西整理在這邊筆記內。 與 Virtual Machine 的差異 Docker 與虛擬機器(Virtual Machine)的差異 Docker 容器與容器間共用相同的 OS Kernel，虛擬機器是各自擁有自己的 OS，這表示 Docker Server 如果是跑 Linux 版本(通常也是這個)，就不能跑 Windows 的容器。虛擬機器只是共用硬體資源，所以在 VM Server 上就可以並存 Linux base 和 Windows Base 在同樣的硬體資源下，Docker 可以跑比較多單位 複製環境的速度，Docker 比較快，因為容器所需要的 Image 是可以透過指令的方式從某一個地方抓下來就可以執行，而 VM 也是可以做到，但因為 VM 的檔案比較大，搬移需要比較長的時間 概念 名詞 Image: 透過 dockerfile 編譯出來的 Image，唯獨屬性，就想成他是一片 CD Container: 執行 Image 的容器，就像 CD-ROM，一個 Image 可以創造出很多 Container，Container 具有讀寫的能力，但由於 Image 是唯讀，所以要操作保留的資料應該要放在另外一個地方, Volume Volume: 可以想成容器的外掛硬碟，用來保留資料使用 Registry: 放 Image 的地方，有公用的服務，例如 Docker Hub，當然也可以自己架 安裝 Windows 10 的電腦可以安裝下載 Docker desktop for Windows 的穩定版，但須具有 Hyper-V 的功能才能啟動 Docker 的服務。如果能安裝 WSL 2 及 Windows Terminal 的，之後的操作上會更加友善 至於其他作業系統的安裝方式，官網或是網路上有很多文件，這邊就不多贅述 網路 None: 沒有網路功能，簡單說就是一個沒有網卡的 Container Bridget (Default)，Docker 內部的虛擬網路，除了可以對外連線外，也提供內部各 Container 間的聯繫 Host Mode: 建立與 Docker Server Host 一樣等級的 network interface Container Mode: Container 共用同一個 Network Interface Overlay: Container 可以與跑在不同 Docker Server 上的 Container 做溝通，類似 VPN Site to Site 的概念? Overview 流程圖]]></content>
      <categories>
        <category>Docker</category>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Office] 如何在簡報上做出圓圖效果]]></title>
    <url>%2F2020%2F07%2F28%2Foffice-ppt-tips-crop-image%2F</url>
    <content type="text"><![CDATA[這一個技巧應該很多人都知道了，但我是最近需要用到才學會的，但不管怎樣還是分享一下，如何在簡報上做出圓圖效果，而這一個技巧適用於 Office PowerPoint 與 Google 簡報，以下是操作步驟。 Office PowerPoint 加入一張圖片，可以用複製、拖拉、或是手動加入都可以 選擇圖片，這時候上方的選單會多出跟圖片編輯相關的選項 選擇【圖片格式】 裁剪的功能是我們要的，但這之前先介紹裁剪原本的功能 可以裁剪我們想要的圖片範圍，點選【裁剪】後圖片的邊界會顯示如下圖圓圈標示起來的樣式 透過移動邊際來決定裁剪後要顯示的範圍 確定後只會留下明亮的部分 除了預設功能外，【裁剪】下方的箭頭打開還有更多的功能，本篇文章的圓圖顯示就是要利用這邊的功能 顯示圓圖 選擇裁剪成圖形，選擇橢圓形，(沒有圓形的選項) 設定長寬比例為 1 : 1 完成圓形圖片的顯示 Google 簡報 在 Google 簡報上要顯示圓形圖片的方式跟 PowerPoint 是一樣的 插入圖片 選擇圖片後，會出現【裁剪】的圖示 透過旁邊的箭頭選單，選擇要裁剪的圖形樣式 這裡要留意的是，如果圖片的長寬比例不是 1 : 1 的關係時，就不會顯示成圓形，所以要裁剪圖片的尺寸 打完收工 參考資料 本文章使用的圖片來源是 Photo by Vitor Pinto on Unsplash]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 幫 moment.js 套件瘦身]]></title>
    <url>%2F2020%2F07%2F25%2Fangular-moment-localte-is-too-fat%2F</url>
    <content type="text"><![CDATA[長久以來，使用 moment.js 這一個時間套件讓我很掙扎，畢竟他很好用但很肥，主要肥胖的地方都是一堆用不到的 locale. 今天終於下定決心要來解決這個問題，經過兩分鐘的搜尋後，以下是解法 在 src 資料夾下建立一個 locale 空的資料夾 在 angular.json 的 fileReplacements 內多新增下面設定 1234&#123; "replace": "node_modules/moment/locale/", "with": "src/locale/"&#125; 當這樣子設定完成後，ng build --prod 時會出現 \moment\locale\af.js&quot; does not exist. 找不到的錯誤訊息，沒關係這個不會影響到我們的程式執行。 經過這樣子的調整後，整個 moment locale 的部分就會被拔掉，瞬間瘦了快 400kb 的大小，可以算是瘦身成功]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] 使用 Azure Key Vault 服務來管理簽章用的金鑰]]></title>
    <url>%2F2020%2F06%2F22%2Fazure-keyVault-sign-with-rsa%2F</url>
    <content type="text"><![CDATA[要使用 RSA Private Key 來做資料簽章表示我們需要將 Private Key 存放在某一個地方，但絕對不會在程式的參數設定檔內，其實在 ASP.NET Core 內提供很多方法可以存放設定檔，例如使用 user secret，更多資訊可以參閱此文件。 Azure 上面也有一個 Azure Key Vault 的服務，可以集中管理相關的金鑰 (Keys)、秘密 (Secret)、憑證 (Certificate) 等資訊，而相關的服務就可以連線到這一個 Key Vault 服務取得相關的資訊做進一步的使用，例如加解密等作業 秘密 (Secret) 在一個網站會有一些設定檔會因為部屬環境而所異動，這一類的設定當然不可能寫死在程式裡，所以會將這一類的設定檔放在某一個設定檔類，例如 appsettings.json 或是 user secret 等地方，而像資料庫連線這種資料敏感的資料，存放在 appsettings.json 內就十分危險，會建議放在版控以外的地方或是 Hosting 的主機上，例如 Azure App Service 就有提供設定環境參數的地方。 但如果同樣的資訊出現在不同的程式裡，分別設定就變得十分不合適了，這時候使用 Azure Key Vault 服務就會是個不錯的選擇，但這邊就不多說明如何建立 Azure Key Vault 的步驟了，相關資訊可以上網找一下，應該蠻多的 當 Azure Key Vault 設定好時，為了要讓網站 (ASP.NET Core MVC) 可以將 Key Vault 上所設定的 Secret 資訊讀近來，還需要以下有幾個步驟 在 Azure Active Directory 下註冊應用程式 註冊完成後，到該應用程式下的【憑證與秘密】，新增 【用戶端密碼】 這邊需要記下兩個資訊，分別是 【應用程式 (用戶端) 識別碼】與 【用戶端密碼的值】 這邊如果不想要使用用戶端密碼的，可以使用憑證的方式 回到 Azure Key Vault 的服務內，授權應用程式可以存取 Key Vault 新增存取原則 設定相關的權限 選擇套用的主體，這邊是指剛剛所註冊的應用程式 完成新增動作 到這邊，就已經完成相關權限設定的部分，接下來就是程式端的設定 程式 需要安裝以下套件 Microsoft.Azure.Services.AppAuthentication Microsoft.Azure.KeyVault Microsoft.Extensions.Configuration.AzureKeyVault 在 appsettings.json 的地方新增此資訊 12345"KeyVault": &#123; "Vault": "xxx", "ClientId": "xxx", "ClientSecret": "xxx"&#125;, 當然這邊的 ClientId 和 ClientSecret 會放在 User secret 下，而不會是 appsettings.json 內 在 Program.cs 的地方做出以下調整 1234567891011121314151617181920212223public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureAppConfiguration((ctx, builder) =&gt; &#123; // 新增部分 var builtConfig = builder.Build(); var keyVaultEndpoint = GetKeyVaultEndpoint(builtConfig["KeyVault:Vault"]); if (!string.IsNullOrEmpty(keyVaultEndpoint)) &#123; var azureServiceTokenProvider = new AzureServiceTokenProvider(); var keyVaultClient = new KeyVaultClient( new KeyVaultClient.AuthenticationCallback( azureServiceTokenProvider.KeyVaultTokenCallback)); builder.AddAzureKeyVault( keyVaultEndpoint, keyVaultClient, new DefaultKeyVaultSecretManager()); &#125; &#125;) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;); // 新增部分 private static string GetKeyVaultEndpoint(string VAULT_NAME) =&gt; $"https://&#123;VAULT_NAME&#125;.vault.azure.net/"; 當完成這修改後，.NET Core MVC 就會優先從 Azure Key Vault 裡取得 secret 資料，讀取的方式與其他參數設定取法是一樣的 金鑰 (Keys) 至於金鑰的取法就比較特殊點，需要透過 KeyVaultClient 的方式來取得，而且也只能取得公開金鑰的部分，私有金鑰要做的事情，則會透過 KeyVaultClient 來完成。 要建立 KeyVaultClient 的方法如下 1234567private KeyVaultClient GetClient() =&gt; new KeyVaultClient(new KeyVaultClient.AuthenticationCallback(async (string authority, string resource, string scope) =&gt; &#123; var context = new AuthenticationContext(authority, TokenCache.DefaultShared); ClientCredential clientCred = new ClientCredential(configuration["KeyVault:ClientId"], configuration["KeyVault:ClientSecret"]); var authResult = await context.AcquireTokenAsync(resource, clientCred); return authResult.AccessToken; &#125;)); 執行 GetClient() 就可以取得 KeyVaultClient，當取得 client 後，就可以取得我們想要的金鑰，但這邊最簡單的方式是透過金鑰的識別碼 這邊的【金鑰識別碼】就是我們等等要用的資訊，先記起來，相關的程式碼會這樣子寫。 12345678910111213141516171819202122var KeyId = "xxx"; // 金鑰識別碼var client = GetClient();var hostKey = await client.GetKeyAsync(KeyId);// 取得 Public Key var rsa = hostkye.Key.ToRSA();var publicKey = rsa.ToXmlString(false);// 簽章var hasher = new SHA256CryptoServiceProvider();var digest = hasher.ComputeHash(data_buffer);var result = await client.SignAsync(KeyId, "RS256", digest);byte[] sign_buffer = result.Result;// 驗證簽章var sign_buffer = sign_getFromSomeWhere();var data_buffer = data_getFromSomeWhere();var rsa = new RSACryptoServiceProvider();rsa.FromXmlString(publicKey);var hasher = new SHA256CryptoServiceProvider();var digest = hasher.ComputeHash(data_buffer);var isVerfy = rsa.VerifyHash(digest, "Sha256", sign_buffer); 到這裡基本上就是一些 KeyVaultClient 的操作，當然還有其他更細節的東西，可能就要等我之後有玩更深入時，才能分享了 參考資料 Azure Key Vault Azure Key Vault Tutorial | Secure secrets, keys and certificates easily ASP.NET Core 中的 Azure Key Vault 設定提供者 [ASP.NET Core] 使用User Secret安全存放開發應用程式密鑰(VS 2017)]]></content>
      <categories>
        <category>Azure</category>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] 將 Angular 網站放在 App Service Linux Version 上]]></title>
    <url>%2F2020%2F06%2F15%2Fazure-app-service-linux-angular%2F</url>
    <content type="text"><![CDATA[要將 Angular 放在 Azure 上面的方法有很多種，而今天要介紹的是其中一種，App Service(Linux Version) 在 Azure 上面，使用 Linux 版本的價錢可以比 Windows 版本便宜許多，但如果想要放靜態網站時又該怎麼呢? 其實可以簡單透過 npm 上面的一個套件 serve 來完成，這樣就不用自己寫一個 Http Server。但如果是要給 Production 環境使用，還是建議使用正統的 http server 寫法 在 App Service 上面可以這樣子設定 可以透過啟動指令的方式來啟動我們想要執行的程式，所以如果是 node epxress 的情況下，就會是 node ./index.js 之類的 而部屬的動作就將 Angular build 出的專案資料夾內的檔案上傳到 App Service 即可]]></content>
      <categories>
        <category>Azure</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular FormGroup Value 之被忽略的細節]]></title>
    <url>%2F2020%2F05%2F06%2Fangular-formgroup-value%2F</url>
    <content type="text"><![CDATA[當在操作 Angular 表單時，於最後送出表單資料到 API 時，常見的使用方法為 formGroup.value 或是 formGroup.getRawValue() 兩種方法，關於 getRawValue() 大概也不用多贅述了。但你知道 FormGroup 的 value 取得資料的規則嗎 ? FormGroup.value 一般來說，FormGroup 的 value 會將該群組下的控制項資料取出，如下 123456formData1 = new FormGroup(&#123; firstName: new FormControl("Kevin"), lastName: new FormControl("Yang"),&#125;);console.log(formData1.value); // &#123;firstName: 'Kevin', lastName: 'Yang'&#125; 而第一個新手常會踩到的雷，會這遇到 FormControl 狀態是 Disabed 時，FormGroup 取出的值就不會是全部了 1234567formData1 = new FormGroup(&#123; firstName: new FormControl(&#123;value:"Kevin", disabled: true&#125;), lastName: new FormControl("Yang"),&#125;);console.log(formData1.value); // &#123;lastName: 'Yang'&#125;console.log(formData1.getRawValue()); // &#123;firstName: 'Kevin', lastName: 'Yang'&#125; 官方文件說明 For an enabled FormGroup, the values of enabled controls as an object with a key-value pair for each member of the group. 到這邊都還算正常，但你知道當 FormGroup 狀態為 Disabled 時，就會取出所有控制項的值嗎? 123456formData1 = new FormGroup(&#123; firstName: new FormControl(&#123;value:"Kevin", disabled: true&#125;), lastName: new FormControl("Yang"),&#125;);formData1.disable();console.log(formData1.value); // &#123;firstName: 'Kevin', lastName: 'Yang'&#125; 根據官網的說明 For a disabled FormGroup, the values of all controls as an object with a key-value pair for each member of the group. 但如果是這樣子的結構，會取得怎樣的值呢? 12345formData1 = new FormGroup(&#123; firstName: new FormControl(&#123;value:"Kevin", disabled: true&#125;), &#125;);console.log(formData1.value); // ?? 在第五行會顯示 {firstName: 'Kevin'}，這是一件我剛開始也覺得很困惑的現象，為什麼明明 FormControl 是 disabled 的狀態，但為什麼還能取得呢? 原始碼解析 在 FormGroup class 內有一個方法是在判斷目前 FormGroup 下的控制項是否全部為 Disabled ，如果是自己本身的狀態也會被設定為 Disabled 12345678 _allControlsDisabled(): boolean &#123; for (const controlName of Object.keys(this.controls)) &#123; if (this.controls[controlName].enabled) &#123; return false; &#125; &#125; return Object.keys(this.controls).length &gt; 0 || this.disabled;&#125; source code 因為這一個關係，上面那一個問題就會使用 FormGroup 為 Disabled 時的規則運行 參考資料 Angular API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Form 值變化 - 不踩雷就不會進步]]></title>
    <url>%2F2020%2F04%2F20%2Fangular-form-valuechanges%2F</url>
    <content type="text"><![CDATA[Angular Reacitve Form 內有一套值的更新流程，從 FormGroup 到 FormControl 間到底是如何進行資料的更新，有什麼要留意的地方，在這篇筆記內我盡量整理 (會持續潤稿) 首先先將重點放在 FormGroup 和 FormControl 這兩個主體上就好，我們都知道 FormGroup 和 FormControl 都是繼承 AbstractControl，不同的部分就在各 class 上重新撰寫 ，好加在的是這篇文章要看的程是碼都在同一個檔案上 而此篇要探討的是 setValue、patchValue 和 valuechanges 這三件事情，到底更新的流程是什麼，為什麼這件事情很重要，當在寫連動表單或是物件時，流程一但搞錯就會讓你除錯除到死 原始碼解析 FormControl 先從最底層的元件來看，對於 FormControl 來說，patchValue 與 setValue 是沒有差異的，即使呼叫 patchValue，還是會去執行 setValue 12345678 patchValue(value: any, options: &#123; onlySelf?: boolean, emitEvent?: boolean, emitModelToViewChange?: boolean, emitViewToModelChange?: boolean &#125; = &#123;&#125;): void &#123; this.setValue(value, options);&#125; 而 setValue 會執行的程是碼其實也不多，所有的工作都落在 updateValueAndValidity 上 12345678910111213setValue(value: any, options: &#123; onlySelf?: boolean, emitEvent?: boolean, emitModelToViewChange?: boolean, emitViewToModelChange?: boolean &#125; = &#123;&#125;): void &#123; (this as &#123;value: any&#125;).value = this._pendingValue = value; if (this._onChange.length &amp;&amp; options.emitModelToViewChange !== false) &#123; this._onChange.forEach( (changeFn) =&gt; changeFn(this.value, options.emitViewToModelChange !== false)); &#125; this.updateValueAndValidity(options); // 重點 function &#125; updateValueAndValidity 1234567891011121314151617181920212223updateValueAndValidity(opts: &#123;onlySelf?: boolean, emitEvent?: boolean&#125; = &#123;&#125;): void &#123; this._setInitialStatus(); this._updateValue(); if (this.enabled) &#123; this._cancelExistingSubscription(); (this as &#123;errors: ValidationErrors | null&#125;).errors = this._runValidator(); (this as &#123;status: string&#125;).status = this._calculateStatus(); if (this.status === VALID || this.status === PENDING) &#123; this._runAsyncValidator(opts.emitEvent); &#125; &#125; if (opts.emitEvent !== false) &#123; (this.valueChanges as EventEmitter&lt;any&gt;).emit(this.value); (this.statusChanges as EventEmitter&lt;string&gt;).emit(this.status); &#125; if (this._parent &amp;&amp; !opts.onlySelf) &#123; this._parent.updateValueAndValidity(opts); &#125; &#125; 主要程式碼是寫在 AbstractControl 裡 line 2: 取得目前物件的狀態，如果是 disabled 的話，則 status 將會是 DISABLED 不然就是 VALID line 3: 只有在 FormGroup 和 FormArray 有實做，根據目前 Group / Array 內子物件的值更新本身的值 1234567891011121314/** @internal */_updateValue(): void &#123; (this as &#123;value: any&#125;).value = this._reduceValue();&#125;/** @internal */_reduceValue() &#123; return this._reduceChildren( &#123;&#125;, (acc: &#123;[k: string]: AbstractControl&#125;, control: AbstractControl, name: string) =&gt; &#123; if (control.enabled || this.disabled) &#123; acc[name] = control.value; &#125; return acc; &#125;);&#125; line 5 ~ 13: 如果物件狀態是 enabled 才會進行驗證動作，驗證的順序為 同步驗證先執行，並更新狀態 如果狀態是 VALID 或是 PENDING 才會進行非同步驗證 根據傳入參數 emitEvent 來決定是否觸發 valueChanges 和 statusChanges 根據 onlySelf 來決定是否要觸發父層的 updateValueAndValidity 這裡有一個小技巧，所傳入的參數值並沒有設定預設值，而是很明確指定判斷值，這招可以學一下 123if (opts.emitEvent !== false) &#123; ...&#125; FormGroup patchValue 123456789patchValue(value: &#123;[key: string]: any&#125;, options: &#123;onlySelf?: boolean, emitEvent?: boolean&#125; = &#123;&#125;): void &#123; Object.keys(value).forEach(name =&gt; &#123; if (this.controls[name]) &#123; this.controls[name].patchValue(value[name], &#123;onlySelf: true, emitEvent: options.emitEvent&#125;); &#125; &#125;); this.updateValueAndValidity(options); &#125; 會先更新子物件，並設定只會更新子物件本身 在跑自己的 updateValueAndValidity 細節 一般使用基本上不會遇到什麼問題，但如果遇到連動的情況，就要特別小心 1234formData = new FormGroup(&#123; firstName: new FormControl(), lastName: new FormControl() &#125;); 情境 1 請各位想想根據第一段的原始碼解析，這邊跑出來結果會是什麼呢? 12345678910111213141516this.formData.valueChanges.subscribe(&#123; next: value =&gt; console.log("formGroup", this.formData.value)&#125;);this.formData.controls.firstName.valueChanges.subscribe(&#123; next: value =&gt; console.log("firstName:", value, "formGroup value:" ,this.formData.value)&#125;);this.formData.controls.lastName.valueChanges.subscribe(&#123; next: value =&gt; console.log("lastName:", value, "formGroup value:" ,this.formData.value)&#125;);this.formData.patchValue(&#123; firstName: "1", lastName: "2"&#125;); 結果如下 為什麼呢? 來模擬一下執行的步驟 formGroup.patchValue : 會根據傳進去的資料依序更新 firstname 與 lastName formControl firstName FormControl 更新自身的值，但因為 FormGroup 傳入 onlySelf 為 true，所以不會更新 parent 的值 lastName FormControl 更新自身的值，但因為 FormGroup 傳入 onlySelf 為 true，所以不會更新 parent 的值 FormGroup 執行 updateValueAndValidity 根據 children 更新自身的值 送出 valueChanges event 結束 情境 2 這邊跑出來結果會是什麼呢? 12345678910111213141516171819202122232425this.formData.valueChanges.subscribe(&#123; next: value =&gt; console.log("formGroup", this.formData.value)&#125;);this.formData.controls.firstName.valueChanges .pipe(tap(() =&gt; this.formData.controls.lastName.setValue("3"))) .subscribe(&#123; next: value =&gt; console.log( "firstName:", value, "formGroup value:", this.formData.value )&#125;);this.formData.controls.lastName.valueChanges.subscribe(&#123; next: value =&gt; console.log("lastName:", value, "formGroup value:", this.formData.value)&#125;);this.formData.patchValue(&#123; firstName: "1", lastName: "2"&#125;); 結果如下 你想對了嗎? 我們來模擬一下執行的步驟 formGroup.patchValue : 會根據傳進去的資料依序更新 firstname 與 lastName formControl firstName FormControl 更新自身的值，但因為 FormGroup 傳入 onlySelf 為 true ，所以不會更新 parent 的值 過程中去執行更新 lastName FormControl 的值 ，參數接為預設值，所以 emitEvent: true,onlySelf:false 觸發 lastName FormControl 的 valueChanges 觸發父層的 updateValueAndValidity firstName FormControl 自身 valueChanges 流程跑玩 lastName FormControl 更新自身的值，但因為 FormGroup 傳入 onlySelf 為 true，所以不會更新父層的值 FormGroup 執行 updateValueAndValidity 根據 children 更新自身的值 送出 valueChanges event 結束 情境 3 這邊跑出來結果會是什麼呢? 12345678910111213141516171819202122232425this.formData.valueChanges.subscribe(&#123; next: value =&gt; console.log("formGroup", this.formData.value)&#125;);this.formData.controls.firstName.valueChanges .pipe(tap(() =&gt; this.formData.controls.lastName.setValue("3", &#123;emitEvent: false&#125;))) .subscribe(&#123; next: value =&gt; console.log( "firstName:", value, "formGroup value:", this.formData.value )&#125;);this.formData.controls.lastName.valueChanges.subscribe(&#123; next: value =&gt; console.log("lastName:", value, "formGroup value:", this.formData.value)&#125;);this.formData.patchValue(&#123; firstName: "1", lastName: "2"&#125;); 結果如下，你想對了嗎? 情境 4 這邊跑出來結果會是什麼呢? 12345678910111213141516171819202122232425this.formData.valueChanges.subscribe(&#123; next: value =&gt; console.log("formGroup", this.formData.value)&#125;);this.formData.controls.firstName.valueChanges .pipe(tap(() =&gt; this.formData.controls.lastName.setValue("3", &#123;emitEvent: false, onlySelf: true&#125;))) .subscribe(&#123; next: value =&gt; console.log( "firstName:", value, "formGroup value:", this.formData.value )&#125;);this.formData.controls.lastName.valueChanges.subscribe(&#123; next: value =&gt; console.log("lastName:", value, "formGroup value:", this.formData.value)&#125;);this.formData.patchValue(&#123; firstName: "1", lastName: "2"&#125;); 結果如下，你想對了嗎? 情境 5 1234567891011121314151617181920212223242526272829303132333435this.formData.valueChanges.subscribe(&#123; next: value =&gt; console.log("formGroup", this.formData.value) &#125;);this.formData.controls.firstName.valueChanges .pipe( mergeMap(() =&gt; timer(1000, 0).pipe( take(1), tap(() =&gt; this.formData.controls.lastName.setValue("3", &#123; emitEvent: false, onlySelf: true &#125;))) ) ) .subscribe(&#123; next: value =&gt; console.log( "firstName:", value, "formGroup value:", this.formData.value )&#125;);this.formData.controls.lastName.valueChanges.subscribe(&#123; next: value =&gt; console.log("lastName:", value, "formGroup value:", this.formData.value)&#125;);this.formData.patchValue(&#123; firstName: "1", lastName: "2"&#125;); 結果如下，你想對了嗎? 心得 Reactive Form 將 valueChanges 包成 Observable 是很方便，要做一些連動的動作可以如流水般的操作，但問題是，如果資料流的線路沒搞對，就會發生為什麼這裡取的資料是錯的問題發生。這些細節的部分都是文件中沒有提到的 所以，在 FormControl 的 valuechanges 流中操作其它 FormControl 的值要特別小心，務必確認同步與非同步的發生順序]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AMP] First AMP Page]]></title>
    <url>%2F2020%2F04%2F16%2Famp-101%2F</url>
    <content type="text"><![CDATA[AMP = Accelerated Mobile Pages，Google帶領開發的開源專案，目的是為提升行動裝置對網站的存取速度。沒寫過，所以要來學，這一篇就是學習過程中的筆記 AMP 基本組成 一個合格的 AMP 一定要有以下的元素 第一行一定是 &lt;!doctype html&gt; 一定有 &lt;head&gt;&lt;/head&gt; 和 &lt;body&gt;&lt;/body&gt; 兩個區塊 &lt;html&gt; 標籤內要標示閃電符號 (&lt;html ⚡&gt;，或是 amp 文字 (&lt;html amp&gt;) &lt;head&gt; 的第一個元素一定是 &lt;meta charset=&quot;utf-8&quot;&gt; &lt;head&gt; 內會有 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1,initial-scale=1&quot;&gt; &lt;head&gt; 內要有 &lt;script async src=&quot;https://cdn.ampproject.org/v0.js&quot;&gt;&lt;/script&gt;，這一行越早寫越好 &lt;head&gt; 內要有 &lt;link rel=&quot;canonical&quot; href=&quot;$SOME_URL&quot;&gt;，$SOME_URL 要替換成目前頁面的網址，目的是要連結目前的 AMP 頁面到非 AMP 頁面或是網站 包含 AMP-Style: 這段程式碼會在 AMP Script 載入前將畫面隱藏 1&lt;style amp-boilerplate&gt;body&#123;-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both&#125;@-webkit-keyframes -amp-start&#123;from&#123;visibility:hidden&#125;to&#123;visibility:visible&#125;&#125;@-moz-keyframes -amp-start&#123;from&#123;visibility:hidden&#125;to&#123;visibility:visible&#125;&#125;@-ms-keyframes -amp-start&#123;from&#123;visibility:hidden&#125;to&#123;visibility:visible&#125;&#125;@-o-keyframes -amp-start&#123;from&#123;visibility:hidden&#125;to&#123;visibility:visible&#125;&#125;@keyframes -amp-start&#123;from&#123;visibility:hidden&#125;to&#123;visibility:visible&#125;&#125;&lt;/style&gt;&lt;noscript&gt;&lt;style amp-boilerplate&gt;body&#123;-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none&#125;&lt;/style&gt;&lt;/noscript&gt; AMP 限制 CSS 在 AMP 上面要使用自訂 CSS 有以下的設定 自訂 CSS 必須定義在 &lt;style amp-custom&gt;&lt;/style&gt; 內且只能有一個或是 inline-style，為了節省網路傳輸，不能有外部 style 連結 CSS 內容的部分大小不能大於 75 K 不能使用 !important 不能寫 i-amphtml- class 和 tag 名稱，簡單說不能使用 AMP Component 要用的名稱 其它能用不能用的 CSS Style 請參閱 Suppored CSS HTML 除了 CSS 有限制外，HTML 也有允許跟不允許使用的列表 ，HTML5 Tag 白名單 更多詳細資訊可以閱讀此文，AMP HTML Specification 開發思維 AMP 的開發方式，基本上是使用官方提供的 Component 去組出畫面，所以在內容呈現上就是要找到對的 Component 然後將內容套進去，例如 &lt;img&gt;，就會用 &lt;amp-img&gt; 替代 1&lt;amp-img src="IMG-URL" layout="responsive" width="640" height="480"&gt;&lt;/amp-img&gt; 所有的動作就交給 component 來處理，像是 RWD 的效果，除了 responsive 的效果外，當然還有其他的設定，設定方式請參閱官方文件 AMPHTML Layout System 章節 使用 AMP Components 每一個 AMP Component 在自己的 API 文件中，大部分都有 Required Scripts 的資訊，而這一個資訊就是要加到頁面中，例如 amp-youtube 元件 1&lt;script async custom-element="amp-youtube" src="https://cdn.ampproject.org/v0/amp-youtube-0.1.js"&gt;&lt;/script&gt; 基於這種架構，寫 AMP 的第一個門檻是要使用哪一個 component。(怎麼跟 Flutter 好像)，更多關於 Component 的可以參閱 Components 文件 驗證工具 Chrome 有出 AMP 驗證工具，安裝後即可使用，安裝位置 參考資料 AMP Beginning Free Course 整合重複的網址 canonical AMPHTML Layout System Components 文件]]></content>
      <categories>
        <category>AMP</category>
      </categories>
      <tags>
        <tag>AMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Podcast] Podcast 新手上路，有什麼是我需要準備的]]></title>
    <url>%2F2020%2F04%2F15%2Fpodcast-preparation%2F</url>
    <content type="text"><![CDATA[收聽 Podcast 的人比你想像中的還多很多，在台灣也有很多有優質的 Podcast 節目，這裡我整理了一些開自己 Podcast 所需要準備的基本工作 開 Podcast 節目其實不難，可以分幾個部分來看 企劃 一個節目最重要的是內容及走向，這裡所指的走向是風格，想要呈現怎樣的節目風格? 時間長度? 這些都是要在開始製作前需要思考的部分。 一但決定好風格內容後，接下來的另外一個難題就是節目名稱，節目名稱的困難點是如何帶給聽眾一個記憶點，或是凸顯主持人的個性，可以花點時間，好好的思考一下。 接下來的節目規畫部分就比較簡單了，每一個製作 Podcast 的人風格都不一樣，有些人喜歡將稿先擬好，然後進量不要脫稿演出，有些人喜歡列出這次要講的大綱，更有些人就直接上了，找出適合自己的方式，畢竟 Podcast 是一個需要時間的長期創作，找到適合的工作方式可以讓自己持續下去。 軟體 平台 規劃面到一個段落後，就可以來尋找錄出來的節目要放在哪裡，所幸目前的年代已經有很多很方便的平台與服務，可以幫我們處理這一塊的工作，以三宅一聲來說，我們是放在 anchor.fm上，這是國外的平台，這一類的平台台灣也有，例如 Firstory，這些平台可以讓你放節目上去並幫你轉發布到其它媒介，例如 Spotify、iTune、Google Podcast 等。另外一種是自有平台，例如 SoundOn、八寶網路廣播，這一類的平台就是透過自己的 App 平台收聽廣播。 就挑一個自己操作上沒有問題的平台先做，有很多節目到最後都是各平台都有放 編輯軟體 聲音檔的編輯軟體，最常見的是 Audacity，這軟體除了可以編輯外，也可以做為錄音的軟體，所以只要在自己的電腦上安裝這軟體，接上麥克風就可以開始錄製節目了。 遠端錄音 這部分就有點麻煩，目前能透過網路錄製聲音的工具不多，以下就列出幾個可以錄的 Zoom: 這線上開會軟體，有提供分軌錄音的功能，錄製出來的音質也不錯，除了開起來很耗電腦資源外，算是一個不錯的選擇 Discord: 這是在打遊戲的人比較知道的通訊軟體，音質跟延遲都有不錯的表現，也有人提供錄音用的 Bot，叫 Craig，這一個 Bot 也可以做到分軌錄音的功能，但就是將音訊檔儲存在雲端空間，等結束錄音後，Bot 會提供對應的下載網址，使用上也不複雜 anchor.fm 手機 App 有提供多人錄音的功能，沒實際使用過 如果有其它不錯的遠端錄音方式，也在下方留言交流一下。 硬體 或許會問一定要有電腦才能製作 Podcast 節目嗎? 其實現在每一個人手邊的手機，就是一個不錯的錄音設備，利用他就可以製作出一個高品質的節目，但還是有一些必須擁有的設備，可以讓節目品質更往上走。 麥克風 一支好的麥克風是很重要的，除了可以將主持人的聲音個性好好地收錄起來，畢竟廣播節目就只有聲音，聲音品質的呈現就非常重要，算是必要投資。但麥克風的價位差異真的很大，至於要選那一種麥克風也是另外一門學問了，這裡就列出最低最低的需求，手機使用的免持耳機，至少要有這個吧 。(這個也適用在線上會議，不要在用筆電內建的麥克風了) 監聽耳機 為什麼要用耳機，是要避免麥克風再次收到由喇叭發出的聲音，其次有些比較好的耳機或是錄音介面有提供監聽的輸出介面，可以聽見自己的聲音呈現的方式也是提升節目品質的重要環節。 錄音環境 安靜沒有背景雜音的地方，不要太空曠，因為聲音會反彈會讓麥克風收到的聲音有回音，而且會有空洞的感覺。假如你的房間很空洞，多放點雜物，讓聲音的反彈行為被破壞掉就可以了，或是去買吸音棉貼在講話方向的正前方也是一種方式 對於外界的環境音，這部分能透過氣密窗或是比較厚的窗簾來做阻隔，在搭配一隻高指向性的麥克風就可以將環境噪音降到最低 宣傳 FB 是一個還不錯的地方，除了自己的空間外，還有很多跟 podcast 相關的社團可以加入，例如: Podcast Club 我的設備清單 電腦錄音 Zoom / Discord 麥克風: Blue Yeti 監聽耳機: 普通的手機耳麥 編輯軟體: Audacity 發佈平台: Anchor FB 粉專: 三宅一聲 自架網站: 3 Nerds 希望入手的設備清單 Rode Caster Pro Rode podcaster Rode podmic 參考資料 八寶 - 新手上路]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] 該如何設定 JSON 物件到 App Servie Configuration 中]]></title>
    <url>%2F2020%2F04%2F12%2Fazure-appservice-configuation-with-nest-object%2F</url>
    <content type="text"><![CDATA[我們都知道 Production 的設定檔應該要放在 Azure App Service 或是其他相關的地方，不應該將該設定檔簽入到版控中，但是，當愈到這種設定檔時，App Service 該如何設定呢? 1234567"AzureAdB2C": &#123; "Instance": "https://xxx.xxxx/", "ClientId": "...", "CallbackPath": "...", "Domain": "...", "SignUpSignInPolicyId": "..." &#125; 在 .NET Core 的程式碼內，可以透過 : 的方式取得階層型態的設定檔，例如 AzureAdB2C:Instance，但是在 Linux 的 App Service 是不能使用冒號，所以要用兩個底線代替冒號 In a default Linux container or a custom Linux container, any nested JSON key structure in the app setting name like ApplicationInsights:InstrumentationKey needs to be configured in App Service as ApplicationInsights__InstrumentationKey for the key name. In other words, any : should be replaced by __ (double underscore). 參考資料 Configure an App Service app in the Azure portal]]></content>
      <categories>
        <category>Azure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Taipei Standard Time 在 Linux 上找不到 ?]]></title>
    <url>%2F2020%2F04%2F12%2Fdotnet-core-timezone-on-linux%2F</url>
    <content type="text"><![CDATA[.NET Core 在 Linux 環境上遇到設定時區時，會遇到這一個錯誤訊息 The time zone ID 'Taipei Standard Time' was **not** found on the local computer. ，這一個問題在 mac 上也會遇到，主要是因為以前 .Net 只能跑在 windows 上，所以不會遇到這個問題，而當現在 .NET Core 跑在 Linux 環境上就會遇到這類似的問題 解法很簡單，判斷目前跑的環境是什麼，然後給予正確的時區名稱即可 12345using System.Runtime.InteropServices;string id = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "Taipei Standard Time" : "Asia/Taipei";TimeZoneInfo tw = TimeZoneInfo.FindSystemTimeZoneById(id); 當這樣子寫完，問題就解決了]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Blazor] 基本 Blazor Component 筆記]]></title>
    <url>%2F2020%2F04%2F04%2Fblazor-basic-component-page%2F</url>
    <content type="text"><![CDATA[Blazor 畫面基本組成是 Razor Component 物件，他可以是顯示元件，也可以是頁面之一，所有的設定都在 .razor 的檔案內做設定，以下是一些在開發過程中，覺得比較重要的筆記內容 筆記 Code Behind 預設 Blazor Component 的寫法是將 HTML 與 Code 寫在同一個檔案內，但當程式碼比較複雜的時候，寫在同一個畫面就會變得比較麻煩，或是習慣將 HTML 和 Code 分開寫的朋友，這個是 Code Behinde 的寫法 建立一個與 blazor 物件名稱一樣但附檔名為 .cs 的檔案，例如 Episode.razor.cs，這樣子命名 Visual Studio 就會自動合在一起顯示 在 editor.razor.cs 的程式碼內，繼承 ComponentBase 12345using Microsoft.AspNetCore.Components;public class EpisodeBase: ComponentBase&#123; &#125; 在 Episode.razor 檔案繼承上列的 class 1@inherits EpisodeBase 這樣就可以做到 Code Behind 的效果 注入 原本的寫法是 1@inject SampleSerivce samepleService 當單獨寫一個 class 時，則要這樣子寫 12345public class EpisodeBase: ComponentBase&#123; [Inject] public SampleService sampleService &#123;get; set;&#125;&#125; 多重路由規則 一個 Blazor component 可以擁有多個路由規則，設定方式就是寫多個 @page 就可以了 12@page "/manage/new"@page "/manage/&#123;id:int&#125;" 當有使用到變數時，則須同時宣告 parameter 12[Parameter]public int Id &#123; get; set; &#125; Markdown Editor 套件選擇: Markdig html 1234567891011121314&lt;div class="row"&gt; &lt;div class="form-group col-6"&gt; &lt;label for="description"&gt;描述&lt;/label&gt; &lt;textarea class="form-control" id="description" rows="10" @bind="formData.Description" @bind:event="oninput"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="col-6"&gt; &lt;span&gt;Preivew&lt;/span&gt; &lt;div&gt; @((MarkupString) Preview) &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; code 12public FormData formData = new FormData();public string Preview =&gt; Markdown.ToHtml(formData.Description); 文字結合變數 在 blazor component 顯示下，如果寫 somepage/@data.Id ，編譯時會抱怨便顯示這個錯誤 Blazor RZ9986 — Component attributes do not support complex content (mixed C# and markup) 簡單的解法是指用 string template formate 的方式改寫，當改成 @($&quot;somepage/{data.Id}&quot;)，就可以成功編譯 生命週期 Blazor 的生命週期有幾個，且有分同步與非同步，這部分要留意 初始化 同步: OnInitialized 1234protected override void OnInitialized()&#123; ...&#125; 非同步: OnInitializedAsync 1234protected override async Task OnInitializedAsync()&#123; await ...&#125; 設定參數 之前 123456public override async Task SetParametersAsync(ParameterView parameters)&#123; await ... await base.SetParametersAsync(parameters);&#125; 之後 非同步 1234protected override async Task OnParametersSetAsync()&#123; await ...&#125; 同步 1234protected override void OnParametersSet()&#123; ...&#125; 剩餘其他的，請參閱生命週期章節 參考資料 要求元件中的服務 路由範本 生命週期]]></content>
      <categories>
        <category>Blazor</category>
      </categories>
      <tags>
        <tag>Blazor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Blazor] 自動重新整理 (auto reload)]]></title>
    <url>%2F2020%2F04%2F04%2Fblazor-reload-after-save%2F</url>
    <content type="text"><![CDATA[在開發 Blazor 時，最常遇到的問題是儲存完程式後，還需要手動重新更新瀏覽器的頁面，除了那個提示畫面很礙眼外，竟然還要手動，以下是一個小技巧可以自動更新頁面 除了保哥寫的這篇文章外，如何讓 ASP.NET Core Blazor Server 在斷線時不影響頁面瀏覽。在 _Host.cshtml 的頁面下加入這段程式碼就可以做到自動更新 12345&lt;script&gt; Blazor.defaultReconnectionHandler._reconnectCallback = function (d) &#123; document.location.reload(); &#125;&lt;/script&gt; 我是放在 &lt;script src=&quot;_framework/blazor.server.js&quot;&gt;&lt;/script&gt; 的後面。當加上這段程式碼後，畫面就會在連線重新連上時自動更新畫面 如果想限定加入這段 script 的時機點，可以搭配 &lt;environment include=&quot;Development&quot;&gt; 使用]]></content>
      <categories>
        <category>Blazor</category>
      </categories>
      <tags>
        <tag>Blazor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OBS] 跑馬文字]]></title>
    <url>%2F2020%2F04%2F02%2Fobs-tips-2%2F</url>
    <content type="text"><![CDATA[使用 OBS 內建的功能就可以完成跑馬燈的效果，而以下是使用方法 但這之前，要先了解如何新增顯示文字到 OBS 上 新增文字 在 Source 的地方選擇新增 Text(GDI+) Font: 設定文字字型、樣式、大小等 Text: 要顯示的文字 Text Transform: 設定英文字大小寫顯示規則 None: 不調整 Upper Case: 全部大小 Lower Case: 全部小寫 Start Case: 單字開頭文字大小 Vertical: 垂直顯示 Color: 設定文字顯示顏色 Opacity: 飽和度 Gradient: 是否開啟顏色漸層效果，開啟後可以選擇第二個顏色達到漸層效果 Background Color: 背景顏色設定 Background Opacity: 背景顏色飽和度 Alignment / Vertical Alignment: 對齊方式 Use Custom Text Extents: 自訂文字顯示範圍 當然也可以將檔案的文字讀進來顯示，將 Read from file 勾選起來就可以了，選取檔案後，當檔案內容改變時，要顯示的文字也會跟著改變，雖然有些延遲，但還在可以接受的範圍內 跑馬燈效果 要讓文字跑起來，就要再多加一個 filter 到文字 source 上，透過 scroll filter 就可以做到跑馬燈的效果 新增完 scroll filter 後，透過設定 Horizontal Speed 和 Vertical Speed 來決定文字移動的方向及速度，就是這麼簡單]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OBS 技巧筆記] OBS-NDI]]></title>
    <url>%2F2020%2F04%2F02%2Fobs-tips-1%2F</url>
    <content type="text"><![CDATA[OBS 是一套功能強大而且免費的直播軟體，我會將一些我覺得不錯的功能寫成筆記分享出來，今天先介紹 OBS-NDI 這個擴充功能。 NDI 是 NewTek 這間公司發展出來的一個網路協定，全名是 Network Device Interface，詳細功能就讓各位去查了，簡單的說，他可以將影像訊號透過網路的方式傳遞，而且中間的延遲非常的低 而 OBS 當然也有人寫擴充套件，讓 OBS 也能支援 NDI 這個功能，套件名稱是 obs-ndi，還沒有安裝的，就先按網站的步驟安裝下載吧，windows/mac 都可以使用 當安裝完 OBS-NDI 後，OBS 就支援 Input/Output NDI Source 的功能了 Input 當要將外部的 NDI Source 加到 OBS 內，可以透過 add NDI Source 的方式完成 當區域網路內有 NDI Source 存在時，Source name 的下拉選單就可以看到該來源的名稱 Bandwidth: 頻寬使用量，在不使用 NDI|HX 的模式下，選擇 Highest 的可以取的高畫質低延遲的影像，這裡指的低延遲，大概就一個 frame 的延遲，但頻寬使用就很高，這也是為什麼一定要在使用有線網路的環境下跑 其他的設定基本上預設就可以了 按下 Ok 完成後，剩下的操作就跟其他 OBS 的操作一樣，很簡單的 Output 如果想要讓 OBS 所設定好的畫面輸出給其他支援 NDI 的軟體或介面使用的話，可以開啟 output 的功能 當開啟 Output 時，OBS 也會認定目前處於直播的狀態，所以相關的設定也會被關起來不能被修改。以下為一些可以使用的情境 NDI Virtual Input: 將 NDI Source 模擬成 Webcam，讓可以使用 webcam 的軟體看到此訊號 第二台電腦的直播訊號來源，因為直播需要消耗主機支援，可以透過使用第二台電腦來減少主電腦的資訊損耗，這時候透過 NDI 就可以很簡單的將訊號傳給第二台電腦 擷取桌面。給直播主機使用，除了使用 OBS 擷取桌面外，也可以使用這一個軟體 VMIX Desktop capture 軟體 (下載位置)，使用方式很簡單，下載開啟就可以使用了 如果 NDI Source 抓不到，可能是防火牆的問題 Filter OBS-NDI 還有另外一個很實用的功能，就是可以將某 Source 設定為單獨輸出的 NDI Source，但這邊就需要使用 Filter 的功能 NDI Name 的地方就是輸出出去的名稱，這樣子除了 Main/Preview 的訊號外，還可額外取得某 Source 的 NDI 訊號 這功能就可以讓設定直播畫面更加有彈性，當然除了影像外，聲音也可以設定一樣的 Filter，但就只有聲音訊號 延遲測試]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Material Datepicker 遇到民國年]]></title>
    <url>%2F2020%2F03%2F23%2Fmaterial-datepicker-taiwan%2F</url>
    <content type="text"><![CDATA[上周接到一個很討厭的需求，對方想要日期選擇時可以用民國年，其實有在處理日期選擇元件的人多少都會遇到這個需求，基本上就是討厭，但該做的還是要做，那 Angular Material Datepicker 要怎麼處理呢? 其實也不複雜，因為 Angular Material Datepicker 有提供 DateAdapter 的介面可以實做，但又因為從頭做起太痛苦了，只好借用現有的 MomenetDateAdapter 來擴充了，以下是幾個地方需要調整 parse: 處理使用者輸入日期時，要轉換成對的時間 format: 將日期顯示成要顯示的樣子 getYearName: 在選擇年的頁面顯示 擴充 前置作業 因為是要擴充 MomentDateAdapter，所以比較保險的方式，是擴充 momenet，讓其可以幫忙處理民國年，網路上面是有一個 momenet-taiwan 的 plugin，但由於 Moment 在 Angular 內的取得方式不太一樣，所以該套件不能直接使用，但裡面所寫的程式碼是可以拿來直接使用，該段程式碼的基本概念是拿 moment 物件直接在上面擴充新功能，相關的程式碼可以參考這個 Gist 在 MomentDateAdapter 的部分就直接繼承 12345678910111213141516@Injectable()export class MyMomentDateAdapter extends MomentDateAdapter &#123;&#125;..@NgModule(&#123; ... providers:[ ... &#123; provide: DateAdapter, useClass: MyMomentDateAdapter, deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS] &#125; ]&#125;) format DateAdapter 的 format 是用來處理顯示的樣式，其樣式可以透過 MAT_DATE_FORMATS 做設定，介面如下 1234567891011type MatDateFormats = &#123; parse: &#123; dateInput: any; &#125;; display: &#123; dateInput: any; monthYearLabel: any; dateA11yLabel: any; monthYearA11yLabel: any; &#125;;&#125; 所以 format 的方法除了原本的日期值外，還會有 displayFormat 的資訊傳入 1234567format(date: Moment, displayFormat: string): string &#123; date = this.clone(date); if (!this.isValid(date)) &#123; throw Error('MomentDateAdapter: Cannot format invalid date.'); &#125; return date.format(displayFormat);&#125; 根據我們的需求只需要改變回傳的文字即可，由於我們上面已經有寫好 moment 民國年的擴充方法，所以只要將 moment 加工一下拿來使用即可 12345678910111213141516import * as _moment from 'moment';import &#123; MomentFactory &#125; from './moment-factory';...@Injectable()export class MyMomentDateAdapter extends MomentDateAdapter &#123; moment = MomentFactory(_moment); ... format(date: Moment, displayFormat: string): string &#123; date = this.clone(date); if (!this.isValid(date)) &#123; throw Error('MomentDateAdapter: Cannot format invalid date.'); &#125; return this.moment(date).format(displayFormat); &#125;&#125; 經過這樣子的調整後就可以 parse parse 的功能是將使用者輸入的文字轉換成日期型，所以這裡的功能是將輸入的民國年文字轉換成西元年的日期型 1234567891011121314151617181920212223242526272829303132@Injectable()export class MyMomentDateAdapter extends MomentDateAdapter &#123; moment = MomentFactory(_moment); constructor( @Optional() @Inject(MAT_DATE_LOCALE) dateLocale: string, @Optional() @Inject(MAT_MOMENT_DATE_ADAPTER_OPTIONS) private options?: MatMomentDateAdapterOptions ) &#123; super(dateLocale, options); this.setLocale(dateLocale || this.moment.locale()); &#125; parse(value: any, parseFormat: string | string[]): Moment | null &#123; if (value &amp;&amp; typeof value === 'string') &#123; return this.createMoment(value, parseFormat, this.locale); &#125; return value ? this.createMoment(value).locale(this.locale) : null; &#125; private createMoment( date: _moment.MomentInput, format?: _moment.MomentFormatSpecification, locale?: string ): Moment &#123; const &#123; strict, useUtc &#125;: MatMomentDateAdapterOptions = this.options || &#123;&#125;; return useUtc ? this.moment.utc(date, format, locale, strict) : this.moment(date, format, locale, strict); &#125; ...&#125; 看起來程式碼比較多，但其實就是將文字轉換成日期型而已 getYearName getYearName 這一個比較討厭，因為在原本的設計並沒有將這一個顯示的格式做成動態設定，必須手動寫死，這一個方法是用來顯示年度選擇的那個頁面 123getYearName(date: Moment): string &#123; return this.moment(this.clone(date)).format('tYY');&#125; 對應到 Material Datepicker 的程式碼是 12345/** Creates an MatCalendarCell for the given year. */ private _createCellForYear(year: number) &#123; let yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1)); return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year)); &#125; source code 完整程式碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; Inject, Injectable, Optional &#125; from '@angular/core';import &#123; MatMomentDateAdapterOptions, MAT_MOMENT_DATE_ADAPTER_OPTIONS, MomentDateAdapter&#125; from '@angular/material-moment-adapter';import &#123; MAT_DATE_LOCALE &#125; from '@angular/material/core';import * as _moment from 'moment';import &#123; Moment &#125; from 'moment';import &#123; MomentFactory &#125; from './extend-factory';@Injectable()export class MyMomentDateAdapter extends MomentDateAdapter &#123; moment = MomentFactory(_moment); constructor( @Optional() @Inject(MAT_DATE_LOCALE) dateLocale: string, @Optional() @Inject(MAT_MOMENT_DATE_ADAPTER_OPTIONS) private options?: MatMomentDateAdapterOptions ) &#123; super(dateLocale, options); this.setLocale(dateLocale || this.moment.locale()); &#125; getYearName(date: Moment): string &#123; return this.moment(this.clone(date)).format('tYY'); &#125; parse(value: any, parseFormat: string | string[]): Moment | null &#123; if (value &amp;&amp; typeof value === 'string') &#123; return this.createMoment(value, parseFormat, this.locale); &#125; return value ? this.createMoment(value).locale(this.locale) : null; &#125; format(date: Moment, displayFormat: string): string &#123; date = this.clone(date); if (!this.isValid(date)) &#123; throw Error('MomentDateAdapter: Cannot format invalid date.'); &#125; return this.moment(date).format(displayFormat); &#125; private createMoment( date: _moment.MomentInput, format?: _moment.MomentFormatSpecification, locale?: string ): Moment &#123; const &#123; strict, useUtc &#125;: MatMomentDateAdapterOptions = this.options || &#123;&#125;; return useUtc ? this.moment.utc(date, format, locale, strict) : this.moment(date, format, locale, strict); &#125;&#125; 參考資料 moment-taiwan]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[實用] 如何使用 Zoom 來開線上活動]]></title>
    <url>%2F2020%2F03%2F03%2Fzoom-create-event%2F</url>
    <content type="text"><![CDATA[Zoom 這套線上會議軟體，從我一開始使用他到現在，整個的功能與介面都有很大幅度的提升，說實話，如果有線上會議的需求，Zoom 這個服務是一個不錯的選擇，而今天這篇文章來分享一下，Zoom 在建立會議時，可以做到那些事情，在辦線上活動時，又能如何利用這些功能 預約會議 預約會議的功能雖然可以透過桌面應用程式完成，但透過網頁的方式預約會議，能做到更多的事情 登入 zoom.us 的網站後台並點選【排程會議】 填入會議的相關資訊 如果想要利用 zoom 會議功能辦線上活動的人，會議排程項目中的【註冊】功能，就是一個不錯的功能，先啟動起來，之後可以做到更多的設定 註冊 確定儲存後，就會帶到會議的細節設定頁面，這裡會針對剛剛勾選【註冊】可以設定的項目 註冊選項可以設定的有 也可以檢視註冊者有哪些人 電子郵件設定的部分可以設定活動聯絡用的 Email 及窗口名稱，也可以客製化郵件內容 當然要更專業一點，可以在品牌化的地方上傳 Banner 與 Logo 的圖，而這些圖也會放到電子郵件中 而活動參加者則可以透過 Zoom 所提供的註冊頁面進行活動註冊 使用者一旦完成註冊，會收到活動註冊成功的信件，當所註冊的活動有所異動或是取消，註冊者也會收到相關的訊息，十分方便 問卷調查 在安排活動時，可以事先輸入想要詢問活動參加者的問題，做一些問卷調查，這些調查的結果也可以從之後的報告中取得 直播功能 Zoom 的 meeting 也有提供直播功能，除了 zoom 本身的會議功能外，也可以直撥到 Facebook、Facebook workspace、YouTube 或是自定的直播服務 會議中 在會議中，主持人可以做的事情有 錄影 控制參加者的麥克風是否靜音 直播啟動與否 建立問卷調查 開啟分組討論 (另外一篇文章分享) 指定聯合主持人 分享桌面 參加者可以做 分享桌面 使用聊天，不論是公開或是針對某人的私下聊天 回答問卷等等 報告 開啟註冊功能的另外一個好處是可以在報告的功能中，取得更詳細的資訊，報告的功能是為在 管理員 -&gt; 帳戶管理 -&gt; 報告 當點選報告功能時，可以看到的報告種類其實還不少，管理者看到的報告資訊是全組織的，假如會議有勾選註冊功能，則可以在這 【會議】的分類下看到報表 從這個報表中，就可以產出會議(活動)的報名資訊及問卷調查的結果(民意調查報告)，如果有需要做後續的追蹤，這一個報告資訊其實還蠻完整的 小結 使用 Zoom 這服務也好幾年了，一開始會使用是因為要辦 Angular 線上讀書會，結果一租就租用到現在。如一開始所說的，只要有在使用而且用起來順手，付費的服務都不是問題，因為獲得的價值早已遠大於付出的價格]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 不要在 Angular template expression 中使用 function，這是不好的]]></title>
    <url>%2F2020%2F02%2F14%2Fangular-dont-use-function-in-template-expression%2F</url>
    <content type="text"><![CDATA[Angular 原本的顯示效能，在沒有刻意調教的情況下，已經有不錯的表現，但如果有不當的寫法出現，依然可造成如 AngularJS 一樣顯示效能低落的問題，這是可以避免的狀況，只要稍微多留意一些 這一篇文章將會針對 HTML Template 的部分，一個小地方沒留意，就可以大大的拖累整個顯示效能 Angular 顯示變數到畫面上的方式，基本語法如下 1&#123;&#123; some-variable &#125;&#125; 當資料稍微複雜一點或是想要顯示組合文字時，有能會使用 function 來代替變數，而這一個動作將會造成很大的效能問題，這裡有一個簡單的範例程式來展示使用 function 會造成 Angular Change Detector 過勞 123456789101112131415161718import &#123; Component, OnInit, Input, SimpleChanges &#125; from '@angular/core';import &#123; User &#125; from '../data';@Component(&#123; selector: 'app-user', templateUrl: './user.component.html', styleUrls: ['./user.component.css']&#125;)export class UserComponent &#123; @Input() user: User; calculateFullNameCounter = 0; fullName() &#123; this.calculateFullNameCounter++; return `$&#123;this.user.name&#125;($&#123;this.user.username&#125;)`; &#125;&#125; 12&lt;p&gt;使用者: &lt;strong&gt;&#123;&#123; fullName() &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&lt;p class="amount"&gt;計次: &lt;span&gt;&#123;&#123; calculateFullNameCounter &#125;&#125;&lt;/span&gt;&lt;/p&gt; AppComponent 12345678910111213141516171819202122232425262728293031import &#123; Component &#125; from '@angular/core';import &#123; users &#125; from './data';@Component(&#123; selector: 'app-root', template: ` &lt;button (click)="next()"&gt;下一位&lt;/button&gt; &lt;button (click)="justclick()"&gt;只是一個觸發 CD 的按鈕&lt;/button&gt; &lt;app-user [user]="currentUser"&gt;&lt;/app-user&gt; `, styles: []&#125;)export class AppComponent &#123; title = 'nofninexpression'; users = users; currentUser; currentIndex = 0; ngOnInit() &#123; this.currentUser = this.users[this.currentIndex]; &#125; next() &#123; ++this.currentIndex; if (this.currentIndex &gt;= this.users.length) &#123; this.currentIndex = 0; &#125; this.currentUser = this.users[this.currentIndex]; &#125; justclick() &#123;&#125;&#125; 執行結果 (範例程式碼) 當按下上方的【只是一個觸發 CD 的按鈕】，會發現計次的數字又多跳了好幾個 (請忽略這個錯誤，這個錯誤是為了要顯示數字而造成的)，但到底為什麼? Angular 的 Change Detection 會決定畫面上那一部分的內容需要被重新產生，所以他會比較這次的值與上一次的值是否相同，如果有不同時，就會重新顯示該區塊的畫面，但是 Change Detection 卻沒有辦法確認 function 回傳值是否與上次相同，故每一次都會被重新顯示畫面，整個 App 或是該 Component 被觸發了 100 次 CD (Change Detection)，那 function 就會被執行 100 次 或許你會想使用 onPush 是否會有幫助 (範例程式碼)? 而答案是確實會有幫助，在 Component 的 ChangeDetection 策略 設定為 onPush 時，確實只會讓 Component 本身與外界做隔離，但是，如果是 Component 本身的 CD 觸發時，例如按鈕的 click 等事件，所以還不是一個最佳的解法 以下提供兩種思考方向，來解決上述的問題 解決方案 手動 所謂的手動，是指事先將資料加工並儲存到另外一個變數上，不論是原本的 data model 或是額外的變數都可以，在畫面顯示該變數即可 12345678910111213141516171819202122232425262728293031...@Component(&#123; selector: "app-user", templateUrl: "./user.component.html", styleUrls: ["./user.component.css"], changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class UserComponent &#123; @Input() user: User; calculateFullNameCounter = 0; calculateDisplayFullNameCounter = 0; fullName; ngOnChanges(change: SimpleChanges) &#123; if (change.user) &#123; this.fullName = this.transformData(); &#125; &#125; displayfullName()&#123; this.calculateDisplayFullNameCounter++; return `$&#123;this.user.name&#125;($&#123;this.user.username&#125;)`; &#125; transformData() &#123; this.calculateFullNameCounter++; return `$&#123;this.user.name&#125;($&#123;this.user.username&#125;)`; &#125; onMouseMove() &#123;&#125;&#125; 12345678910&lt;h1&gt;使用 function 顯示欄位&lt;/h1&gt;&lt;p&gt;使用者: &lt;strong&gt;&#123;&#123; displayfullName() &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&lt;p class="amount"&gt;計次: &lt;span&gt;&#123;&#123; calculateDisplayFullNameCounter &#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;手動整理顯示欄位&lt;/h1&gt;&lt;p&gt;使用者: &lt;strong&gt;&#123;&#123; fullName &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&lt;p class="amount"&gt;計次: &lt;span&gt;&#123;&#123; calculateFullNameCounter &#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;Trigger change detection&lt;/h1&gt;&lt;p (mousemove)="onMouseMove()" class="hover-area"&gt;移動滑鼠觸發 CD &lt;/p&gt; 可到這裡看執行結果，會發現當手動先處理顯示欄位時，不論 CD 被觸發多少次，計次都不會增加，除了切換至下一位使用者 Pipe 另外一種方式是透過 Pipe 的方式顯示，因為 Pipe 預設的行為是 pure 的，等同於 onPush，所以只有在串接的值有異動時才會被觸發執行 123456789101112import &#123; Pipe, PipeTransform &#125; from "@angular/core";import &#123; User &#125; from "../data";@Pipe(&#123; name: "displayFull"&#125;)export class DisplayFullPipe implements PipeTransform &#123; transform(user: User): any &#123; console.log('pipe been trigger') return `$&#123;user.name&#125;($&#123;user.username&#125;)`; &#125;&#125; 12345...&lt;h1&gt;使用 Pipe 顯示欄位&lt;/h1&gt;&lt;p&gt;使用者: &lt;strong&gt;&#123;&#123; user | displayFull &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&lt;p class="amount"&gt;計次: &lt;span&gt;請看 console &lt;/span&gt;&lt;/p&gt;... 當開啟 F12 看 Console 紀錄時，也只會看到 pipe 被觸發的時間點是 Input 的 User 資料改變時 範例程式碼 結論 雖然在 Template 上寫 Function 顯示很快速，但這就是一種技術債，當要還的時候還是得還，一開始就乖乖地寫不就好了，但如果要我選預設的處理方式，大概會是手動先將資料處理完成後，在來顯示，而 Pipe 的使用時機點是通用方法可以共用時，例如換行符號的更換等 參考資料 完整範例程式碼(https://stackblitz.com/edit/angular-8qsqdr)]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 使用 KeyValuePipe 的小地雷]]></title>
    <url>%2F2020%2F02%2F13%2Fangular-keyvaluepipe%2F</url>
    <content type="text"><![CDATA[Angular 6 版推出了 KeyValue Pipe，可以讓我們在 HTML 上使用 ngFor 跑 Object 或是 Map 型態的資料，但是，這裡面有一個小雷，一個不注意就會踩進去，那就是排序 但這一個雷在官網的 API 文件中有提到，以下是說明 The output array will be ordered by keys. By default the comparator will be by Unicode point value. You can optionally pass a compareFn if your keys are complex types. 在不讀文件就使用，會讓你 debug 到天荒地老。但這表示我們可以傳入排序的比較函式了，以下是使用方式 1&#123;&#123; input_expression | keyvalue [: compareFn] &#125;&#125; input 值須為 { [key: string | number] : V } | Map compareFn: (a:keyValue, b: keyValue) =&gt; number 範例 12345678910111213141516171819202122232425import &#123; Component &#125; from "@angular/core";@Component(&#123; selector: "my-app", template: ` &lt;h1&gt;Display Object Value&lt;/h1&gt; &lt;pre&gt; &#123;&#123; data | json &#125;&#125; &lt;/pre&gt; &lt;ul&gt; &lt;li *ngFor="let item of (data | keyvalue)"&gt; &#123;&#123; item.key &#125;&#125; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class AppComponent &#123; name = "Angular"; data = &#123; userId: 1, id: 1, title: "delectus aut autem", completed: false &#125;;&#125; 執行結果 可以發現物件的顯示順序已經依 key 值的字母做排序了 這時候加入 compareFn 看看，可以取到哪些資訊 1234 compareFn(a, b) &#123; console.log(a, b); return 0;&#125; template 的地方也將 compareFn 加上 12345&lt;ul&gt; &lt;li *ngFor="let item of (data | keyvalue: compareFn)"&gt; &#123;&#123; item.key &#125;&#125; &lt;/li&gt;&lt;/ul&gt; console.log 出來的結果是 從這裡可以得知 a 為新值，而 b 為舊值，這裡就可以使用我們寫陣列排需規則的方式來寫，稍微複習陣列排序的寫法規則 當 compareFunction 回傳的值小於 0 ，則 a 會排在 b 之前 當 compareFunction 回傳的值大於 0 ，則 a 會排在 b 之後 當 compareFunction 回傳的值等於 0 ，則 a 與 b 的順序不會改變 小結 使用之前詳讀使用說明書 參考資料 Arrary.prototype.sort KeyValue KeyValuePipe 範例程式碼]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Scully: Angular + JAMStack]]></title>
    <url>%2F2020%2F01%2F18%2Fangular-scully-jam%2F</url>
    <content type="text"><![CDATA[JAMStack 這名詞出來有一段時間了，JavaScript+API+Markdown = Static Site Generator，從早期的 Hexo ，到後起新秀 Gatsby、Gridsome 等，但 Angular 卻一直都沒有對應的框架，直到去年年底(2019/12)，由 Aaron Frost、Sander Elias、Jorge Cano、Anderes Villanueva 等人開發出 Scully 後，Angular 正式有了第一套靜態網站產生器了 需求 必須是 Angular 9 的專案 起手式 新的 Angular 專案 加入 scullyio，ng add @scullyio/init package.json 新增兩行 scripts 用來執行 scully 指令 app.component.ts 注入 IdleMonitorService 新增 scully.config.js 檔案 polyfills.ts，加入所需的 polyfill 第一次啟動 注意事項: Angular 專案內至少要有一個路由設定，不然目前版本的 scully 會壞掉 ng build npm run scully 使用範例 1 網址有 about user/ user/:id 當建立完上列的 component 重新執行 build 和 scully 後，在 dist/static 的資料夾下應可看到這些內容 但當執行到 user/1 時，會發現該頁面不存在，這是因為我們還沒有告訴 scully 有哪些對應的資料需要被產生，這裡需要多做一個設定，還記得一開始安裝 scully 時，會多產生一個 scully.config.js 檔案，我們可以從這邊設定相關的資訊 123456exports.config = &#123; projectRoot: "./src/app", outFolder: './dist/static', routes: &#123; &#125;&#125;; 在 routes 的地方告訴 scully 路由規則及處理方式 例如 123456789routes: &#123; '/user/:id': &#123; type: 'json', id: &#123; url: 'https://jsonplaceholder.typicode.com/users', property: 'id' &#125; &#125; &#125; /user/:id 需要處理的路由 type: 'json' 回傳的資料格式 id:{..} 需要處理的變數名稱 url: 從哪一個 API 取值 property 取值回來所對應的欄位名稱 當設定完成後，重新在執行一次 npm run scully，就會看到 scully 會根據我們所設定的規則去撈 API 的資料回來產生對應的靜態檔案 使用範例 2 要使用 Scully 所提供的 Blog 範本，可透過 ng g @scullyio/init:blog 來產生相關的檔案 如果要產生一個新的 Post，可以執行 ng g @scullyio/init:post --name=&quot;some title here&quot;，就會幫你在 blog 資料夾下產生一個 Markdown 檔案 細節的部份可以自己動手做看看 參 考資料 GitHub - Scrullyio YouTube - Introducing Scully: Angular + JAMStack JAMStack]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#] 8.0 新功能 - 索引與範圍]]></title>
    <url>%2F2020%2F01%2F16%2Fcsharp-8-index-range%2F</url>
    <content type="text"><![CDATA[C# 8 提供了許多新語法，很多新語法可以讓我們的程式碼閱讀性提高，但前提是我們要先了解有那些新功能 這裡我先挑出一個我最近才用到的好用功能，陣列索引 索引 早期在操作陣列取值時，使用 Linq 應該算是標準解，但假設只是要取陣列最後的幾個項目，使用 Linq 似乎又太囉嗦 123456789101112131415161718using System;using System.Linq;namespace csharp&#123; class Program &#123; static void Main(string[] args) &#123; var urls = "https://blog.kevinyang.net/images/4550568.jpg".Split('/'); var imagesFile = urls.Last(); var folderName = urls.SkipLast(1).LastOrDefault(); Console.WriteLine("Image FileName: &#123;0&#125;", imagesFile); Console.WriteLine("Folder Name: &#123;0&#125;", folderName); &#125; &#125;&#125; 執行結果 如果是使用 C# 8.0 的新語法，就可以這樣子寫 1234567891011121314151617using System;namespace csharp&#123; class Program &#123; static void Main(string[] args) &#123; var urls = "https://blog.kevinyang.net/images/4550568.jpg".Split('/'); var imagesFile = urls[^1]; var folderName = urls[^2]; Console.WriteLine("Image FileName: &#123;0&#125;", imagesFile); Console.WriteLine("Folder Name: &#123;0&#125;", folderName); &#125; &#125;&#125; 說明 新語法，當使用 ^ ，索引計算起點就會從最後面開始起算，圖解如下 12345678910111213var words = new string[]&#123; // index from start index from end "The", // 0 ^9 "quick", // 1 ^8 "brown", // 2 ^7 "fox", // 3 ^6 "jumped", // 4 ^5 "over", // 5 ^4 "the", // 6 ^3 "lazy", // 7 ^2 "dog" // 8 ^1&#125;; // 9 (or words.Length) ^0 範圍 既然知道如何使用索引表示，接下來是另外一個新功能，範圍 。這一個功能在某些語言已經存在一段時間了 語法表示 Array[StartIndex … EndIndex(不包含 End Index 的值)] 範例 (延續上面的 words 陣列) 12var lazyDogs = words[^2..^0]; // ["lazy", "dog"]var firstThreeWords = words[0..3] // ["The", "quick", "brown"] 當不指定開始或結束索引時，就會是為最頭至最尾 123var allwords = words[..]; // ["The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]var firstThreeWords = words[..3]; // ["The", "quick", "brown"]var skipFirstThree = words[3..]; // ["fox", "jumped", "over", "the", "lazy", "dog"] 當然也可以先決定 Range 型別後，在放到陣列中 12345678var range0 = 1..2;var range1 = new Range(1, 2); // 1..2var range2 = Range.StartAt(3); // 3..var range3 = Range.EndAt(3); // ..3Console.WriteLine(String.Join(',', words[range0])); // ["quick"]Console.WriteLine(String.Join(',', words[range1])); // ["quick"]Console.WriteLine(String.Join(',', words[range2])); // ["fox", "jumped", "over", "the", "lazy", "dog"]Console.WriteLine(String.Join(',', words[range3])); // ["The", "quick", "brown"] 以下型別都有支援索引和範圍的新功能 陣列 字串 Span ReadOnlySpan 參考資料 C# 8.0 索引和範圍 索引和範圍的類型支援]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Angular in Clean Architecture - 學習筆記]]></title>
    <url>%2F2019%2F12%2F30%2Fangular-in-cleanArchitecture%2F</url>
    <content type="text"><![CDATA[繼上一篇 學習使用 CleanArchitecture 開發 - 筆記 1，依習慣先從畫面往底層看回去，而這專案範本使用 Angular 作為前端開發框架，那就來看看裡面有哪些東西或是技巧是可以偷學的 學習筆記 ##authorize service 這一專案的 authorize service 使用 oidc-client 來和後端 .NET Core 的 IdentityServer 做溝通。這一個 Libraryoidc-client 支援 OpenID Connect (OIDC) 和 OAuth2 協定的 JS library，程式碼的位置 src/api-authoriztion/authorize.service.ts 要建立一個 UserManager ，需要一個 Configuration 12345678const response = await fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);if (!response.ok) &#123; throw new Error(`Could not load settings for '$&#123;ApplicationName&#125;'`);&#125;const settings: any = await response.json();settings.automaticSilentRenew = true;settings.includeIdTokenInSilentRenew = true;this.userManager = new UserManager(settings); line 1: 跟後端要 Configuration 設定檔，回傳結果如下 12345678&#123;authority: "https://localhost:44312",client_id: "newMember.WebUI",redirect_uri: "https://localhost:44312/authentication/login-callback",post_logout_redirect_uri: "https://localhost:44312/authentication/logout-callback",response_type: "code",scope: "newMember.WebUIAPI openid profile"&#125; line 8: 初始化 UserManager UserManager 有許多 events 可以掛 callback (API)，而這邊是針對 userSignedOut 的部分做了一些處理 1234this.userManager.events.addUserSignedOut(async () =&gt; &#123; await this.userManager.removeUser(); this.userSubject.next(null);&#125;); 關於使用者的登入及註冊都交給後端的 ASP.NET Core Idenetity 去處理了 (這是另外一個大坑要填) LoginComponent LoginComponent 的目的並不是用來顯示而是負責處理相對應的行為，例如登入應該要顯示後端的登入畫面等，而因為網址會有分前端管理的跟後端管理的區別，而 Angular 內建的 Router 並沒有辦法直接導覽到非 Angular 網址的地方，所以這裡的處理方式為 1234private redirectToApiAuthorizationPath(apiAuthorizationPath: string) &#123; const redirectUrl = `$&#123;window.location.origin&#125;$&#123;apiAuthorizationPath&#125;`; window.location.replace(redirectUrl);&#125; 這裡使用 window.location.replace 的目的是為了確保使用者按下返回鍵是回到正確的位置而不是 loginComponent 的對應網址 LogoutComponent 透過 [state]='{ local: true }'來傳遞額外的狀態，而在程式碼內則需要從 window.history.state 中取得 123if (!!window.history.state.local) &#123; ...&#125; 如果想要學習如何在後端網頁跟 Angular 間做網頁切換的， 是可以從 LoginComponent 和 LogoutComponent 學習，因為這兩個 Component 本身不做任何顯示，所有的動作在 ngOnInit 就被執行了 API Service 這專案範本的 API Service 是由 NSwag toolchain 根據 Swagger 的 API JSON 自動產生的，這部分就看個人喜好了，但我個人的偏好是喜歡自己寫，至少程式碼看起來會乾淨很多 關於 NSwag 的資訊，可以 參考此網站 參考資料 oidc-client]]></content>
      <categories>
        <category>.NET core</category>
      </categories>
      <tags>
        <tag>.NET core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] 學習使用 CleanArchitecture 開發 - 筆記 1]]></title>
    <url>%2F2019%2F12%2F27%2Fasp-net-CleanArchitecture-note1%2F</url>
    <content type="text"><![CDATA[最近 CleanArchitecture 這名詞終於出現在我的雷達裡了，我知道這東西已經存在很久了，所以現在趕快將這一塊的基礎能力補上。好加在地是已經有好心人整理出一個 CleanArchitecture 的專案樣板，只要從中學習使用，應可學習到一些基本知識(應該) 工具 作者 Jason Taylor 建立一個 dotnet 用的專案範本，能讓我們快速的產生 CleanArchitecture ，Template 的 GitHub 網址在最後的參考資料有提供，但首先我們需要先將這一個範本工具安裝起來 1dotnet new --install Clean.Architecture.Solution.Template 安裝完工具後，就可以來使用了 建立一個專案用的資料夾，並進入該資料夾後，執行下列指令 1dotnet new ca-sln 執行完這個指令後，就會產生以下的資料夾架構 專案架構分析 Domain 跟 Domain 相關的東西都會放在這邊，包含 entities、enums、exceptions、interfaces、types，這部分需要將自己的 DDD 的知識補起來。 Common AuditableEntity 內包含建立與更新的時間及異動人員資訊，Entities 資料夾內的 Entity 都有繼承這一個類別 ValueObject: 這一個是 DDD 內的一個概念，更多的資訊可以在此找到，紀錄一下幾個特性 無法被識別 (No identity) Immutable Exceptions 自訂 Exceptions 類別，這方法在後續 logging 會有很幫助，也可以在處理 Exception 時減少重複程式碼的撰寫 Application 這一個資料夾內會撰寫整個應用程式的商業邏輯，只會相依在 domain layer 之上。在這一個階段也會定義一些需要在外部實做的服務介面，這表示 service interface 會在 Application 資料夾內定義，服務程式碼實做會在 Infrasturacuture 完成 而這一個專案架構，使用 Mediator (MediatR library) + CQRS 的模式，所以可以看到 Commands/Queries 的資料夾分類，而在 Coammnds 的內配合 MediatR 訊息傳遞的模式，會有 request 和 handler 的角色 123456789101112131415161718192021222324252627public partial class CreateTodoListCommand : IRequest&lt;int&gt; &#123; public string Title &#123; get; set; &#125; public class CreateTodoListCommandHandler : IRequestHandler&lt;CreateTodoListCommand, int&gt; &#123; private readonly IApplicationDbContext _context; public CreateTodoListCommandHandler(IApplicationDbContext context) &#123; _context = context; &#125; public async Task&lt;int&gt; Handle(CreateTodoListCommand request, CancellationToken cancellationToken) &#123; var entity = new TodoList(); entity.Title = request.Title; _context.TodoLists.Add(entity); await _context.SaveChangesAsync(cancellationToken); return entity.Id; &#125; &#125; &#125; 更多關於 MediatR 和 CQRS 的架構資訊可以在參考資料處找到 Infrasturcture 這一層是存取外部資源的部分，包含資料庫、檔案系統、其他的 API 服務等. 當然這些服務的介面都會在 Application 層定義 WebUI 對外的顯示介面，相依 Applicatin 及 Infrasturcture。由於整個專案架構是使用 Mediator 模式，所以在 API Controller 的地方，程式碼就會變得很單純，只要決定執行哪一個 command 即可 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TodoListsController : ApiController &#123; [HttpGet] public async Task&lt;ActionResult&lt;TodosVm&gt;&gt; Get() &#123; return await Mediator.Send(new GetTodosQuery()); &#125; [HttpGet("&#123;id&#125;")] public async Task&lt;FileResult&gt; Get(int id) &#123; var vm = await Mediator.Send(new ExportTodosQuery &#123; ListId = id &#125;); return File(vm.Content, vm.ContentType, vm.FileName); &#125; [HttpPost] public async Task&lt;ActionResult&lt;long&gt;&gt; Create(CreateTodoListCommand command) &#123; return await Mediator.Send(command); &#125; [HttpPut("&#123;id&#125;")] public async Task&lt;ActionResult&gt; Update(long id, UpdateTodoListCommand command) &#123; if (id != command.Id) &#123; return BadRequest(); &#125; await Mediator.Send(command); return NoContent(); &#125; [HttpDelete("&#123;id&#125;")] public async Task&lt;ActionResult&gt; Delete(int id) &#123; await Mediator.Send(new DeleteTodoListCommand &#123; Id = id &#125;); return NoContent(); &#125; &#125; 測試 除了 src 資料夾下的基本架構外，在 tests 裡也有相對應各專案的測試專案 小結 專案架構看似簡單，但藏在背後的原理卻很深奧的，有很多理論是需要深入學習的。希望能透過實做的方式，讓自己能理解相關的理論原理 參考資料 Clean Architecture with ASP.NET Core Clean Architecture Solution Template Repo Mediator Pattern CQRS The Clean Architecture]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Go] Go 語言學習筆記 Part 5 - interface]]></title>
    <url>%2F2019%2F12%2F09%2Fgo-note-5-interface%2F</url>
    <content type="text"><![CDATA[繼續上次的 Method, Go 內的 interface 也是很重要的一個環節, 尤其跟 method 間的關係更是緊密 基本宣告 Interce 是用來定義 method signatures, 換句話說, 如果是這個型別(interface) 的值, 就會有所規範的 method 可以使用 123type Abser interface &#123; Abs() float64&#125; 這樣的描述跟原本常見的 interface 會有些差異, 主要原因還是因為 Go 沒有 class 造成的 1234567891011121314151617181920212223242526272829303132func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat implements Abser, see line 17~24 a = &amp;v // a *Vertex implements Abser, See line 26~32 // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v // 這行會壞掉 fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 在上述程式碼提到 line 11 行會壞掉, 主要原因是 Abs() 方法只有在 struct Vertex 上面實做 (Pointer type), 而沒有再 value type 上面實做。這也是為什麼會發生錯誤的原因 nil interface 當被指定時, 預設值是 nil , 而所宣告的 method 還是可以被呼叫, 只是是透過 nil receiver 罷了 12345678910111213141516171819202122232425type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; if t == nil &#123; fmt.Println("&lt;nil&gt;") return &#125; fmt.Println(t.S)&#125;func main() &#123; var i I var t *T i = t // t 此時為 nil describe(i) // output (&lt;nil&gt;, *main.T) i.M() // &lt;nil&gt;&#125; 但如果只有單純的宣告卻沒有指定值時 (如 line 22), 就會出現以下的錯誤訊息 123456789type I interface &#123; M()&#125;func main() &#123; var i I describe(i) // output: (&lt;nil&gt;, &lt;nil&gt;) i.M() // error: panic: runtime error: invalid memory address or nil pointer dereference&#125; Type switches 在介紹 Type switches 之前, 要先了解兩個東西, 1. empty interface, 2. type assertions Empty interface empty interface 就字面上意思, 是沒有宣告任何 method 的 interface, 在 go 裡面會這樣子表示 12345678910111213141516// interface&#123;&#125;func main() &#123; var i interface&#123;&#125; describe(i) // output: &lt;nil&gt;, &lt;nil&gt; i = 42 describe(i) // output: 42, int i = "hello" describe(i) // output: hello,string&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf("(%v, %T)\n", i, i)&#125; 透過上面的範例, 得知我們可以透過 empty interface 來取得變數的值及型別兩種資訊 Type assertions 既然知道型別, 那是否可以直接做條件判斷了, 在 go 裡面是可以做到的 12345678910111213var i interface&#123;&#125; = "hello"s := i.(string)fmt.Println(s)s, ok := i.(string) fmt.Println(s, ok) // "hello", truef, ok := i.(float64) // f: 0, ok:falsefmt.Println(f, ok)f = i.(float64) // 噴錯fmt.Println(f) 如果 i 的值是 string 型別的話, s 就會等於 i 的值 但如果不是, 就會噴錯。但這樣子就太蠢了, 所以 go 提供了第二個值可以接, 當這一個有接起來, 效果就等於 try catch. 執行時就不會噴錯了 switches 透過前面兩地的特性, 再搭配 switch 就可以做到型別的判斷了 123456789101112131415161718192021222324type Vertex struct &#123; name string&#125;func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf("Twice %v is %v\n", v, v*2) case string: fmt.Printf("%q is %v bytes long\n", v, len(v)) case Vertex: fmt.Printf("Vertex %v", v) default: fmt.Printf("I don't know about type %T!\n", v) &#125;&#125;func main() &#123; do(21) do("hello") do(true) do(Vertex&#123;"Go"&#125;)&#125; i.(type) 只能搭配 switch 使用 參考資料 interface 文件]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Go] Go 語言學習筆記 Part 4- Methods]]></title>
    <url>%2F2019%2F12%2F02%2Fgo-note-4-method%2F</url>
    <content type="text"><![CDATA[Go 的 Methods 功能很強， 但也很多要注意的地方，就仔細地跟著官網的文件學習了。 基本 Go 本身沒有並沒有 Class 語法, 但我們卻可以針對型別去擴充功能。Method 也是一種 function 但有特定寫法 123456789101112func (v T) &lt;func name&gt; &lt;return type&gt; &#123; ....&#125;// 範例type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 與一般 function 差異在於 function name 的前面指定作用的型別 (v Type), 這樣子定義完成後, 我們就可以直接使用 1234func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) // 使用 Methods&#125; 一開始就有提到 Method 也是 function, 那為什麼要刻意在區分出來呢, 這個在後面會提到, 到就這裡先用標準 function 寫出同樣功能吧 12345678func Abs(v Vertax) float64&#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125; 既然 Method 是可以在型別上做擴充功能, 原生型別是否可行呢? 答案是不行的 Method 只能宣告在 local type 上, 所以當要在處理類似的動作, 就必須做 type 宣告 12345678910111213type MyFloat float64 // 給予 alias typefunc (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; Pointer 12345678910111213141516171819202122232425package mainimport ( "fmt" "math")type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v.Abs())&#125; 16 行的 method 使用 * 來描述 Scale 是定義在 *T 上, 表示這個 method 的操作會直接反應回操作實體上 當第 23 執行時, v 裡面的 x 會這樣子變動 1234567v := Vertex&#123;3, 4&#125;v.Scale(10) // &#123;30 40&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f // v.X = 3 * 10 v.Y = v.Y * f // v.Y = 4 * 10&#125; 接下來的第 24 行的執行結果就是 $$\sqrt{30 \times 30 + 40 \times 40} = 50$$ 回到上一段提到的 Methods 也是 functions, 但這兩者對於 Pointers 的處理方式是一樣的嗎? 先用 function 的方式寫出一樣的功能 1234567891011...func Scale(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; Scale(&amp;v, 10) fmt.Println(v.Abs())&#125; 到這邊的寫法是一樣的, 但當將 function 裡的 * 給移除後, 就會發生錯誤訊息 但 methods 是否會有同樣的問題呢? 123456789101112131415func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v) fmt.Println(v.Abs()) // 5&#125; 雖然將第 5 行的 * 給移除掉是不會壞掉, 但是第 13 行的執行結果就完全不一樣了 來看一下執行的順序 line 12 的 Scale 的是取得 Value Receiver 的副本, 所以任何改變都不會影響本體 line 13 印出來的結果還是 {3 4} 當然 line 14 的結果是 5 如果要將該 method 改成與原本的結果一樣, 就必須將 v 回傳 所以加上加 Pointer (*) 雖然 method 都不會壞掉, 但意義上是全然不同的 換另外一個方向來看, 當使用的 Value 本體是否為 Pointer 呢? function 一定會壞掉, function 本身就是那麼嚴謹 123456func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) p := &amp;v fmt.Println(p.Abs()) // 等同 (p*).Abs()&#125; 選擇 value or pointer Receiver 簡單說, 選擇 pointer receiver 的理由就是為了快, 因為不會多產生一個副本, 針對越大的 struct 效果越明顯, 另外一個決定點, 是否要共用資料 (side effect or not) 如果不想要, 就使用 value receiver, 反之, 使用 pointer receiver 一般來說為了維護一致性, 並不會混和 value 和 pointer 一起使用]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Go] Go 語言學習筆記 - 語言 part 3]]></title>
    <url>%2F2019%2F11%2F29%2Fgolang-note-3%2F</url>
    <content type="text"><![CDATA[繼續研究 Go，這次會涵蓋 Map 和 Functions Map Map 是一個 Key Value 形式的格式，當沒有給予初始值時，預設值為 nil，一樣可以使用 make 建立 123456789101112func main() &#123; var m map[string]int if m == nil &#123; fmt.Println("is nil") // output: is nil &#125; m = make(map[string]int) fmt.Println(m) // output: map[] m["first"] = 1 fmt.Println(m) // output: map[first:1] fmt.Println(m["first"]) // output: 1&#125; 給予初始值的方式與 struct 雷同，但須要多給 key 值 1234567891011121314151617type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; "Bell Labs": Vertex&#123; 40.68433, -74.39967, &#125;, "Google": Vertex&#123; 37.42202, -122.08408, &#125;,&#125;// 也可以這樣var m = map[string]Vertex&#123; "Bell Labs": &#123;40.68433, -74.39967&#125;, "Google": &#123;37.42202, -122.08408&#125;,&#125; 修改 Map 資料的方式也很直覺，直接根據 Key 值修改資料即可 123456789101112131415func main() &#123; m := make(map[string]int) m["Answer"] = 42 fmt.Println("The value:", m["Answer"]) m["Answer"] = 48 fmt.Println("The value:", m["Answer"]) delete(m, "Answer") fmt.Println("The value:", m["Answer"]) v, ok := m["Answer"] // 第二個回傳值: 判斷 key 值是否存在 fmt.Println("The value:", v, "Present?", ok) // output: 0 Present?: false&#125; Functions Go 裡面的 Function 也是一種型別，表示我們可以將 Function 傳入一個 Function 或是回傳一個 Function。 12345678910111213func compute(fn func(float64, float64) float64) float64 &#123; return fn(3, 4)&#125;func main() &#123; hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))&#125; Function Closures 好像也是基本了 12345678910111213141516func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos := adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), // output: 1 3 6 10 ... ) &#125;&#125; 小結 到這篇筆記為止，應該都算是 Go 的基礎篇，接下來的筆記都算是比較進階的內容。期待進入 Go 的進階世界]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Element as SharePoint WebPart - Connect Data]]></title>
    <url>%2F2019%2F11%2F28%2Fangular-element-with-sharepoint-part2%2F</url>
    <content type="text"><![CDATA[上一篇 介紹了如何使用 Angular Element 建立 SharePoint 的 WebPart，但如果不串接資料，這功能就太弱了，所以這篇就來記錄一下，如何使用內建的方法來取得 SharePoint 或是 MS Graph 的資料 但由於使用 Graph API 需要在環境設定權限等，這篇就不做這部分的範例 (也找不到相關的資料.QQ) 找到方法，補充在後面 要連接 SharePoint 的資料，我們可以透過 @pnp 的套件來完成，官方說明文件 安裝 可以使用的套件有這些，可以選擇安裝自己需要的部分即可 1npm install @pnp/logging @pnp/common @pnp/odata @pnp/sp @pnp/graph --save 初始啟動 文件上有提供三種啟動方式，這裡我就舉其中一種方法，在 WebPart 的程式裡，加入這些程式碼 12345678public onInit(): Promise&lt;void&gt; &#123; return super.onInit().then(_ =&gt; &#123; // other init code may be present sp.setup(&#123; spfxContext: this.context &#125;); &#125;);&#125; 取 SharePoint 資料 在 Angular Element Component 單純使用 @pnp/sp 包裝好的 api，就可以很輕鬆地取得相關的資訊 12345import &#123; sp &#125; from '@pnp/sp';...ngOnInit() &#123; this.webLists = sp.web.lists.get();&#125; 12345&lt;ul&gt; &lt;li *ngFor="let item of webLists | async"&gt; &#123;&#123; item.Title &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 更多 @pnp/sp Library API 可以閱讀此文件 測試 由於 @pnp/sp 內有包 context 這物件，而這物件只有在真正的 SharePoint 環境才會存在，那我們也不可能每次都要打包上傳到正式環境，基於這裡由。其實在當執行 gulp serve 時，除了本機會啟動一個測試用的環境外，也會試著遠端連線到 SharePoint Server (不確定這邊的原理是什麼)，但可以透過開啟 https://{sharepoint-site-name}.sharepoint.com/_layouts/15/workbench.aspx 來進行遠端測試 可以看到正式環境擁有的 App，當然也可以找到我們正在寫的 WebPart，找到後加入到頁面上，就可以看到撈出來的資料有正常的顯示到畫面上了 使用 Graph API 程式碼 呼叫 graph 的程式碼不困難，但一樣相依 context 這一個物件，所以如果 Angular Element component 要使用，就要被傳進 component 123456789101112131415export class HelloWorldWebPartComponent implements OnInit, AfterViewInit &#123; @Input() context: WebPartContext; ... ngOnInit()&#123; if (this.context) &#123; this.context.msGraphClientFactory.getClient().then((client): void =&gt; &#123; client.api('/me').get((error, user, rawResponse?: any) =&gt; &#123; this.user = user; &#125;); &#125;); &#125; &#125;&#125; 而 WebPart的部分就要將 context 傳進去 1234567891011121314public render(): void &#123; let ngElement = this.domElement.getElementsByTagName( "app-hello-world-web-part" )[0]; if (ngElement) &#123; this.domElement.removeChild(ngElement); &#125; const baseEl = customElements.get("app-hello-world-web-part"); const element = new baseEl(); element.description = this.properties.description; element.context = this.context; // 將 content 傳給 Angular Element this.domElement.appendChild(element); &#125; 權限設定 當要使用 graphAPI 時，需要在 SPFx 專案下的 config/package-solution.json 內的 solution 區塊新增 webApiPermissionRequests 的權限請求 123456"webApiPermissionRequests": [ &#123; "resource": "Microsoft Graph", "scope": "User.ReadBasic.All" &#125; ] 為了要將權限請求限制在此 WebPart，需要多開啟一個設定 1"isDomainIsolated": true, 當這些都設定完成後，就需要上傳到 SharePoint 做 API 權限請求核准的動作，先來打包一下，依序執行動作 編譯打包 Angular Element，在 Angular 專案內執行 npm run bundle 在 SPFx 專案下，執行以下指令 gulp bundle --ship gulp package-solution --ship : 會產生一個 .sppkg 檔案在 sharepoint/solution 的資料夾下 打開 SharePoint 網站，進入 應用程式目錄網站 的網站內進行 App 上船動作，如果沒有 應用程式目錄網站的，則須要先建立。建立方法如下 進入 SharePoint 系統管理中心，網址: https://&lt;org&gt;-admin.sharepoint.com 點選 更多功能，並開啟 App 進入 應用程式目錄，依上面文字建立一個應用程式目錄 建立完成後，稍後一下，應可以在【網站】-&gt; 【使用中網站】的清單中看到剛剛建立的應用程式目錄網站 進入【應用程式目錄網站】 點選【SharePoint 適用的分散式應用程式】 點選【新增】或【上傳】，將剛剛的 ssppkg 檔案上傳 上傳成功應可以看到這個畫面，點選【部屬】 由於我們有請求授權，所以需要在到 SharePoint 系統管理中心 的 【API 管理】頁面去授權，這個選項如果一開始沒有任何的請求時是不會出現的，一旦有第一次請求時就會自己跑出來了 點選等待核准的項目，進行核准 一旦核准成功後，我們就可以透過前面介紹的 gulp server --nobrowser 的方式到線上測試 webpart 的功能是否正常了 小 結 這段我其實卡很久，都卡在 context 為什麼都取不到，結果後來發現要使用遠端的測試環境，就可以正常地做到測試了。 另外還是想要解決的是使用 Graph API 這段，因為我們可以透過 MS Graph API 取到更多 O365 上有的資訊 參考資料 Connect your client-side web part to SharePoint (Hello World part 2)]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Element as SharePoint WebPart]]></title>
    <url>%2F2019%2F11%2F27%2Fangular-element-with-sharepoint%2F</url>
    <content type="text"><![CDATA[Angular Element 的使用情境是什麼? 關於這個問題的答案有很多，在去年年初(2018/2) Angular 團隊的 Rob 在 歐洲一場 SharePoint 的活動內介紹了這一段， 影片，SharePoint 這產品在台灣除了一些大公司或是老公司中還可以看到外，基本上很難在聽到他的名字，可是在國外，SharePoint 還是有很多使用者的。而 WebPart 允許我們使用不同的技術 + sharepoint 提供的 sdk 來做畫面顯示及資料串接。 當然我們也可以使用 HTML + CSS + JavaScript 才做到這件事情，而有一群使用 SharePoint 的社群推出一套基於 @microsoft/generator-sharepoint 的 yeoman ，擴充出來的另外一個 SharePoint 套件，@pnp/generator-spfx，這一個產生器內支援了 Angular / Vue / React 等前端框架，裡用這些框架來開發 SharePoint 的 WebPart / extendsion / library 等，這一篇筆記就是來記錄如何使用 @pnp/generator-spfx 來建立第一個 Angular Element as WebPart in SharePoint 環境要求 node 版本: 10.x 版 。很重要， 目前 @microsoft/generator-sharepoint 還不支援 Node 12.x 版，會在 node-sass 的地方壞掉 yeoman 套件 gulp 工具 Angular CLI 版本: 6、7、8，但這邊我們可以手動修改讓他支援 9 版 工具安裝 1npm i -g yo gulp @pnp/generator-spfx 這邊假設以經安裝過 @angular/cli 了 建立專案 建立一個空的資料夾並進入到該資料夾 執行 yo 指令 選擇 @pnp/spfx 產生器 選擇要建立的範本，這邊先選取 SharePoint Online only 選擇要使用的前端框架 假設看到 Angular Elements 是 Disabled 狀態時，這是因為安裝的 @angular/cli 版本沒有落在 @pnp/generator-spfx 內所設定的 @angular/cli 版本，這裡需要手動去改一下程式，修改步驟如下 windows 版可以到 %UserProfile%\AppData\Roaming\npm\node_modules\@pnp\generator-spfx 資料夾下，修改以下檔案 app/promptConfig.js ，約 第19 行的地方，新增 || ngVersion.version.startsWith('9') 12345678910// support for Angular 6/7/8 if (ngVersion.version.startsWith('6') || ngVersion.version.startsWith('7') || ngVersion.version.startsWith('8') || ngVersion.version.startsWith('9')) &#123; angularVersion = ` (uses @angular/cli $&#123; ngVersion.version&#125;)`; return false; &#125;; generators/angularelements/index.js 約第 83 行的地方，新增 || ngVersion.version.startsWith('9')，記得要將第二段的條件用小括弧包起來 12345if (ngVersion.version !== undefined &amp;&amp; (ngVersion.version.startsWith("8")|| ngVersion.version.startsWith('9'))) &#123; ...&#125; 完成後，重新執行步驟二，執行 yo，就可以看到 Angular Elements 被開啟了 選擇是否安裝其他 Library，預設 Enter 下一步 選擇 TypeScript 版本，我本身是喜歡越新版的 TypeScirpt 越好 其他檢查套件安裝，直接 Enter 下一步 是否安裝 pipeline 設定，Enter 下一步 開始設定專案相關資訊，就依畫面上提示的輸入即可 進入 SharePoint 專案的設定階段，基本上都是依文字說明選擇自己要的設定，但當第二個問題 Enter 下一步後，會停住 這邊理論上會問專案要建立在目前的資料夾呢，還是建立新的資料夾，不確定為什麼會空白，在多按一次 Enter 就會繼續往下走，而專案會建立在目前所在的資料夾內 選擇要建立的 component 類型，選擇 WebPart 後 Enter 下一步 輸入 WebPart 的名稱等相關資訊 接下來就是漫長的安裝過程 完成後，可以檢視目前的資料夾，會有兩個資料夾，一個是 Angular 專案，一個是 SPFx 專案。 最後，如果從沒有安裝過開發憑證，可先進入 SPFx 專案資料夾內，執行 gulp trust-dev-cert 測試是否有安裝成功，需要執行以下兩個步驟 進入 Angular 專案資料夾，執行 npm run bundle 指令 進入 SPFx 專案資料夾，執行 gulp serve ，看看是否能正常地啟動起測試用的網頁 能看到這些畫面，就代表環境及專案都建立成功了，就可以往下一階段進行了 程式碼架構 Angular 專案 採用 Angular Element 的方式來完成，所以在 app.module.ts 的地方可以看到註冊 custom Element 的程式碼 123456789101112131415161718192021222324import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule, Injector &#125; from '@angular/core';import &#123; createCustomElement &#125; from '@angular/elements';import &#123; HelloWorldWebPartComponent &#125; from './hello-world-web-part/hello-world-web-part.component';@NgModule(&#123; declarations: [ HelloWorldWebPartComponent ], imports: [ BrowserModule ], providers: [], entryComponents: [HelloWorldWebPartComponent]&#125;)export class AppModule &#123; constructor(private injector: Injector) &#123;&#125; ngDoBootstrap() &#123; const el = createCustomElement(HelloWorldWebPartComponent, &#123; injector: this.injector &#125;); customElements.define('app-hello-world-web-part', el); &#125;&#125; Component 本身的 Selector 只會在 Angular 內部環境生效，對外是吃 customElements 這邊定義的名稱 如果是 Angular CLI 的版本，第 15 行的 entryComponents 可以不用在寫了 (可移除) SPFx 專案 src/webparts/helloWorld 資料夾內是我們要看的部分 webpart HelloWorldWebPart.ts 12345678910import "ng-element-webpart/dist/ngElementWebpart/bundle"; // 引用 Angular 建置 bundle 出來的檔案export default class HelloWorldWebPart extends BaseClientSideWebPart&lt; IHelloWorldWebPartProps&gt; &#123; public render(): void &#123; this.domElement.innerHTML = `&lt;app-hello-world-web-part description="$&#123;this.properties.description&#125;"&gt;&lt;/app-hello-world-web-part&gt;`; &#125; ...&#125; render 是用來顯示 WebParts 畫面的方法 另外一種寫法 123456789101112131415161718export default class HelloWorldWebPart extends BaseClientSideWebPart&lt; IHelloWorldWebPartProps&gt; &#123; public render(): void &#123; let ngElement = this.domElement.getElementsByTagName( 'app-hello-world-web-part' )[0]; if (ngElement) &#123; this.domElement.removeChild(ngElement); &#125; const baseEl = customElements.get("app-hello-world-web-part"); const element = new baseEl(); element.description = this.properties.description; this.domElement.appendChild(element); &#125; ...&#125; WebParts 屬性的設定 12345678910111213141516171819202122232425262728export default class HelloWorldWebPart extends BaseClientSideWebPart&lt; IHelloWorldWebPartProps&gt; &#123;... protected getPropertyPaneConfiguration(): IPropertyPaneConfiguration &#123; return &#123; pages: [ &#123; header: &#123; description: strings.PropertyPaneDescription &#125;, groups: [ &#123; groupName: strings.BasicGroupName, groupFields: [ PropertyPaneTextField("description", &#123; label: strings.DescriptionFieldLabel &#125;) ] &#125; ] &#125; ] &#125;; &#125;....&#125; 這邊程式碼的寫法有支援 i18n 多國語系，要搭配 loc 資料夾內的檔案一起看，有興趣的可以去對應一下 manifest.json HelloWorldWebPart.manifest.json WebPart 在 SharePoint 內要顯示的資訊設定檔 1234567891011121314... "preconfiguredEntries": [ &#123; "groupId": "5c03119e-3074-46fd-976b-c60198311f70", // Other "group": &#123; "default": "Other" &#125;, "title": &#123; "default": "HelloWorld-2" &#125;, // 顯示在 WebParts 清單內的名稱 "description": &#123; "default": "HelloWorld description" &#125;, "officeFabricIconFontName": "Page", "properties": &#123; "description": "HelloWorld-2" // 屬性預設值 &#125; &#125; ] 參考資料 PnP/generator-SPFx - Angular Elements]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Go] Go 語言學習筆記 - 語言 part 2]]></title>
    <url>%2F2019%2F11%2F25%2Fgolang-note-2%2F</url>
    <content type="text"><![CDATA[上一篇簡單快速的介紹 Go 最基礎最簡單的部分，這一篇要進入比較進階一點的地方，更多跟語言有關的筆記介紹如下 Pointers Pointer 的作用是讓變數可以參考某一個變數的記憶體位置，預設值為 nil，語法是 *T 是指到 T 的位址(memory address)，&amp; 是產生 pointer 的運算式 12345678910111213...func main() &#123; i, j := 42, 2701 p := &amp;i fmt.Println(*p) // 42 *p = 21 fmt.Println(i) // 21 p = &amp;j *p = *p / 37 fmt.Println(j) // 73&#125; Structs 可以利用 struct 來當作一個資料模型 123456789...type Vertex struct &#123; X int // field Y int&#125;func main() &#123; fmt.Println(Vertex&#123;1, 2&#125;)&#125; 可以將 structs 視為一個 data object，當然就可以做到這件事情 123456789101112...// Vertex Modeltype Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; v.X = 4 fmt.Println(v) // output: &#123;4 2&#125;&#125; 當 strcut 遇上 pointer 時，由於 * 寫起來很麻煩，所以當是一個 struct point 時， * 就可以不用寫 123456789101112...type Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; p := &amp;v p.X = 5 fmt.Println(v) // output &#123;5 2&#125;&#125; 如果還是要加 * 的話，還是可以加，寫法如下 123456func main() &#123; v := Vertex&#123;1, 2&#125; p := &amp;v (*p).X = 5 // 加 * 的寫法 (*T).field ...&#125; 定義完 strcut 後，建立 struct 實體的方式除了直接一開始就先給值之外，還可以這樣子寫 12345678type Vertex struct &#123; X, Y int&#125;v1 := Vertex&#123;1, 2&#125; // has type Vertexv2 := Vertex&#123;X: 1&#125; // Y:0 is implicitv3 := Vertex&#123;&#125; // X:0 and Y:0p := &amp;Vertex&#123;1, 2&#125; // has type *Vertex Arrays 陣列的操作，在任何程式語言都應該被好好熟悉並掌握，在 Go 裡面宣告陣列的方式比較不一樣，宣告方視為 [n]T is an array of n values of type T，範例 12345678910func main()&#123; var a [2]string a[0] = "Hello" a[1] = "world" fmt.Println(a[0], a[1]) // output: Hello World fmt.Println(a) // output: [Hello World] primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; // 宣告後直接賦予值 fmt.Println(primes)&#125; Go 在開發時，會立刻針對型別做檢查 如果陣列初始值長度大於宣告的，也會出現錯誤提示 Slices 設定方法 1 Array 是一個有固定長度的陣列，而 slices 是沒有固定長度的陣列，宣告使用方式為 1234567891011121314q := []int&#123;2, 3, 5, 7, 11, 13&#125;// strcut slicess := []struct &#123; i int b bool &#125;&#123; &#123;2, true&#125;, &#123;3, false&#125;, &#123;5, true&#125;, &#123;7, true&#125;, &#123;11, false&#125;, &#123;13, true&#125;, &#125; 設定方法 2 slices 可透過這語法array[lowIndex: highIndex]，包含 lowIndex 但不包含 highIndex，從一個陣列中取出某一部分的陣列資料 12345func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; s := primes[1:3] fmt.Println(primes, s) // output: [2,3,5,7,11,13] [3,5]&#125; 注意 非常重要，slice 出來的陣列，並不是複製體，而是參考到原本的來源陣列，這表示，改動 slice 出來的陣列，是會影響到原本的資料，測試程式碼如下 123456func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; s := primes[1:3] // 由上面得知是 [3,5] s[0] = 1 // 修改後變成 [1,5] fmt.Println(primes, s) // output: [2,1,5,7.11.13] [1,5]&#125; 當沒有設 lowIndex 或 highIndex 時，Go 內的預設值會是 lowIndex : 0 highIndex: 陣列長度 123456func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; s := primes[:3] // output: [2 3 5] p := primes[4:] // output: [11 13] fmt.Println(s, p) &#125; slices 資訊 (重要觀念) 如果想要得知目前 slice 長度跟複製的陣列來源長度，可以透過 len() 和 cap() 兩個方法取得 len() : slice 出來的陣列長度 cap(): slice 來源的陣列長度 12345678910111213141516171819func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; printSlice(s) // len: 6, cap: 6, s: [2 3 5 7 11 13] // Slice the slice to give it zero length. s = s[:0] printSlice(s) // len: 0, cap: 6, s: [], cap_s: [2 3 5 7 11 13] // Extend its length. s = s[:4] printSlice(s) // len: 4, cap: 6, s: [2 3 5 7], cap_s: [2 3 5 7 11 13] // Drop its first two values. s = s[2:] printSlice(s) // len: 2 cap: 4, s: [5 7], cap_s: [5 7 11 13] s = s[:4] printSlice(s) // len: 4 cap: 4, s: [5 7 11 13], cap_s: [5 7 11 13]&#125; 預設值 而一個 slices 沒有設定初始值時，預設值就是 nil 使用 make 建立 slices make 是 go 內建的方法之一，可以透過 make 來建立一個動態長度的陣列, slices. 語法是 make( []T, len, cap) 1234func main()&#123; a := make([]int, 0, 5) fmt.Println(a, len(a), cap(a)) // output: [] 0 5&#125; 多維陣列 這應該就不用多解釋了 12345board := [][]string&#123; []string&#123;"_", "_", "_"&#125;, []string&#123;"_", "_", "_"&#125;, []string&#123;"_", "_", "_"&#125;, &#125; 擴增 透過 append( s []T, vs ...T) 的方式增加 slices 內的資料筆數，slices 會根據需要長大 12345func main() &#123; var a []int a = append(a, 0, 1, 2) fmt.Println(a, len(a), cap(a))&#125; range range 是一種 for loop slices 的用法，直接看程式碼比較快 12345func main() &#123; for i, v := range pow &#123; fmt.Println(i, v) &#125;&#125; 由圖片得知, range 會回傳目前所在的 index 和 value (複製本) 如果只想值，不想取得 index 時，第一個 index 可以用 _ 來代替 123for _, v := range pow &#123; fmt.Println(v)&#125; 如果只是想要取得 index 的話，那可直接省略 , v 的部分 123for i := range pow &#123; fmt.Println(i)&#125; 延伸閱讀 更多關於 slices 的資訊，可以閱讀這篇文章]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Go] Go 語言學習筆記 - 語法]]></title>
    <url>%2F2019%2F11%2F25%2Fgolang-note-1%2F</url>
    <content type="text"><![CDATA[Go 這語言出來也好一段時間了，由於本身後端都是用 C# 在開發，一直都沒有很大的動機學習另外一個後端語言。趁著這次 GDG 台中 12 月份的大活動，來學習一波 Go 吧 歷史 Go 是由 Google 和眾多的貢獻者一起發展的開源專案 (BSD-style 授權) 安裝 依官網的安裝文件安裝，基本上是沒有問題的。編輯器的部分可以使用 VS Code + Go 的擴充套建，或是使用JetBrains GoLand 編輯器(商用) Hello World 第一個 Go 的程式 12345678// hello-world.gopackage mainimport "fmt"func main() &#123; fmt.Println("Hello, world")&#125; 透過下指令的方式就可以執行 Go 檔案，go run hello.world.go 要將 Go 建置成可以跑執行檔，執行 go build hello.world.go 之後，就可以執行 ./hello-word 如果要將 Go 打包成全域可使用的話，可透過 go install 的語法，但要使用這個前置條件是 GOBIN 的環境變數要設定，windows 就加入一個環境參數 GOBIN 並設定一個資料夾即可 基本語法 packages go 世界裡，每一個 go 檔案都會歸屬到一個 packages 裡面，就拿上面的 hello-world 來看 12package main.... 要使用其他 package 就需要透過 import 1234import ( "fmt" "math") 當 package 被 import 時，就可以使用該 package 內第一個為大寫的 functions。換句話說，如果 functions 的名稱第一個是小寫的，就不會被 export 出去 上圖為使用小寫 functions 時會出現的錯誤訊息，當改使用大寫的 functions，則會是這個結果 functions Go 的 functions 也是要定型別的，只是定型別的順序跟常見的 C# 等語言不太一樣 123func add(x int, y int) int &#123; return x + y&#125; 型別都定義在後方，當連續的參數都是同一型別時，也可以這樣寫 123func add(x, y int) int &#123; return x + y&#125; Go 另外一個比較特別的地方就是 function 允許回傳多個值 12345678func swap(x, y string) (string, string)&#123; return x, y&#125;func main()&#123; a, b := swap("hello", "world") // a=world , b= hello&#125; 換另外一種命名方式回傳 (但不太建議這樣子使用) 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; variables 可愛的 var 又來了 123456789package mainimport "fmt"var c, python, java boolfunc main() &#123; var i int fmt.Println(i, c, python, java)&#125; 設定預設值的方式，就在後面一順序給要的預設值就可以了，Go 會依預設值自行推斷型別 1var c, python, java = true, false, "no!" 另外一種簡化的宣告方式，使用 := 1234567891011// 原本的做法func main() &#123; var result int result = add(1, 2) fmt.Println(result)&#125;// 使用 := 語法糖func main() &#123; result := add(1, 2) fmt.Println(result)&#125; basic types bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32, represents a Unicode code point float32 float64 complex64 complex128 defaultValue 各型別如果沒有給予設值的系統預設值為 string =&gt; 「」 bool =&gt; false 數字型 =&gt; 0 如果要轉型的話，可以這樣子操作 T(v) 會將 value v 轉換成 T 型別 123var i int = 42var f float64 = float64(i)var u uint = uint(f) consts 使用 const 宣告常數值，常數值不能使用 := 宣告 1const Pi = 3.14 流程控制 for for 迴圈的基本起手式，不需要小括弧，但大括弧是必要的 1234567func main() &#123; sum := 0 for i := 0; i &lt; 10; i++ &#123; sum += i &#125; fmt.Println(sum)&#125; go 版本的 while，仍是用 for 表示 12345sum := 1 for sum &lt; 1000 &#123; sum += sum &#125; fmt.Println(sum) 永不停止的寫法，還是用 for 123for &#123; ...&#125; if 條件判斷應該是最基本的，只是不需要小括弧，但大括弧是必要的 123if x &lt; 0 &#123; return sqrt(-x) + "i"&#125; 更懶惰但要習慣的寫法是，在 if 內做變數指定 123456func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; return lim&#125; switch 1234567891011today := time.Now().Weekday()switch time.Saturday &#123; case today + 0: fmt.Println("Today.") case today + 1: fmt.Println("Tomorrow.") case today + 2: fmt.Println("In two days.") default: fmt.Println("Too far away.")&#125; 基本 switch case 都會附上 break (預設隱藏)，當然要寫也是可以的，而 case 的條件也可以是 expression，這樣就不局限必須為一個數值之類的，可以是條件、function 的，以下是一些 switch case 不同的寫法 12345678910func myswitch(v int) &#123; switch &#123; case v &gt; 10: fmt.Println("value 大於 10") case v == 10: fmt.Println("value 等於 10") default: fmt.Println("value 小於 10") &#125;&#125; 12345678910func myswitch(v int) &#123; switch &#123; case v == 10: fallthrough case v &gt; 10: fmt.Println("數字大於等於 10") default: fmt.Println("其他數值") &#125;&#125; fallthrough : 執行完此 case 後，繼續往下走 switch case 判斷 12345678910func myswitch(v int) &#123; switch v &#123; case 0, 1, 2, 3, 4, 5: fmt.Println("介於 0 ~ 5 之間") case 6, 7, 8, 9, 10: fmt.Println("介於 6 ~ 10 之間") default: fmt.Println("其他數值") &#125;&#125; defer defer 會等到周圍的 function 都執行完成後，再執行 123456789package mainimport "fmt"func main() &#123; defer fmt.Println("world") fmt.Println("hello") // hello world&#125; 既然 defer 會 hold 住 function，那當好幾個 defer 時，又會怎麼執行呢 12345678910111213package mainimport "fmt"func main() &#123; fmt.Println("counting") for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println("done")&#125; 輸出結果為 所以 defer 所堆疊起來的 functions，會採後進先出的方式執行，可以讀此文章了解更多 參考資料 A Tour of Go - Packages, variables, and functions A Tour of Go - Flow control…]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何設定開發時期的 SignalR proxy 檔]]></title>
    <url>%2F2019%2F10%2F17%2Fangular-proxy-with-signalr%2F</url>
    <content type="text"><![CDATA[Angular 在開發時期有提供 proxy 的檔案供我們設定 reverse proxy ，以避免 CORS 所產生的問題，而 API 的設定上是沒有問題的，那遇到 SignalR 又該怎麼辦呢? 首先要先了解 SignalR 是跑在什麼協定上，SignalR (這裡提的 SignalR 是用最新版的 @microsoft/signalr) 預設是跑在 websocket 上，既然知道是跑在 websocket 上，proxy 設定檔就變簡單了，以下是基本範例 1234567&#123; ... "/messageHub": &#123; "target": "&lt;your url&gt;", "ws": true // 這是關鍵設定 &#125;&#125; 當加上 line:5 後，一切問題就解決了。 進階設定 當要設定的網址很多時，可以怎樣設定呢? 可以使用 context 來設定，範例如下 1234567&#123; "context": ["/messageHub", "/api"], "target": "&lt;your url&gt;", "secure": false, "changeOrigin": true, "ws": true&#125;]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 靜態檔案]]></title>
    <url>%2F2019%2F10%2F15%2Fflutter-assets%2F</url>
    <content type="text"><![CDATA[Flutter 處理靜態檔案的方法，特別針對圖檔的處理算是很完整又簡單，筆記如下 靜態檔案 Flutter 是透過設定 pubspec.yaml 的 assets 區塊來決定哪些靜態檔案或是資料夾下的靜態檔案要被包到 Flutter 專案內 12345flutter: assets: - assets/my_icon.png - assets/background.png - assets/docs/ 可以直接設定靜態檔案名稱 設定資料夾名稱 (結尾要有 /)，則會包含第一層內的所有靜態檔案 單針對影像檔的處理方式有更彈性的作法，由於手機設備的螢幕大小都不太一樣，為了讓圖片顯示得更清楚，都會針對不同的解析度而輸出相對應的圖檔，所以如果採用上述的打包規則，設定規則會超級囉嗦。 針對這一塊，Flutter 的彈性處理方式是，他會根據圖檔的檔名，往下找一樣檔名的檔案並一起打包進來，假設圖檔的存放結構如下 123.../assets/images/background.png.../assets/images/dark/background.png.../assets/images/my_icon.png 這時候我的 pubspec.yaml 是這樣子設定 123flutter: assets: - assets/images/background.png Flutter 會連同 assets/images/dark/background.png 檔案一起打包進來，同理套用在資料夾模式，真的很彈性。 透過這樣的機制，就可以很輕鬆的處理多尺寸圖片的問題了，資料夾的命名依放大比例命名 (ex: /2.0x/image.png，/3.0x/image)，沒放在資料夾內的圖檔為 base ration (1倍) 讀取靜態檔案 讀取文字 123456import 'dart:async' show Future;import 'package:flutter/services.dart' show rootBundle;Future&lt;String&gt; loadAsset() async &#123; return await rootBundle.loadString('assets/config.json');&#125; 讀取圖檔 12var imageData = await rootBundle.load('assets/images/ReceiptRaw_1.jpg'); // Future&lt;ByteData&gt;var image = Image.memory(imageData); 更簡單的方式是使用 widget 讀取，當使用會針對解析度改變會處理的 widget，會自己載入合適的圖檔 1AssetImage('graphics/background.png') 打包 package 的靜態檔案 當要使用 package 的圖檔時，則需要這樣子設定 1234flutter: assets: - backgrounds/background1.png - packages/fancy_backgrounds/backgrounds/background1.png 當使用 AssetImage 時，就可以指定要載入哪一個 package 1AssetImage('backgrounds/background1.png', package: 'fancy_backgrounds') 參考資料 Assets and images]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] Provider]]></title>
    <url>%2F2019%2F10%2F12%2Fflutter-provider%2F</url>
    <content type="text"><![CDATA[Flutter 內狀態管理的方法很多種，先從包裝好的 provider package 先研究起，pub 網址 Basic Provider 是 Dependency injection 和 state manager 的混和體，使用 provider 可以讓我們很容易的重複使用 wigdet class，並確保幾件事情 維護姓，單一方向的資料流 測試性，容易 mock service 健全性，不容易遺忘處理更新事件 Provider 的安裝方式很簡單，在 pubspec.yaml 的 dependcies 內加入 provider 套件即可。然後再 flutter pub get 安裝 12dependencies: provider: ^3.1.0 設定方式 如果只需要設定單一 provider ，有兩種設定方式 使用 Provider&lt;T&gt;.value() 123456Provider&lt;String&gt;.value( value: 'Hello World', child: MaterialApp( home: Home(), )) 比較複雜的情況，像是要處理 constructor 或是 dispose 時，可以使用這種設定方式 12345Provider&lt;MyComplexClass&gt;( builder: (context) =&gt; MyComplexClass(), dispose: (context, value) =&gt; value.dispose() child: SomeWidget(),) 不論是哪一種方式，使要是被 provider 包起來的 child widget，都能讀取設定的 provider，但通常我們需要註冊的 service 不只有一個，這時候就可以使用多層 provider 設定的寫法 1234567MultiProvider( providers: [ Provider&lt;String&gt;.value(value: 'Provider Rocks'), Provider(builder: (context) =&gt; AppConfig,) ], child: someWidget,) 取用方式 如何在不同的 widget 中取得 provider 內的 services 呢? 有以下幾種做法 在 build(context) 下，可以單純的使用 Provider.of&lt;T&gt;(context) 的方式取得，因為 Provider 就是 Inheritedwidget 的實作 1234567class DemoWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var title = Provider.of&lt;String&gt;(context); return Container(child: Text(title)); &#125;&#125; 假設 widget 並不是直接放在 build 下面時，因為沒有方法直接存取 context ，這時候就可以使用 consumer 來存取 provider 1234567891011class DemoWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var title = Provider.of&lt;String&gt;(context); return Container(child: titleWidget); &#125; Widget titleWidget = Consumer&lt;String&gt;( builder: (context, title, child) =&gt; Text(title), );&#125; 更進一步的可以使用 selector 來提升 app 效能，可以設定依某條件才觸發更新 123456Selector&lt;List, int&gt;( selector: (_, list) =&gt; list.length, // 觸發條件 builder: (_, length, __) &#123; return Text('$length'); &#125;) 假設同時需要存取多個 provider 時，可以這樣子寫，以此類推，最多到 6 個 123Widget titleWidget = Consumer2&lt;String, AppConfig&gt;( builder: (context, title, appConfig, child) =&gt; Text(title),); 其他 Provider 類型 除了 Provider 外，還有其他延伸變化類型的 provider name description Provider The most basic form of provider. It takes a value and exposes it, whatever the value is. ListenableProvider A specific provider for Listenable object. ListenableProvider will listen to the object and ask widgets which depend on it to rebuild whenever the listener is called. ChangeNotifierProvider A specification of ListenableProvider for ChangeNotifier. It will automatically call ChangeNotifier.dispose when needed. ValueListenableProvider Listen to a ValueListenable and only expose ValueListenable.value. StreamProvider Listen to a Stream and expose the latest value emitted. FutureProvider Takes a Future and updates dependents when the future completes. ProxyProvider A provider that builds a value based on other providers.(3.0 版新增功能) 完整的 list]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] interactivity 互動 - stateful widget]]></title>
    <url>%2F2019%2F10%2F07%2Fflutter-interactivity%2F</url>
    <content type="text"><![CDATA[一個 App 加減都會有互動，有互動就需要面對狀態管理的課題，而 Flutter 針對狀態管理又有幾套實作的方式，這一個學習筆記將從基本元素開始看起，stateful widget stateless 與 stateful widgets Flutter 內的 widget 有兩種，無狀態和有狀態的 widget，stateless widget 基本上會長這樣 1234567891011121314class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter layout demo!', home: Scaffold( appBar: AppBar( title: Text('Flutter layout demo'), ), // Change to buildColumn() for the other column example body: Center(child: buildRow()), ), ); &#125; 而 stateful widget 會稍微複雜一點，基本架構會這樣，會由兩個 class 組成 1234567891011class FavoriteWidget extends StatefulWidget &#123; @override _FavoriteWidgetState createState() =&gt; _FavoriteWidgetState();&#125;class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; &#123; @override Widget build(BuildContext context) &#123; return Container(); &#125;&#125; 而狀態就可以存放在 state class 內，這裡面的狀態，在 widget 沒有被摧毀前，都會存在著，至於避免狀態隨著 widget 消失而消失的方法，這個下一篇再來探討 12345class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; &#123; bool _isFavorited = true; int _favoriteCount = 41; // ···&#125; 但不論是 stateless 或是 stateful widget 都是透過 build 方法產生要顯示的 UI 畫面，在 stateful widget 內如果要更新 UI 時，可以透過 setState 來觸發 build 方法 12345678910111213141516171819202122232425262728293031323334353637class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; &#123; // ··· @override Widget build(BuildContext context) &#123; return Row( mainAxisSize: MainAxisSize.min, children: [ Container( padding: EdgeInsets.all(0), child: IconButton( icon: (_isFavorited ? Icon(Icons.star) : Icon(Icons.star_border)), color: Colors.red[500], onPressed: _toggleFavorite, ), ), SizedBox( width: 18, child: Container( child: Text('$_favoriteCount'), ), ), ], ); &#125; void _toggleFavorite() &#123; setState(() &#123; if (_isFavorited) &#123; _favoriteCount -= 1; _isFavorited = false; &#125; else &#123; _favoriteCount += 1; _isFavorited = true; &#125; &#125;); &#125;&#125; more about stateful widget 如果要從外部傳資料到 stateful widget 時，又會怎麼處理呢? 繼續使用上面的範例 123456789101112131415class FavoriteWidget extends StatefulWidget &#123; final String name; FavoriteWidget(&#123;this.name&#125;); // @override _FavoriteWidgetState createState() =&gt; _FavoriteWidgetState();&#125;class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; &#123; @override Widget build(BuildContext context) &#123; print($widget.name); // return Container(); &#125;&#125; line 3: 透過建構式的方式將值從外部傳入 line 12: 可以透過 widget.xxx 的方法取得 widget 的變數 參考資料 How Stateful Widgets Are Used Best - Flutter Widgets 101 Ep. 2 Adding interactivity]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] Responsive Apps]]></title>
    <url>%2F2019%2F10%2F07%2Fflutter-responsive-app%2F</url>
    <content type="text"><![CDATA[由於手機或是相關的設備，螢幕尺寸都不一樣，這時候就必須有所謂的響應式的設計，而 Flutter 內野有提供相對應的方法來幫助我們完成這件事情 LayoutBuilder LayoutBuilder 起手式 123LayoutBuilder(builder: (context, constraints) &#123; // Code here&#125;,) context: BuildContext，這裡取得的 context 等同於 build 方法的 context。 constraints: BoxConstraints 型別，內包含許多顯示畫面的相關資訊，就可以透過這資訊來決定畫面要怎麼處理 範例程式 123456789LayoutBuilder( builder: (context, constraints) &#123; if(constraints.maxWidth &gt; 600) &#123; getWideLayout(); &#125; else &#123; getNormalLayout(); &#125; &#125;,) MediaQuery 如果不透過 LayoutBuilder，也可以透過 MediaQuery.of 的方法來取得相關資訊 1234Widget build(BuildContext context) &#123; MediaQueryData media = MediaQuery.of(context); ...&#125; MediaQueryData 包含許多資訊，細節內容可以參閱官方文件 AspectRatio 另外一個很實用的 widget，顯示圖片時，因為圖片本身有所謂的長寬比例，而在做放大縮小時，理論上也應該按一定比例做縮放，這時候就可以使用 AspectRatio 來完成 1234AspectRation( aspectRatio: 3 / 2, child: MyWidget()) aspectRatio 可以指定數字，或是用 width / height 的方式表示 使用範例 在其幾篇有介紹到 GridView.count 的使用方法，由於 count 是很明確的指定每一個 row 的顯示數量，這時候當設備是直立顯示與橫向使用，可使用的寬度就是不一樣，這裡就可以使用 MediaQuery 來做到動態設定 count 的功能 1234567891011121314151617181920final Orientation orientation = MediaQuery.of(context).orientation;...GridView.count( crossAxisCount: (orientation == Orientation.portrait) ? 2 : 3, mainAxisSpacing: 4.0, crossAxisSpacing: 4.0, padding: const EdgeInsets.all(4.0), childAspectRatio: (orientation == Orientation.portrait) ? 1.0 : 1.3, children: photos.map&lt;Widget&gt;((Photo photo) &#123; return GridDemoPhotoItem( photo: photo, tileStyle: _tileStyle, onBannerTap: (Photo photo) &#123; setState(() &#123; photo.isFavorite = !photo.isFavorite; &#125;); &#125;, ); &#125;).toList(),), 參考資料 LayoutBuilder MediaQuery AspectRatio]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] Layout - GridView and ListView]]></title>
    <url>%2F2019%2F10%2F06%2Fflutter-layout-grid-list%2F</url>
    <content type="text"><![CDATA[當畫面內容很長時，既需要可以滾動 (scrollable)，基本上有兩種可以用 Gridview 和 ListView，稍微紀錄一下使用的方式 GridView GridView 有兩種決定每一列能放多少項目的方式 GridView.count: 設定 crossAxisCount 來指定每一列要放多少欄， GridView.extent: 設定 maxCrossAxisExtent 來讓 widget 自行計算每一列可以放多少欄 其他可以用的設定屬性 padding: GridView 外圍的距離 mainAxisSpacing 橫向的寬度 crossAxisSpacing 縱向的寬度 children 要放入 GridView 的 widgets childAspectRatio 放大比例 dragStartBehavior 設定活動的觸發時間點 DragStartBehavior.start: 當拖拉事件發生時才設定初始位置 DragStartBehaviro.down : 當按到畫面時就設定初始位置 範例程式 123456789Widget _buildGrid() =&gt; GridView.extent( maxCrossAxisExtent: 150, padding: const EdgeInsets.all(4), mainAxisSpacing: 4, crossAxisSpacing: 4, children: _buildGridTileList(30));List&lt;Container&gt; _buildGridTileList(int count) =&gt; List.generate( count, (i) =&gt; Container(child: Image.asset('images/pic$i.jpg'))); ListView ListView 就很單純是清單列表 scrollDirection : 設定滾動方向 Axis.verticle 垂直滾動 Axis.horizontal: 水平滾動 假設在每一個 listItem 中間顯示分隔線，ListView 也有提供方法做到這件事情，範例程式碼如下 12345678910ListView.separated( shrinkWrap: true, itemCount: 15, itemBuilder: (BuildContext context, int index) =&gt; Container(child: Image.network('https://picsum.photos/400')), separatorBuilder: (BuildContext context, int index) =&gt; const Divider( color: Colors.red, thickness: 8, ), ); Lifecycle ListView 有一個需要注意的地方是，他並不是所有的清單內的項目都會被建立，只有在顯示範圍內的才會變建立出來，而離開視線範圍的，就會被摧毀，細節說明可以參閱[此文件 的 Child elements’ lifecycle section] (https://api.flutter.dev/flutter/widgets/ListView-class.html) 範例程式 123456789101112131415161718192021222324252627282930Widget _buildList() =&gt; ListView( children: [ _tile('CineArts at the Empire', '85 W Portal Ave', Icons.theaters), _tile('The Castro Theater', '429 Castro St', Icons.theaters), _tile('Alamo Drafthouse Cinema', '2550 Mission St', Icons.theaters), _tile('Roxie Theater', '3117 16th St', Icons.theaters), _tile('United Artists Stonestown Twin', '501 Buckingham Way', Icons.theaters), _tile('AMC Metreon 16', '135 4th St #3000', Icons.theaters), Divider(), _tile('Kescaped_code#39;s Kitchen', '757 Monterey Blvd', Icons.restaurant), _tile('Emmyescaped_code#39;s Restaurant', '1923 Ocean Ave', Icons.restaurant), _tile( 'Chaiya Thai Restaurant', '272 Claremont Blvd', Icons.restaurant), _tile('La Ciccia', '291 30th St', Icons.restaurant), ], );ListTile _tile(String title, String subtitle, IconData icon) =&gt; ListTile( title: Text(title, style: TextStyle( fontWeight: FontWeight.w500, fontSize: 20, )), subtitle: Text(subtitle), leading: Icon( icon, color: Colors.blue[500], ), ); 小結 當然除了這兩個 widget 之外，其他還有所謂的 table 或是 DataTable widget，但這部分就留到後面在探索了，關於 Layout 相關的 widget，就可參閱這份文件，裡面有更詳細的說明 參考資料 GridView(https://api.flutter.dev/flutter/widgets/GridView-class.html) ListView]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] Layout Widget - Container]]></title>
    <url>%2F2019%2F10%2F05%2Fflutter-layout-container%2F</url>
    <content type="text"><![CDATA[Flutter 有幾個基本的 Layout Widget ，例如 Container、GridView、ListView、Stack，Material Wdigets 也有 Card 和 ListTile 這幾種，這一篇先探索 Container，Container 算是最常使用的 layout widget，因為像是 padding、margins、borders 等效果都是由這一個 widget 來設定的 Container Container 的設定項目有 child: 指定一個 widget alignment: Aligment 設定，九宮格 ，topLeft、topCenter、topRight、centerLeft、center、centerRight、bottomLeft、bottomCenter 及 bottomRight constraints: 屬性限制 123456Container( constraints: BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, ), ...&#125; width: 寬度 height: 高度 decoration: 使用 BoxDecoration 來做設定背景 BoxDecooration 可設定以下屬性 color: 設定顏色 image: DecorationImage class border: Border class foregroundDecoration: 前景顏色，填滿 padding 內的區塊 margin &amp; padding 可使用 EdgeInsets class 設定 transform: 可使用 Matrix4 來做轉換效果 1234567891011121314151617181920212223Container( color: Colors.pink[100], child: Container( alignment: Alignment.bottomRight, // 右下對齊 decoration: BoxDecoration( color: Colors.blue, // 背景顏色 image: DecorationImage( image: NetworkImage('https://picsum.photos/300'), // 背景圖 ), border: Border.all(color: Colors.yellow, width: 5), // 邊框線 borderRadius: BorderRadius.all(Radius.circular(10)), // 邊框圓角 ), foregroundDecoration: BoxDecoration( color: Colors.green[50].withOpacity(0.5) // 前景蓋了一層綠色半透明 ), height: 400, // 高度 width: 400, // 寬度 padding: EdgeInsets.all(50), // 上下左右各 padding 50 margin: EdgeInsets.fromLTRB(50, 40, 30, 20), // Margin 邊框設定 child: Image.network('https://picsum.photos/150'), // context widget transform: Matrix4.rotationZ(0.1), // 轉換效果 ), ); 顯示效果 Margin Padding Border 關係圖 參考資料 Container Class BoxDecoration DecorationImage]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] Layout 思維]]></title>
    <url>%2F2019%2F10%2F05%2Fflutter-layout-01%2F</url>
    <content type="text"><![CDATA[這一類的 UI Framework 最需要掌握的是 UI Component (Widget) 的操作，尤其是排版的部分，要如何生出自己想要的畫面，就決定於排版技巧的熟悉度，就像網頁切版，如果 CSS 不熟，就無法切出漂亮有可用的版型，同理，Flutter 也需要先從 Layout Widget 跟設計思維學起 Layout 思維 Flutter 有提供很多種用來排版的 Widget，但要使用哪一種會比較合適，這既需要對每一個 Layout Widget 的特性做深入的了解，但這之前，總要知道如何安排畫面，才能選到對的 Widget。這裡有一個官網文件提供的圖 這是一個算常見的產品介紹畫面，當看到這畫面時，會思考要怎麼呈現。根據圖上面所標示的，可以知道第一層是使用 Row 來呈顯左右兩欄的畫面，而第一欄使用 Column Widget 來顯示其他資訊，而第二欄是使用 Image Widget 來顯示畫面。 再來第一欄的產品資訊使用 Column Widget ，所以物件會是由上而下的呈現，細節設計思維的部分可以參閱下圖 所以綜合這些資訊，我們可以理解成 Flutter 的畫面是從左上到右下，由上而下，由左而右採 S 型移動。這樣理解後，就可以幫我們選擇合適的 layout widget 了 Layout Widget 屬性 Aligning Widgets Row 和 Column widget 內有可以設定排序物件的屬性，mainAxisAligment 和 ``crossAxisAlignment` 而 mainAxisAlignment 有提供下列的選項可以使用 start (預設值) center end spaceAround: 頭尾的空白大小是中間空白的一半 spaceBetween spaceEvenly crossAxisAlignment 有提供以下的選項可使用 center(預設值) baseline: 須設定 textBaseline 屬性 沒設定 baseline 時 end start stretch: 塞滿畫面 Sizing 使用 Expanded widget 可以避免原始圖檔太大造成 App 產生畫面時的錯誤 使用前 使用後 設定 flex 的效果 12345678910111213141516Row( mainAxisAlignment: MainAxisAlignment.start, children: [ Expanded( child: Image.network('https://picsum.photos/300'), ), Expanded( flex: 2, child: Image.network('https://picsum.photos/800'), ), Expanded( flex: 3, child: Image.network('https://picsum.photos/600'), ) ], ); 小結 很多排法跟 css flex 很像，在觀念銜接上是很快速的。基本上沒什麼大問題，下一篇筆記會針對 layout widget 做研究]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 專案程式基本架構]]></title>
    <url>%2F2019%2F10%2F04%2Fflutter-code-structure%2F</url>
    <content type="text"><![CDATA[上一篇建立了第一個 Flutter 專案，這回從零開始，認識 Flutter 的基本程式架構 專案架構 一個基本的 Flutter 程式架構，會長這樣 android / build : 建置輸出成 Android 的專案 ios : 建置輸出成 iPhone 的專案 lib : 主要程式碼存放位置 test : 測試碼存放位置 pubspec.yaml : 專案設定檔，包含引用其他套件的設定是寫在這個檔案內 程式進入點 基本上是由 Android Studio 這逼設定要從哪一個檔案執行，因為每一個 dart 檔案都是可以被單獨執行的。而預設進入點是 main.dart 123456789import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MyAppWidget(); &#125;&#125; line 3: main () 程式進入點 runApp() 是來自 package:flutter/material.dart; 檔案，傳入要啟動的 widget，這裡是傳 MyApp StatelessWidget line 6 build 是 Flutter 產生畫面時會執行的 function, 裡面也是回傳一個要顯示的 widget，而這裡我回傳另外一個 StatefulWidget 至於什麼是 StatelessWidget 和 StatefulWidget 這留到後面在介紹，但到這邊就可以發現 Flutter 是由很多個 widget 將整個 app 的畫面建構出來的一種開發模式 基本 Widgets Text: 要在 Flutter 上面顯示文字，不能很單純的傳入文字，是必須使用 Text widget，Text widget 可以設定文字的顯示方式 123456Text( "Hello", textAlign: TextAlign.center, overflow: TextOverflow.ellipsis, style: TextStyle(fontWeight: FontWeight.bold),) 如果文字要顯示得更多樣式，可以使用 Text.rich 的方法來完成 123456789Text.rich( TextSpan( text: 'Hello', // default text style children: &lt;TextSpan&gt;[ TextSpan(text: ' beautiful ', style: TextStyle(fontStyle: FontStyle.italic)), TextSpan(text: 'world', style: TextStyle(fontWeight: FontWeight.bold)), ], ),) Container 顧名思義，是一個容器可以用來包其他的 widget，可以想成 HTML 裡面的 div 123456789101112Container( height: 56.0, // in logical pixels padding: const EdgeInsets.symmetric(horizontal: 8.0), decoration: BoxDecoration(color: Colors.blue[500]), // Row is a horizontal, linear layout. child: Row( // &lt;Widget&gt; is the type of items in the list. children: &lt;Widget&gt;[ ... ], ), ); Row、Column 是用來排版用的 widget，Row 是橫向排，而 Column 是垂直 Stack 會將 children 內的 widget 用疊層的方式呈現，越晚設定的 widget 會顯示在最上面 12345678910111213141516171819Stack( children: &lt;Widget&gt;[ Container( width: 100, height: 100, color: Colors.red, ), Container( width: 90, height: 90, color: Colors.green, ), Container( width: 80, height: 80, color: Colors.blue, ), ],) 當然還有其他更用來排版的 widget 排版 Flutter 在排版上的想法，跟在開發網頁時有很多雷同的概念，這裡有些圖可以來顯示 Flutter 的排版概念 (圖出處: https://flutter.dev/docs/development/ui/layout) 在不使用 Material Widget 排版的方式會是如此排版 1234567891011121314151617181920212223import 'package:flutter/material.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( decoration: BoxDecoration(color: Colors.white), child: Center( child: Text( 'Hello World', textDirection: TextDirection.ltr, style: TextStyle( fontSize: 32, color: Colors.black87, ), ), ), ); &#125;&#125; 如果是使用 MaterialApp 來排版呢? 起手式是這樣 12345678910111213141516class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter layout demo', home: Scaffold( appBar: AppBar( title: Text('Flutter layout demo'), ), body: Center( child: Text('Hello World'), ), ), ); &#125;&#125; 更多的排版細節等下一篇再來研究，畢竟 Flutter 要寫好，排版的基本功要練好，就跟切版一樣 參考資料 Introduction to widgets]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 環境設定]]></title>
    <url>%2F2019%2F10%2F04%2Fflutter-basic-start%2F</url>
    <content type="text"><![CDATA[Flutter 從去年年底發佈到現在，也接近一年的時間，目前在寫這篇筆記時，Flutter SDK 版本是 1.9，而也是因為看過不少實際將 Flutter 用在專案產品上的案例，所以才決定要開始探索 Flutter。 什麼是 Flutter Flutter 是 Google 所提出用來開發跨平台的 UI Framework。我這裡會指跨平台的原因是，Flutter 從早期的手機跨平台，到現在連 Web 或是桌面應用程式都可以開發。(野心真的很大) 環境設定 在開發之前，需要先安裝 SDK (安裝網址)，根據自己的作業系統選擇對應的 SDK 版本下載安裝，詳細的操作步驟可參閱文件，安裝完成後，可以執行 flutter doctor 來確定開發環境是否完整 如果有提示，可依上述提示安裝缺少的部分，通常都是 Android SDK 環境的部分需要設定 編輯器選擇 官方首推薦使用 Android Studio 作為開發工具，只要有在開發手機 App 的人，對於這工具應不陌生，這 IDE 對於 Flutter 的支援度是完整而且相關的功能是很強大的 當然也可以使用 Visual Studio Code 開發，也是沒有問題的，只是有些在 Android Studio 上有的功能就不一定會出現在 VSC 上。 編輯器設定安裝步驟，可以參閱此連結 建立第一個範例專案 當上面的環境都設定完成後，第一次安裝者，大概會花 1 個小時左右完成設定，大多數的時間都是在等待下載檔案。 來建立第一個範例 Flutter App 來確定所有的設定是正常運作的 開啟 Android Studio 建立新專案 選擇 Flutter Application 輸入專案資訊 設定 package 資訊，基本上預設即可，Kotlin support 當然要選取 Finish 開始建立 專案建立完成後的畫面 預設範本已經是一個可以運行的 Flutter 專案了，這裡我們有兩個選擇，1. 跑在模擬機上 ，或是 2. 跑在實際手機上。我這裡就選擇跑在實體手機，這樣速度比較快 當用 USB 接上手機時， Android Studio 就可以看到手機型號，同樣的動作在 VSC 也可以做到 這時候就可以按下 F5 或是點綠色箭頭部屬 App，部屬中的畫面 如果看到這一個畫面，就代表部屬執行成功 可以點右下角的 + 看到中間數字的改變 Flutter 開發過程中另外一個特色是支援 Hot Reload，這表示在開發時按下儲存時，會立刻影響到開發機器上的 App，可以嘗試修改 Title 來看看效果 修改 MyHomePage Title 文字後儲存看結果，結果會發現 Title 被改變了，而且原本的狀態也沒有被重製，這就是 Hot Reload 的好處 小結 跨平台開發的框架越來越多，而 Flutter 算是後起新秀，也希望 Google Flutter 和社群能持續努力讓此生態圈更強大，之後的學習筆記將會從零開始探索 Flutter 參考資料 Vysor 可以在桌面上看到手機畫面的工具 Dart 開發 Flutter 所用的程式語言]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] generate]]></title>
    <url>%2F2019%2F09%2F04%2Frxjs-generate%2F</url>
    <content type="text"><![CDATA[generate 是 RxJS 裡面的 for loop 方法，這樣的描述應該夠簡單明瞭了 基本用法 這是 JavaScript for loop 的寫法 123for(let i=0; i&lt; 100; ++i)&#123; ...&#125; 而這是 RxJS 使用 generate 的寫法 1generate(0, x=&gt; x&lt; 100, x=&gt; ++x) generate 介面 1generate&lt;T, S&gt;(initialStateOrOptions: S | GenerateOptions&lt;T, S&gt;, condition?: ConditionFunc&lt;S&gt;, iterate?: IterateFunc&lt;S&gt;, resultSelectorOrObservable?: (ResultFunc&lt;S, T&gt;) | SchedulerLike, scheduler?: SchedulerLike): Observable&lt;T&gt; 變化用法 with resultSelector 12345const source = generate(0, x =&gt; x &lt; 10, x =&gt; ++x, x =&gt; x + '!!');source.subscribe(&#123; next: v =&gt; console.log(v)&#125;) 輸出結果 串接其他 observable with from 1234567const source = from(['a', 'b', 'c']).pipe( concatMap((value) =&gt; generate(0, x =&gt; x &lt; 3, x =&gt; ++x, x =&gt; value + '-' + x)))source.subscribe(&#123; next: v =&gt; console.log(v)&#125;) double generate 12345678const source = of(['a', 'b', 'c', 'd']).pipe( concatMap((value) =&gt; generate(0, x =&gt; x &lt; value.length, x =&gt; ++x, x =&gt; value[x] + '-' + x)), concatMap((value) =&gt; generate(0, y =&gt; y &lt; 3, y =&gt; ++y, y =&gt; value + '-' + y)))source.subscribe(&#123; next: v =&gt; console.log(v)&#125;) range 效果 RxJS 裡面原本就有一個 range 的 observable，但是卻沒有辦法設定 step，這時候就可以使用 generate 來完成這件事情 12345const source = generate(0, x =&gt; x &lt; 10, x =&gt; x + 2)source.subscribe(&#123; next: v =&gt; console.log(v)&#125;) 參考資料 Generate API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] WebAPI with CancellationToken]]></title>
    <url>%2F2019%2F09%2F03%2Fcsharp-cancellationtoken%2F</url>
    <content type="text"><![CDATA[這裡是 WebAPI 用非同步的寫法 123public async Task&lt;ActionResult&gt; SomeItem(int id) &#123; ....&#125; 但如果想要搭配 RxJS 的 switchMap 使用，這樣子是不夠的。我們需要使用 CancellationToekn 的協助 先簡單介紹什麼是 switchMap ，前端 RxJS 的 switchMap 的作用是當快速發出 request 時，會將之前的 request 全部 cancel 掉，只保留最後一次的 request，所以當打開開發者工具時，在 Network 下可以看到 cancel 的狀態，但這一個現象只是前段處理，如果後端沒有處理取消行為，所有的 request 還是會全部跑完，只是前端最後不理會而已。 如果 RxJS 的 switchMap 是這樣的功能，那後端要怎麼處理呢? 好家在 C# 有對應的處理方式，那就是使用 CancellationToken，基本寫法是這樣 1234public async Task&lt;ActionResult&gt; ShowItem(int id, CancellationToken cancellationToken)&#123; return await rep.getItem(id).FirstOrDefaultAsync(cancellationToken);&#125; 其實就這麼簡單，C# 的 async 方法基本上可接受 CancellationToken，傳進去就可以，當前端發出取消請求，後面的行為也會跟著被取消。]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] 探討 repeat]]></title>
    <url>%2F2019%2F08%2F30%2Frxjs-repeat%2F</url>
    <content type="text"><![CDATA[來探討一下 RxJS 的 repeat 這個 operator repeat 的功能 repeat 的功能是當一個 Observable 完成時，會重新再 subscribe n 次 使用的方式是 1obs.pipe(retry()).subscribe(); repeat(count: number: -1) 當不給重複的次數時，將會一直有作用 基本範例 1234567891011import &#123; of &#125; from 'rxjs';import &#123; repeat, delay &#125; from 'rxjs/operators';const source = of('Repeat message');const example = source.pipe(repeat(3));example.subscribe(x =&gt; console.log(x));// Results// Repeat message// Repeat message// Repeat message 探討 根據上面的簡單介紹，可以知道 repeat 的用法。延伸思考，repeat 的作用範圍是如何定義，而 Observable 所傳出的值是否如果我們所預期的呢? 如果搭配其他的 operator 是否有先後順序的問題? 先來一個簡單的問題，重複取十次值 123456789const source = () =&gt; new Promise((resolve)=&gt; resolve(Math.random()*10));from(source()).pipe( repeat(10)).subscribe(&#123; next: value=&gt; console.log(value)&#125;); 順序重要嗎? 根據實驗，順序其實不重要，都會被重新 subscribe Observable 的值呢 根據實驗，repeat 所使用的 observable 值是第一次發生的結果，這表示，如果想要做到每一次重新啟動都要觸發 source observable 時，就必須使用不同的寫法 解法1: 如果想要的效果可以使用 interval 完成，改用 interval + mergeMap(or other map) + take 來完成 解法2: 使用 defer 來包 Observable/Promise 123456789const source = () =&gt; new Promise((resolve) =&gt; resolve(Math.random() * 10));defer(() =&gt; from(source())) .pipe( repeat(10) ) .subscribe(&#123; next: value =&gt; console.log(value) &#125;); 啟動範圍 repeat 會重新 subscribe 所歸屬的 Observable 小結 每一個 operator 都有可以細細品嘗的細節，跟 repeat 類似的 operator 有 repeatWhen 、retry、retryWhen ，也都可以去看看了解一下]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] HttpInterceptor 應用 - 日期轉換]]></title>
    <url>%2F2019%2F08%2F22%2Fangular-http-inteceptor-practice-1%2F</url>
    <content type="text"><![CDATA[呼叫後端 API 當遇到回傳資料欄位是日期時，我們所拿到的都是文字格式的日期資料，這時候就必須多做一次轉換才能變成日期型別，因為 TypeScript 並不會因為將 Model Class 欄位標示為日期格式，就會自動轉換，並不會好嗎，這樣太為難 TypeScript 了。 所以看起來最省事的解法是在 http request 時就解結掉，這樣就不需要到處寫日期轉換 既然是要在 Http 層處理，HttpInterceptor 就是個好選擇，也懶得解釋了，程式碼自己看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import &#123; HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse&#125; from '@angular/common/http';import &#123; Observable &#125; from 'rxjs';import &#123; tap &#125; from 'rxjs/operators';export class JsonInterceptor implements HttpInterceptor &#123; private utcRegex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;(?:\.\d*)?)Z$/; private dateRegex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;(?:\.\d*)?)$/; private zoneRegex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;(?:\.\d*)?)([+-])(\d&#123;2&#125;):(\d&#123;2&#125;)$/; intercept( req: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req).pipe( tap((event: HttpEvent&lt;any&gt;) =&gt; &#123; if (event instanceof HttpResponse) &#123; this.convertDates(event.body); &#125; &#125;) ); &#125; private convertDates(object: Object) &#123; if (!object || !(object instanceof Object)) &#123; return; &#125; if (object instanceof Array) &#123; for (const item of object) &#123; this.convertDates(item); &#125; &#125; for (const key of Object.keys(object)) &#123; const value = object[key]; if (value instanceof Array) &#123; for (const item of value) &#123; this.convertDates(item); &#125; &#125; if (value instanceof Object) &#123; this.convertDates(value); &#125; if (typeof value === 'string') &#123; let a; if (typeof value === 'string') &#123; a = this.utcRegex.exec(value); if (a) &#123; object[key] = new Date( Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]) ); continue; &#125; a = this.dateRegex.exec(value); if (a) &#123; object[key] = new Date( +a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6] ); continue; &#125; a = this.zoneRegex.exec(value); if (a) &#123; const dir = a[7] === '+' ? -1 : 1; object[key] = new Date( Date.UTC( +a[1], +a[2] - 1, +a[3], +a[4] + dir * a[8], +a[5] + dir * a[9], +a[6] ) ); continue; &#125; &#125; &#125; &#125; &#125;&#125; 記得在 App.module 的地方註冊 Http Interceptor 12345&#123; provide: HTTP_INTERCEPTORS, useClass: JsonInterceptor, multi: true &#125;,]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] Pipe 的延伸應用]]></title>
    <url>%2F2019%2F08%2F19%2Fangular-rxjs-practice-2%2F</url>
    <content type="text"><![CDATA[昨天在重構手上一個案子的程式碼，其中有一個功能是在讀取資料時，要顯示 loading 的圖示，這算是一個很常見的需求，但要怎麼寫才能寫得漂亮，這是我目前得到的答案 LoadingComponent 這個案子我使用 Angular Material (MatProgressSpinnerModule ) 的 mat-progress-spinner 和 MatDialog 來完成，簡單的說，就是當讀取時，使用 MatDialog 來開啟 LoadingComponent，沒什麼特殊的技巧，最多是 css 的設定 1234.transparent .mat-dialog-container &#123; box-shadow: none; background: rgba(0, 0, 0, 0.0);&#125; 監控是否開啟 LoadingComponet 的程式 1234567891011121314this.loadingService.isLoading$.subscribe(isLoading =&gt; &#123; if (isLoading) &#123; this.dialogRef = this.dialog.open(LoadingComponent, &#123; height: '200px', width: '200px', panelClass: 'transparent', disableClose: true &#125;); &#125; else &#123; if (this.dialogRef) &#123; this.dialogRef.close(); &#125; &#125; &#125;); LoadingService 比較特殊的處理是在 LoadingService 的地方，這裡我有用到 TypeScript 多型的手法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384load&lt;T&gt;(): UnaryFunction&lt;T, T&gt;;load&lt;T, A&gt;(fn1: UnaryFunction&lt;T, A&gt;): UnaryFunction&lt;T, A&gt;;load&lt;T, A, B&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;): UnaryFunction&lt;T, B&gt;;load&lt;T, A, B, C&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;): UnaryFunction&lt;T, C&gt;;load&lt;T, A, B, C, D&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;): UnaryFunction&lt;T, D&gt;;load&lt;T, A, B, C, D, E&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;): UnaryFunction&lt;T, E&gt;;load&lt;T, A, B, C, D, E, F&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;, fn6: UnaryFunction&lt;E, F&gt;): UnaryFunction&lt;T, F&gt;;load&lt;T, A, B, C, D, E, F, G&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;, fn6: UnaryFunction&lt;E, F&gt;, fn7: UnaryFunction&lt;F, G&gt;): UnaryFunction&lt;T, G&gt;;load&lt;T, A, B, C, D, E, F, G, H&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;, fn6: UnaryFunction&lt;E, F&gt;, fn7: UnaryFunction&lt;F, G&gt;, fn8: UnaryFunction&lt;G, H&gt;): UnaryFunction&lt;T, H&gt;;load&lt;T, A, B, C, D, E, F, G, H, I&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;, fn6: UnaryFunction&lt;E, F&gt;, fn7: UnaryFunction&lt;F, G&gt;, fn8: UnaryFunction&lt;G, H&gt;, fn9: UnaryFunction&lt;H, I&gt;): UnaryFunction&lt;T, I&gt;;load&lt;T, A, B, C, D, E, F, G, H, I&gt;( fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, B&gt;, fn3: UnaryFunction&lt;B, C&gt;, fn4: UnaryFunction&lt;C, D&gt;, fn5: UnaryFunction&lt;D, E&gt;, fn6: UnaryFunction&lt;E, F&gt;, fn7: UnaryFunction&lt;F, G&gt;, fn8: UnaryFunction&lt;G, H&gt;, fn9: UnaryFunction&lt;H, I&gt;, ...fns: UnaryFunction&lt;any, any&gt;[]): UnaryFunction&lt;T, &#123;&#125;&gt;;/* tslint:enable:max-line-length */load(...operations: OperatorFunction&lt;any, any&gt;[]): UnaryFunction&lt;any, any&gt; &#123; return pipe( tap(() =&gt; this.begin()), pipeFromArray(operations), tap(() =&gt; this.finish()) );&#125; 我建立了一個 load 方法，這一個方法的使用方式跟我們在使用 pipe 的方式是一樣的，只是我在最前面跟最後面加上 loading 的開關，這樣的寫法雖然囉嗦，卻可以保留型別推導的能力，至於實際要怎麼使用呢? 範例如下 12345678910111213combineLatest([favGroup$, searchField$, paginator$]) .pipe( this.loadingService.load( switchMap(() =&gt; this.api.randomUsr()), map(users=&gt; users.slice(0,9)), ... ) ) .subscribe(&#123; next: (data) =&gt; &#123; ... &#125; &#125;); 這樣封裝起來，在任何需要的地方，都只需要呼叫同一個方法即可達到 loading 顯示的效果]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] App Service Deployment with Azure DevOps]]></title>
    <url>%2F2019%2F08%2F13%2Fazure-app-service-deployment-with-devops%2F</url>
    <content type="text"><![CDATA[上一篇提到使用 Deployment with GitHub，Azure 當然要整合自家的 DevOps 才能將效益最大化，這一篇就來看看整合 DevOps 後能做到那些事情 串接 DevOps 假設大家都知道如何在 Azure DevOps 上面開專案跟將程式 Push 到上面，這時 App Service 要串接步驟就很簡單 【部屬中心】選擇 Azure Repos 步驟二、不選擇 Azure Pipelines 就說不過去了 選擇專案放置的位置 步驟四，確認無誤後即可完成整個動作 當上述動作完成後，我們回到 Azure Devops 的畫面，可以看到在 PipleLines 的 Build 頁面，看到一個自動產生的 Build Pipeline，更好的是，連 Release Piple 也一併完成了。 部屬中心顯示的歷史紀錄 退版 當 App Service 部署中心連結到 DevOps 又選擇 pipelines 時，退版的動作就不一樣了，將會是透過 release pipeline 的 redeploy 來完成 選擇要退版的紀錄，並點選 release x 這時候會開啟該 Release pipeline 的操作畫面 將滑鼠移到 stages production 的文字方框上，底下會出現 Redeploy 的按鈕 當按下 Redeploy 的按鈕時，會跳出一個視窗做最後的確認，如果確定，就按下 Deploy 如何分辨目前所在版本 在 Pipelines -&gt; Releases 的第一個畫面，可以透過 Stages 的顯示方式來得知目前的版本 目前所在版本會用有背景色做標示 多 Stage 設定 如果我們想要做多 Stage 的 release 設定又要搭配 App Services 時，基本要求方案是基本以上(Standard)，先來將 App Service 使用的方案升級一下 App Service 部分 升級方案 (如果原本方案不支援部署位置功能) 可以使用部署位置的最低方案為 S1 升級完成後，即可看到這一畫面 接下來是多加入一個位置 (Slot) 名稱: 位置名稱，可自己設定 複製設定: 假設原本已有設定一堆參數設定，這時候為了將設定一致性或是因為程式某些設定是吃環境參數設定時，就可以選擇要複製的站台 確認後即可按下【新增】按鈕 在部署位置頁面節可看到兩個部署位置，分別為獨立的站台 (各自擁有瀏覽網址) DevOps 部分 當 App Service 環節設定完成後，即可到 Azure DevOps 編輯 release pipeline 選擇 release pipeline 並進行編輯動作\ 按下在 Stages 的 Add ，並選擇 New Stage 範本選擇: Azure App Service deployment with Slot 設定完 Stage 名稱後即可關掉該畫面 設定剛新增的 Stage Slot: 選擇剛剛在 App Service 所新增的新位置 如果不想要自動進行 Swap 動作時，則可以 Manage Azure App Service - Slow Swap 給拿掉 設定完成後，可以先將預設的 Production 切換成手動 記得儲存設定 測試 當新開的部署位置，該位置是不會有任何程式碼的，所以開啟該網址應該會看到這個畫面 先 push 一個新的 commit 到 devOps Repo，重新觸發整個部署流程 當一切完成後，剛新增的位置，就可以看到修改後的結果，而原本正式的網站還是保留原本舊版的畫面 如果能正確地看到這個畫面，表示剛剛設定的 release pipeline 是正確的 交換 當我們確認一切的修改都是正確的，想要將 QA Stage 的內容更新到正式環境時，只需要透過【交換】的方式即可完成 資訊確認後即可進行交換的動作，成功會出現的訊息 重新檢視兩個網站的內容，會發現顯示的內容的確有被交換 小結 Multi-stage 的設定當然沒有那麼簡單，而 App Service 的部署位置也可以玩一些不同的東西，但這一切就留在後面在玩吧。 參考資料 Define your multi-stage continuous deployment (CD) pipeline]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] Deployment Center in App Service]]></title>
    <url>%2F2019%2F08%2F12%2Fazure-app-service-deployment%2F</url>
    <content type="text"><![CDATA[部署網站到 Azure App Service 的方式有很多種，而為了讓部署的動作能連貫且步驟是最少的，就必須整合到 DevOps 之類的服務。App service 針對部署也有提供幾個不錯的功能，這一篇文章會先從 Deployment Center (部署中心) 開始 Azure App Service 的部署中心，支援多種版控服務，像是 Azure Repos、GitHub、Bitbucket、Local Git 還有一些檔案服務等，這篇文章，我們使用 GitHub 來作為持續部署的程式來源 基本設定操作 建立 GitHub Repo 建立一個簡單的 Razor Page 網站，並將其推送到 GitHub Repo 上 建立 Azure App Service 點選 部署中心 (Deployment Center) 選擇原始檔控制，我這裡選擇 GitHub，由於第一次尚未授權，所以要先進行授權 完成授權，點選【繼續】 選擇【組件提供者】，這邊選擇 App Service 組件服務 後，繼續下一步 進入設定頁面，如果選擇不到 Repo 的話，那表示在 GitHub 這邊還需要在設定一些東西 前往 GitHub ，進入 【Setting】頁面 進入 【Application】 並選擇 【Authorized OAuth Apps】，找到 Azure App Service 將尚未授權的 Orgranization ，開放權限 (Grant) 如果還沒有看到，重新整理畫面，並重新做一次 Deployment Center 的設定畫面，應可以看到相關資訊了 選擇要部署的 Repo 來源 繼續進入最終步驟，確認完成。 完成設定 第一次部署成功 執行結果。太棒了，看到畫面 第二次 Commit 嘗試修改一些文字並 commit 到 GitHub 上後，觀察看看部署中心是否有做到自動建置部署的動作 當 commit push 到 GitHub 上，在部署中心的頁面上，會發現第二次 Commit 的訊息 修改後的畫面 可以看到順利修改後的結果，這代表整個流程已可以正常運作了 退版 有時候在 commit 時，發現上的版本有重大問題需要退版時，透過部署中心可以快速做到退版，以下是操作步驟 選擇想要退版的 commit 紀錄 點選【重新佈署】 退版成功 就是這麼簡單 結論 雖然 GitHub 是很常見好用的程式碼寄放的位置，但如果要跟 Azure App Service 整個的部署整合更流暢，我相信使用 Azure DevOps 的服務會是最佳選擇]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>App Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] 使用 nodeservice 來串接 puppeteer 服務]]></title>
    <url>%2F2019%2F08%2F08%2Fcore-mvc-nodeservice-puppeteer%2F</url>
    <content type="text"><![CDATA[ASP.NET Core MVC 有提供一個 nodeservice 的服務，這一個服務可以將 .NET Core 與 JavaScript 的程式碼整個傳接起來，怎麼使用，下面再來介紹 另外一個要使用的套件叫做 Puppeteer，這一個套件是 Google 出的，可以讓我們創造出 headless 的瀏覽器環境，功能之強大，需要另外寫文章介紹，這邊只是做個配角 NodeServices 不管底層怎麼運作，先來知道怎麼使用吧，如果你的 .NET Core 版本有維持在最新版的話，在建立一個 MVC 專案時，只需要在 startup.cs 內新增這一行即可完成加入 NodeServices 的功能 123456public void ConfigureServices(IServiceCollection services)&#123; ... services.AddNodeServices(); ...&#125; 加入完成後，基本上就可以使用 nodeServices 了 接下來就是使用 npm 來準備 node service 的開發環境，不一定要使用 TypeScript，在專案根目錄下，執行 npm init -y 來建立一個簡單的 package.json 檔案 新增第一個 script 檔案 在專案中開一個資料夾來放 JavaScript/TypeScript 檔案，如果是新增 TypeScript 檔案，Visual Studio 基本上會詢問你是否要安裝 TypeScriptBuild 的套件，這邊就依各位的口味做選擇了。 新增 hello-world.ts 123456789declare var module: any;type Callback = (error: any, result: any) =&gt; void;function helloWorld (callback: Callback, name: string) &#123; callback(null, `Hello $&#123;name&#125;`);&#125;module.exports = helloWorld; NodeServices 可以透過 InvokeAsync&lt;T&gt; 的方法執行某個檔案中預設 export 的方法，當然在同一個檔案可以同時公開多個方法，這時候就需要使用另外一個方法 export 出去的 function ，第一個參數一定是 callback，這個 callback 的型別是 (error, result) =&gt; void Controller 的部分，當然需要將 NodeSerivces 注入進來使用 1234private INodeServices _nodeservices;public ValuesController(INodeServices nodeservices) &#123; _nodeservices = nodeservices;&#125; 執行 JS 的方法 123456[HttpGet]public async Task&lt;ActionResult&lt;string&gt;&gt; Get()&#123; var result = await _nodeservices.InvokeAsync&lt;string&gt;("./Scripts/hello-world", "Kevin"); return result;&#125; InvokeAsync(&lt;file path&gt; , 要傳入的參數) 當呼叫該 api 時，就會回傳 Hello Kevin 的文字在畫面上 一個 JS 檔案多個方法 當然一個 JS/TS 檔案內可以有多個可執行且公開的方法 12345678910111213declare var module: any;function add(callback, a: number, b: number) &#123; callback(null, a + b);&#125;function subtract(callback, a: number, b: number) &#123; callback(null, a - b);&#125;module.exports = &#123; add, subtract&#125; 在這情形下，NodeServices 提供另外一個方法來呼叫執行 123456public async Task&lt;ActionResult&lt;long&gt;&gt; Get()&#123; var result = await _nodeservices.InvokeExportAsync&lt;long&gt;("./Scripts/fns", "add", 2,1); result = await _nodeservices.InvokeExportAsync&lt;long&gt;("./Scripts/fns", "subtract", result, 3); return result;&#125; InvokeExportAsync&lt;T&gt;(&lt;file path&gt;, &lt;export function name&gt;, args) 到這邊我們已經知道基本 NodeServices 的使用方法 情境應用 手上有一個案子，需要用到 Puppeteer 將 SPA 的網頁產生靜態檔案，除了使用 rendertron 外，似乎也可以使用 Puppeteer 這個解決方案，畢竟不是所有人都有辦法架設 rendertron 的服務 快速簡單的介紹 Puppeteer ，Puppeteer 就是 Headless Chrome Node API，結束 安裝 puppeteer 123npm i puppeteer// ornpm i puppeteer-core puppeteer 會下載最新版的 Chromium 到電腦上，檔案很大(~170MB Mac, ~282MB Linux, ~280MB Win)，但能確保 API 能跑 puppeteer-core 不會下載 Chromium，可以使用本機上安裝的 Chrome 也可以連接遠端的 puppeteer services，像是 http://browserless.io 新增 render.ts 檔案 1234567891011121314const puppeteer = require('puppeteer');module.exports = async function (callback, url) &#123; try &#123; const browser = await puppeteer.launch() const page = await browser.newPage(); await page.goto(url, &#123; waitUntil: 'networkidle2' &#125;); const content = await page.content(); callback(null, content); await browser.close(); &#125; catch (ex) &#123; callback(null, ex); &#125;&#125; line 5: 啟動 puppeteer line 6: 開啟新頁籤 line 7: 前往某網址，並等到該網頁的連線請求低於某一種程度 (networkidle2)，還有其他模式 line 8: 取得該網頁的內容 (HTML) line 9: 回傳結果 line 10: 關閉 puppeteer 建立 Middleware，篩選需要執行 render 方法的對象，新增 PuppeteerMiddleware.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Http.Extensions;using Microsoft.AspNetCore.NodeServices;using System.Linq;using System.Threading.Tasks;namespace nodeservices_demo.Extensions&#123; public static class PuppeteerMiddlewareExtension &#123; public static IApplicationBuilder UsePeppeteerRenderer(this IApplicationBuilder builder) &#123; return builder.UseMiddleware&lt;PuppeteerMiddleware&gt;(); &#125; &#125; public class PuppeteerMiddleware &#123; string[] BotUserAgents = new string[] &#123; "W3C_Validator", "baiduspider", "bingbot", "embedly", "facebookexternalhit", "linkedinbo", "outbrain", "pinterest", "quora link preview", "rogerbo", "showyoubot", "slackbot", "twitterbot", "vkShare" &#125;; private readonly RequestDelegate _next; private readonly INodeServices _nodeServices; public PuppeteerMiddleware(RequestDelegate next, INodeServices nodeServices) &#123; _next = next; _nodeServices = nodeServices; &#125; public Task Invoke(HttpContext context) &#123; if (IsNeedRender(context)) &#123; return InvokeRender(context); &#125; else &#123; return _next(context); &#125; &#125; private bool IsNeedRender(HttpContext context) &#123; var userAgent = context.Request.Headers["User-agent"].ToString().ToLowerInvariant(); return BotUserAgents.Any(x =&gt; userAgent.Contains(x.ToLowerInvariant())); &#125; private async Task InvokeRender(HttpContext context) &#123; var cancellationToken = context.RequestAborted; var result = await _nodeServices.InvokeAsync&lt;string&gt;("./Scripts/render", context.Request.GetDisplayUrl()); await context.Response.WriteAsync(result, cancellationToken); &#125; &#125;&#125; 使用 middleware 123456public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; ... app.UsePeppeteerRenderer(); ...&#125; 至於如何測試，我們可以透過 curl 這指令來完成 1curl -D - &lt;url&gt; -A &lt;user-agent&gt; 範例 1curl -D - https://2019.angular.tw -A bingbot 結論 ASP.NET Core 所提供的 NodeServices 可以讓我們使用很多前端好用的套件工具，就自己的感覺，我認為開發者的發揮空間又更大了 此外，Puppeteer 這套件的功能之強大，並不是這一篇能涵蓋的，之後再利用幾篇來介紹這一個工具 參考資料 NodeServices Puppeteer]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 與 O365 跳舞系列 - OneDrive]]></title>
    <url>%2F2019%2F07%2F26%2Fangular-with-o365-3%2F</url>
    <content type="text"><![CDATA[自從去年寫了兩篇跟 O365 Graph 有關的文章後，就停了好長的一段時間，長到連登入的方法都改變了，(登入篇 也做了相對應的更新) 存取檔案可以算是很常見的需求，所以這次要來研究如何讀寫在 OneDrive 上的檔案 權限 當然要存取檔案系統，就必須申請權限，操作檔案需要請求 Files.Read 或 Files.ReadWrite 讀寫權限。 基本概念 Microsoft Graph 針對檔案操作有兩種類型的物件 Drive : 代表著使用者裝檔案的容器或檔案的基本資訊 DriveItem: 呈現檔案或是資料夾本身的詳細資訊 這裡我只會針對 DriveItem 去做展示，大部分的操作也是針對 DriveItem 資料類型去做操作。 API 操作 列表 /drivers/{drive-id} : 取得特定 drive 的 metadata /drive/root : 取得目前使用者預設根目錄 /drive/root/children 列出目前使用者根目錄下的所有資料夾和檔案項目 /drive/root/search: 搜尋根目錄 /drive/sharedWithMe: 列出分享給使用者的檔案清單 /drive/special/{special-folder-id}: 進入特定的資料夾，特殊資料夾有以下 Name ID Documents documents Photos photos Camera Roll cameraroll App Root approot Music music 範例程式 123456789getPhotos() &#123; const headers = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http.get( 'https://graph.microsoft.com/v1.0/me/drive/special/photos',&#123;headers&#125; ); &#125; 此 API 呼叫會回傳 Drive 型別的資訊 123456789101112getPhotos() &#123; const header = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http.get( 'https://graph.microsoft.com/v1.0/me/drive/special/photos/children', &#123; headers: header &#125; ); &#125; 取得 Photos 資料夾下所有的檔案項目 回傳的資料型別為 DriveItem 如果是檔案，就會出現 @microsoft.graph.downloadUrl ，如果是資料夾就不會 新增資料夾 建立資料夾當然需要擁有寫入資料夾的權限，記得要授權 Files.ReadWrite 可以使用的 API 有 POST /drives/{drive-id}/items/{parent-item-id}/children POST /groups/{group-id}/drive/items/{parent-item-id}/children POST /me/drive/items/{parent-item-id}/children POST /sites/{site-id}/drive/items/{parent-item-id}/children POST /users/{user-id}/drive/items/{parent-item-id}/children 範例程式 12345678910111213141516createFolder() &#123; const driveItem = &#123; name: 'New Folder', folder: &#123;&#125;, '@microsoft.graph.conflictBehavior': 'rename' &#125;; const headers = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http.post&lt;any&gt;( 'https://graph.microsoft.com/v1.0/me/drive/items/689EA0E484C3AFBF!33462/children', driveItem, &#123; headers &#125; );&#125; line 5: 決定當遇到名稱重複時的動作 fail replace rename : 在名稱後給予流水號，例如 fname 、fname 1 、fname 2 回傳的 response 內就會包含這一次建立資料夾的相關資訊 修改名稱 / 移動檔案 1234567891011121314renameItem() &#123; const driveItem = &#123; name: 'Folder After Rename' &#125;; const headers = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http.patch&lt;any&gt;( 'https://graph.microsoft.com/v1.0/me/drive/items/&#123;item-id&#125;', driveItem, &#123; headers &#125; ); &#125; 要使用 patch 的方法 如果移動資料夾或是檔案，要修改的對象為 parentReference 裡的 id 123456const driveItem = &#123; parentReference: &#123; id: '&#123;new-parent-folder-id&#125;' &#125;, name: 'new-item-name.txt' &#125;; 刪除檔案 刪除檔案就比較直覺了 可以使用的 API 有 DELETE /drives/{drive-id}/items/{item-id} DELETE /groups/{group-id}/drive/items/{item-id} DELETE /me/drive/items/{item-id} DELETE /sites/{siteId}/drive/items/{itemId} DELETE /users/{userId}/drive/items/{itemId} 範例程式 1234567891011 deleteItem() &#123; const headers = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http.delete&lt;any&gt;( 'https://graph.microsoft.com/v1.0/me/drive/items/&#123;item-id&#125;', &#123; headers &#125; );&#125; 下載檔案 透過 API 方式取得檔案的內容，可以使用的 API 有 GET /drives/{drive-id}/items/{item-id}/content GET /groups/{group-id}/drive/items/{item-id}/content GET /me/drive/root:/{item-path}:/content GET /me/drive/items/{item-id}/content GET /sites/{siteId}/drive/items/{item-id}/content GET /users/{userId}/drive/items/{item-id}/content 範例程式 1234567891011121314151617import &#123; saveAs &#125; from 'file-saver';downloadFile() &#123; const headers = new HttpHeaders().append( 'Authorization', `Bearer $&#123;this.accessToken&#125;` ); return this.http .get( 'https://graph.microsoft.com/v1.0/me/drive/items/&#123;item-id&#125;/content', &#123; headers, responseType: 'blob' &#125; ) .subscribe(res =&gt; &#123; const blob = new Blob([res], &#123; type: res.type &#125;); const filename = 'example.txt'; saveAs(blob, filename); &#125;); &#125; 偷懶一下，安裝 file-saver 套件 設定 responseType 至 blob 結語 更多的相關操作可以參閱官方文件，文件的部分寫得算是很詳細。文件的連結我就放在下面的參考資料內 參考資料 Microsoft Graph Rest API V1.0 Drive DriveItem]]></content>
      <categories>
        <category>Angular</category>
        <category>O365</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Firebase 該如何連結多登入方式到同一個驗證帳號上]]></title>
    <url>%2F2019%2F07%2F15%2Fangular-firebase-link-provide-to-same-account%2F</url>
    <content type="text"><![CDATA[AngularFire 讓我們在處理 firebase 相關功能時，變得十分簡單，可以說是無痛結合。周末有朋友提出一個問題，當我們利用 Firebase 當作系統的登入驗證功能時，由於 Firebase本身有提供多種登入驗證的方式，我們該如何讓使用者可以用不同的登入方式登入，但我們仍將其視為同一使用者呢? 其實 firebase 有提供一種帳號連結模式，讓我們可以連結多種登入方式到同一個帳號上，讓該使用者即使用不同的方式登入系統，能可取得相同的 uid. 這篇文章將會筆記如何完成這一動作 範例 當使用者第一次使用第三方驗證登入時，Firebase 就會先 assign 一個 uid 給該使用者使用，但有些情境是類似這樣 網站也允許使用者使用帳號密碼登入，這裡我們就來實做這一個功能，讓 Google 登入的帳號，也可以綁訂一個 email 帳號做後續的登入 連結 先用 Google 登入的方式取得第一個 UID 12345678import &#123; auth &#125; from 'firebase/app';export class AppComponent implements OnInit &#123; constructor(private afAuth: AngularFireAuth) &#123;&#125; googleLogin() &#123; this.afAuth.auth.signInWithPopup(new auth.GoogleAuthProvider()); &#125;&#125; AngularFireAuth 的 authState 可以用來取得已登入 Firebase 的 User 物件資訊 12345678import &#123; User&#125; from 'firebase/app';...user: User;this.afAuth.authState.subscribe(user =&gt; &#123; console.log(user); this.isLogin = user !== null &amp;&amp; !user.isAnonymous; this.user = user; &#125;); 刻一個表單用來取得使用者的 email 與 password 資訊 1234account = new FormGroup(&#123; email: new FormControl(), password: new FormControl()&#125;); 12345&lt;form [formGroup]="account"&gt; Email: &lt;input type="text" formControlName="email"&gt; password: &lt;input type="password" formControlName="password"&gt; &lt;button (click)="linkWithEmail()"&gt;Link With Email&lt;/button&gt;&lt;/form&gt; 綁定 email 資訊到登入的使用者身上 12345678910linkWithEmail() &#123; const &#123; email, password &#125; = this.account.value; const credential = auth.EmailAuthProvider.credential(email, password); this.user .linkWithCredential(credential) .then(success =&gt; &#123; console.log(success); &#125;) .catch(error =&gt; console.log(error)); &#125; 連結成功後並不會觸發 afAuth 狀態 連結成功後會重新回傳一個 User 物件，建議更新原本的 user 變數值. 如果要綁定其它第三方認證的方式 123linkWithFB() &#123; this.user.linkWithPopup(new auth.FacebookAuthProvider());&#125; 連結狀態 我們又該如何得知此帳號到底有連結那些 provider，在 user 物件資訊內，可以從 providerData (陣列)取得更多資訊，所以可以透過該陣列內取得其它的連結服務 (可利用 providerId ) 1this.userProviders = user.providerData.map(userInfo =&gt; userInfo.providerId); 取消連結 既然能連結，就能取消連結，取消連結的方式如下，其它 provider 也比照辦理 1this.user.unlink(auth.EmailAuthProvider.PROVIDER_ID) 總結 透過以上的方式就可以做到多驗證服務商的帳號連結動作，而在連結失敗時 Firebase 回傳的錯誤訊息也很清晰明瞭。後續的變化就交給各位發揮了 雖然這篇文章是用 TypeScript 做範例，其它的語言的操作模式也相同，轉換上應該沒有太大的問題才是]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] Notification]]></title>
    <url>%2F2019%2F07%2F01%2Frxjs-notification%2F</url>
    <content type="text"><![CDATA[RxJS 內除了 Observable 之外，還有另外一種物件型別，稱做 Notification，什麼是 Notification 而他可以做到那些事情，就讓這篇文章來探討一下 基本介紹 Notification 是一個物件可以用來描述 Observable 所送出的事件資訊，例如這次送出的資料狀態是什麼? 是否有資料? 資料又是什麼? 我們可以透過這些資訊來做一些額外的判斷處理。 我們沒有辦法直接取得 Notification 類型的資料，需要搭配兩個 operator 來完成、materialize 與 dematerialize materialize 是將 Observable 送出的事件資料轉換成 Notification 物件 dematerialize 是將 Notification 轉換為 Observable 的事件資料 當然我們也可以直接建立 Notification 物件 範例 123of(1, 2, 'a', 'b') .pipe(materialize()) .subscribe(value =&gt; console.log(value)); 輸出結果 可以很容易的看到，透過 materialize 的方法，可以讓在 Observable 間流動的資料用物件的方式呈現相關的資訊，來做一點變化 123456of(1, 2, 'a', 'b') .pipe( materialize(), map(x =&gt; (x.kind === 'C' ? x : new Notification(x.kind, x.value + '!'))) ) .subscribe(value =&gt; console.log(value)); line 4: 透過 map 的方法，來加入一些判斷變化條件 輸出結果 最後到 subscribe 的步驟，維持 Notification 的格式是還蠻奇怪的，所以可以使用 dematerialize 做轉換 1234567of(1, 2, 'a', 'b') .pipe( materialize(), map(x =&gt; (x.kind === 'C' ? x : new Notification(x.kind, x.value + '!'))), dematerialize() ) .subscribe(value =&gt; console.log(value)); 輸出結果 Notification 透過上述的範例，我們能知道一個 Notification 至少包含了幾個資訊 kind: 目前資料的狀態: N (Next), E (Error), C (Complete) value: 值/資料 hasValue: 是否有包含資料 error: 錯誤訊息 也可以直接使用 new Notification() 的方式建立 延伸變化 知道 Notification 之後，到底能用在哪裡呢? 例如想不寫 complete function 但又想要在完成時做動作時，這時候就可以利用 Notification 的 kind 來處理 1234567891011range(0, 5) .pipe( materialize(), tap(notifcation =&gt; &#123; if (notifcation.kind === NotificationKind.COMPLETE) &#123; console.log('let do something when complete'); &#125; &#125;), dematerialize() ) .subscribe(value =&gt; console.log(value)); 執行結果 雖然上述的功能，可以利用 finally 來完成，但多知道一種變化型，不是很好嗎? 在深處思考一下以下的情形，是否能用 Notification 寫出 tap 的效果， tap 本身就接受 3 種狀態的 callback ( tap&lt;T&gt;(nextOrObserver?: PartialObserver&lt;T&gt; | ((x: T) =&gt; vlid), error?: (e:any) =&gt; void, complete?: () =&gt; void))，下面程式碼也可以做到一樣的事情 123456materialize(),map(noti =&gt; &#123; noti.accept(v =&gt; console.log('extra callback fn', v)); return noti; &#125;),dematerialize() Notification 的 accept(nextOrObserver: PartialObserver | ((value: T) =&gt; void), error?: (err: any) =&gt; void, complete?: () =&gt; void)]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Web worker]]></title>
    <url>%2F2019%2F06%2F07%2Fangular-web-worker%2F</url>
    <content type="text"><![CDATA[Angular CLI 8 提供建立 web worker 的指令，這一個指令能幫助我們建立相關的檔案及修正相關要調整的設定，剩下的就是功能實作及在何處使用 web worker 了。 Web worker 是什麼? 我們都知道 JavaScript 基本上是一個單執行緒的語言，web worker 可以讓我們多開一條執行緒，這樣子的好處就是可以將高計算的工作放到 worker 內運算，善用現代電腦的強大硬體。 概述 Web Worker 一旦被建立起來後，就會一直運行，所以在使用上要留意關閉的時機點，避免資源浪費，Web Worker 可以讓我們多開戰場，但還是有其使用上的限制，有以下幾點需要留意的 必須來至相同的網址: web worker 的程式不能跨網域的讀取 DOM操作限制: 不能使用: doucment、window、parent 物件 可以使用: navigator 、location 溝通: Worker 與 Main Thread 不能直接溝通，必須透過 Message 來溝通 腳本限制: 不能使用 alert() 和 confirm() 但可以使用 XMLHttpRequest 檔案限制: 不能讀取本機檔案 (file://)，但可以讀取網路上的 基本用法 Main Thread 建立 1const worker = new Worker('worker.js') 傳遞訊息 1worker.postMessage(data); postMessage 就是 Main Thread 與 Worker 間傳遞訊息的方法 接受訊息 123worker.onmessage = (event)=&gt; &#123; // code here&#125; 關閉 1worker.terminate(); Worker 例外狀況處理 123worker.onerror = (error)=&gt;&#123; // handle exception here&#125; Worker 接受訊息 123addEventListener('message', (&#123; data &#125;) =&gt; &#123; // code here&#125;); 傳送訊息 1postMessage(data); 透過 postMessage 的方法可以從 worker 傳送訊息到 Main Thread 引用 Library 在 worker 內一樣可以使用 JavaScript Library, 引用方式如下 123importScripts('script.js');importScripts('script1.js', 'script2.js'); 錯誤處理 123addEventListener('error', function (event) &#123; // handle exception here&#125;); 關閉 Worker 也可以自我關閉 1close(); Angular 用法 建立 worker 檔案 透過 Angular CLI 可以快速的建立及設定相關的環境，指令是 1ng g webWorker &lt;worker-name&gt; 該指令會做以下的幾件事情 新增 &lt;worker-name&gt;.worker.ts 檔案 新增 tsconfig.worker.json 檔案 更新 tsconfig.app.json 檔案，排除 worker.ts 檔案 更新 angular.json 檔案，新增讀取 worker 相關的設定 使用 Web Worker 在 Angular 內不論是 component 或是 service 都可以使用，基本使用方式為 12345678910111213141516if (typeof Worker !== 'undefined') &#123; const worker = new Worker('./my-worker.worker', &#123; type: 'module' &#125;); // 監聽訊息 // 不使用 rxjs worker.onmessage = (&#123; data &#125;) =&gt; &#123; console.log('got message back:', data); &#125;; // 使用 rxjs fromEvent&lt;any&gt;(worker, 'message').subscribe((&#123; data &#125;) =&gt; &#123; console.log('rxjs version:', data); &#125;); worker.postMessage('Hello'); &#125; line 2: 建立 worker，第二個參數可以設定以下的項目 (Optional) type: 指定建立的類型， 預設為 classic ，可設定的選項是 classic 和 module 設定為 module 類型時 ，可以使用 import {} from xxx 語法 credentials: 指定 credentials 類型，可設定的選項有 omit 、same-origin、include，如果 type 的設定為 classic 時，此設定為 omit (不需要 credentials) name: 設定 workder 名稱，通常使用於 Debugging 時期 (IE、Safari 不支援) line 5~12: 兩種監聽 Worker 傳回訊息的方式 基本寫法 使用 rxjs 的方式 line 15: 送訊息到 worker 應用範例 假設我想要做一個定期撈資料的功能，這一個功能雖然可以在 service 內寫 timer 定期去完成。如果想要放到 web worker 內，又該如何完成了，又不能再 web worker 內使用 httpClient 的物件。 這裡有幾個選擇，既然可以使用 import 的方式載入第三方的套件，這裡就用 rxjs 內的 ajax 物件來做示範 my.worker.ts 12345678910111213141516171819202122232425/// &lt;reference lib="webworker" /&gt;import &#123; takeUntil, concatMap &#125; from 'rxjs/operators';import &#123; timer, Subject &#125; from 'rxjs';import &#123; ajax &#125; from 'rxjs/ajax';const destory$ = new Subject();const queryGithub = () =&gt; ajax.getJSON('https://api.github.com/users?per_page=5');const longPolling = () =&gt; timer(1000, 1000).pipe( concatMap(() =&gt; queryGithub()), takeUntil(destory$) );addEventListener('message', (&#123; data &#125;) =&gt; &#123; switch (data) &#123; case 'start': longPolling().subscribe(value =&gt; postMessage(value)); break; case 'stop': destory$.next(); break; &#125;&#125;); app-component.ts 12345678910111213141516171819202122232425262728293031323334353637import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;button (click)="start()"&gt;start&lt;/button&gt; &lt;button (click)="stop()"&gt;stop&lt;/button&gt; `&#125;)export class AppComponent implements OnInit &#123; title = 'ngWorker'; private worker: Worker; ngOnInit() &#123; if (typeof Worker !== 'undefined') &#123; this.worker = new Worker('./my.worker', &#123; type: 'module' &#125;); // 監聽訊息 this.worker.onmessage = (&#123; data &#125;) =&gt; &#123; console.log('Data:', data); &#125;; &#125; &#125; start() &#123; if (!this.worker) &#123; return; &#125; this.worker.postMessage('start'); &#125; stop() &#123; if (!this.worker) &#123; return; &#125; this.worker.postMessage('stop'); &#125;&#125; Web Worker 與 Service Worker 的差異 以下兩張圖快速解釋 Web Worker 與 Service Worker 各自負責的事情 Web Worker Service Worker]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Static Query 是什麼?]]></title>
    <url>%2F2019%2F05%2F29%2Fangular-static-viewchild%2F</url>
    <content type="text"><![CDATA[Angular 8 在五月底正式釋出，而這次的釋出裡面有一個更新屬於新設定，觀念上是有需要調整的，所以寫了這篇文章釐清一下 所謂的 Query 上的改變，是針對 ViewChild / ContentChild 這一類的 decorator 做額外的設定，以前我們的程式碼會這樣子寫 1@ViewChild('foo') foo: ElementRef 這樣子寫在取得內容的時間點，有時候會是在 Oninit 有時候需要在 ngAfterViewInit 時才可以取得。稍微分析一下為什麼會有這樣子的時間點上的差異性 當所要查詢的 Element 上沒有任何 *ngIf 或是 *ngFor 的 directive 時，該 element 一開始就已經存在，不需要再經過 Angular 做額外的判斷 (頁面處理)，這時候就可以在 OnInit 這階段取得該 Element 的相關資訊 當有使用到 *ngIf 或是 *ngFor 時，就會出現另外一種狀態 以上就是同一種寫法卻有可能在兩種地方取得物件，這一個問題 Angular 團隊想要透過手動設定的方式來告訴底層的 compiler 在何時取得物件 在 Version 8 (過度時期) 當在寫 @ViewChild 或是 @ContentChild 時，就必須明確的標示第二個參數 { static: true | false}，這參數的設定意義分別為 當設定為 true 時，只會在 ngOnInit 的地方取得 Element 物件 當設定為 { static: true } 時，在加上 ngIf 的條件，在 ngAfterViewInit 的地方依舊取不到該 Element 物件，原因是 Angular Compiler 認定該 Element 為 static ，所以只會在 OnInit 的地方取一次，之後就不會被執行 所以當遇到這種情形，就必須將 static 設定為 false 當設定為 false 時，只會在 ngAfterViewInit 的地方取得 Element 物件 最後 而這一個 API 改變是暫時性的，在 Angular 9 這一個參數的預設值會是 false，之後就又會回到一般的使用方式。在下面的參考文件中的後半段，有一些 QA 的內容，如果對於這樣子的設定有問題的，也可以閱讀那邊的回答 參考資料 Static Query Migration Guide]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Custom Decorators - Day 07]]></title>
    <url>%2F2019%2F05%2F11%2Fnestjs-custom-decorators%2F</url>
    <content type="text"><![CDATA[NestJS 裡大量使用 Decorators 來設定相關的功能，類似 Filter、Pipe、Interceptors、Req、Body 等，當然也可以自訂 Decorators 來做一些我們想要簡化的功能 在 NestJS 內要自訂 Decorators 很單純，NestJS 為我們準備好 createParamDecorator ，可以透過此方法來建立 decorator。這裡有一個官網提供的範例 12345import &#123; createParamDecorator &#125; from '@nestjs/common';export const User = createParamDecorator((data, req) =&gt; &#123; return req.user;&#125;); 當建立完成後，就可以在需要的地方使用 1234@Get()async findOne(@User() user: UserEntity) &#123; console.log(user);&#125; 這樣當執行到這一行時，就可以直接取得 user 的資訊，簡化了很多。這功能在 @Body 也是這樣子完成的。 假設資料結構長這樣 1234567&#123; "id": 101, "firstName": "Alan", "lastName": "Turing", "email": "alan@email.com", "roles": ["admin"]&#125; 可以透過 data 參數，告訴 decorator 更多的資訊，類似這樣子使用 @User('firstName')，在原本 Decorators 的地方也稍微加工一下 12345import &#123; createParamDecorator &#125; from '@nestjs/common';export const User = createParamDecorator((data: string, req) =&gt; &#123; return data ? req.user &amp;&amp; req.user[data] : req.user;&#125;); 修改完成後，就可以指定要回傳的資料欄位了，是不是很簡單 實際使用範例 稍微修改一下上面的 decorator 123456789101112import &#123; createParamDecorator &#125; from '@nestjs/common';import &#123; Request &#125; from 'express';export const User = createParamDecorator((data: string[], req: Request) =&gt; &#123; let user = req.body; if (data) &#123; user = data.reduce((newuser, prop) =&gt; &#123; return &#123; ...newuser, [prop]: user[prop] &#125;; &#125;, &#123;&#125;); &#125; return user;&#125;); 實際使用 12345678910// tslint:disable-next-line:max-classes-per-file@Controller('products')export class ProductsController &#123; @Post() create(@User(['firstName', 'lastName']) body, @Res() response: Response) &#123; return response.status(HttpStatus.CREATED).send(body); &#125;&#125; 執行結果 參考文件 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Interceptors - Day 06]]></title>
    <url>%2F2019%2F05%2F10%2Fnestjs-interceptors%2F</url>
    <content type="text"><![CDATA[Interceptor 是 NestJS 內唯一可以雙向影響的服務，至於有哪些用途，就先來看官網的文件 基本型 Nest CLI 指令 1nest g in &lt;interceptor name&gt; 123456789import &#123; CallHandler, ExecutionContext, Injectable, NestInterceptor &#125; from '@nestjs/common';import &#123; Observable &#125; from 'rxjs';@Injectable()export class LoggingInterceptor implements NestInterceptor &#123; intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123; return next.handle(); &#125;&#125; context: 內包含所接紹的 Request / Response 等資訊 next: 可以串接/改變傳出去的內容，為 Observable 簡單範例 12345678910111213141516import &#123; CallHandler, ExecutionContext, Injectable, NestInterceptor &#125; from '@nestjs/common';import &#123; Observable &#125; from 'rxjs';import &#123; tap &#125; from 'rxjs/operators';@Injectable()export class LoggingInterceptor implements NestInterceptor &#123; intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123; consoole.log('Before') const now = Date.now(); return next .handle() .pipe( tap(() =&gt; console.log(`After... $&#123;Date.now() - now&#125;ms`)), ); &#125;&#125; 註冊方式與之前的 Pipe 、Fitler 等一樣 12345678910@Controller('products')export class ProductsController &#123; @Get() @UseInterceptors(LoggingInterceptor) getAll(@Res() response: Response, @Query() query) &#123; return response.status(HttpStatus.OK).json([1, 2, 3]); &#125; ...&#125; 輸出結果 進階應用 因為 intercetpor 需要回傳 Observable 型別，這表示任何可以跟 Observable 串的 Operators 都可以使用，或可以直接回傳另外一個 Observable 123456789import &#123; CallHandler, ExecutionContext, Injectable, NestInterceptor &#125; from '@nestjs/common';import &#123; of &#125; from 'rxjs';@Injectable()export class LoggingInterceptor implements NestInterceptor &#123; intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123; return of('這跟原本 Controller 回傳的內容不一樣') &#125;&#125; 或是這樣子使用 123456789import &#123; CallHandler, ExecutionContext, Injectable, NestInterceptor &#125; from '@nestjs/common';import &#123; of &#125; from 'rxjs';@Injectable()export class LoggingInterceptor implements NestInterceptor &#123; intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123; return next.handle().pipe(catchError(()=&gt; throwError(new BadGatewayException())), &#125;&#125; 執行順序 從一開始到現在也看了很多不同介於 Client 與 Server 端的服務，但相互的執行順序又是如何，就簡單做一個測試 12345678910111213// tslint:disable-next-line:max-classes-per-file@Controller('products')export class ProductsController &#123; @Get() @UseInterceptors(LoggingInterceptor) @UseFilters(HttpExceptionFilter) @UsePipes(ValidatePipe) @UseGuards(AuthGuard) getAll(@Res() response: Response, @Query() query) &#123; return response.status(HttpStatus.OK).json([1, 2, 3]); // throw new HttpException('Forbidden', HttpStatus.FORBIDDEN); &#125;&#125; middleware 是註冊在 App.module，執行結果 Recap 這邊可以算是 NestJS 基本的運作，但還有更多的內容等著去開發。例如如何連結資料庫等，就繼續探索下去吧 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Guard - Day 05]]></title>
    <url>%2F2019%2F05%2F09%2Fnestjs-guard%2F</url>
    <content type="text"><![CDATA[Angular 有 Router Guard，是用來管制是否能進入 Component 的一道關卡，而在 NestJS 內也有一樣的機制，名字也叫做 Guard Guard 的執行順序，會在每一個 middleware 之後，但在 interceptor 或是 pipe 之前，這順序要稍微記一下 建立 1nest g gu &lt;guard name&gt; 建立出來 Guard 的基本內容 1234567891011import &#123; CanActivate, ExecutionContext, Injectable &#125; from '@nestjs/common';import &#123; Observable &#125; from 'rxjs';@Injectable()export class AuthGuard implements CanActivate &#123; canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123; return true; &#125;&#125; 需要實作 CanActivate 介面 回傳的結果為布林值，也可以是 Promise 或是 Observable 的格式 true: 請求會繼續下去 false: 會拒絕連線請求 註冊方式與其他 filter/pipe 類似 1234567891011121314import &#123; Controller, Get, UseGuards &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';import &#123; AuthGuard &#125; from './auth.guard';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() @UseGuards(AuthGuard) getHello(): string &#123; return this.appService.getHello(); &#125;&#125; 當連線被拒絕時，會收到此訊息 12345&#123; statusCode: 403, error: "Forbidden", message: "Forbidden resource"&#125; ExecutionContext 在 canActivate 的方法，會有一個 context 的變數，其型別為 ExecutionContext 12345canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123; return true; &#125; 而這一個 ExecutionContext 是繼承 ArgumentsHost，而這個型別我們也在 Exception Filter 那邊有看過，相關細節的部分，可以再回去那個章節閱讀 1234export interface ExecutionContext extends ArgumentsHost &#123; getClass&lt;T = any&gt;(): Type&lt;T&gt;; getHandler(): Function;&#125; 範例: Role-based Auth 既然可以透過回傳 ture 或是 false 的方式決定是否能進入後續的請求流程，那再搭配其他的設定，不就能做到 Role-based 的權限控管了 官方文件內使用了 SetMetadata 與 Reflection 的方式來設定每一個 Controller method 的允許角色 123456@Get() @UseGuards(AuthGuard) @SetMetadata('roles', ['admin']) // 設定 metaData getHello(): string &#123; return this.appService.getHello(); &#125; 在 Guard 的地方可以用這種方式取得所設定的 metaData 1234567891011121314import &#123; Reflector &#125; from '@nestjs/core';@Injectable()export class AuthGuard implements CanActivate &#123; constructor(private readonly reflector: Reflector) &#123;&#125; canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123; const roles = this.reflector.get('roles', context.getHandler()); console.log(roles); // 可以取得 ['admin'] 的資料 return true; &#125;&#125; 既然能取得所設定的 metaData，那後續的動作就可以自由發揮了 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Pipe - Day 04]]></title>
    <url>%2F2019%2F05%2F07%2Fnestjs-pipe%2F</url>
    <content type="text"><![CDATA[昨天提到 Exception Filter，今天來談談 Pipe，Pipe 在 NestJS 裡面有兩個比較常見的使用情境， 1. 轉型 2. 驗證。至於怎麼完成呢? 根據官網的圖，Pipe 是落在這一個象限內。 而常見的使用情境有 轉型 (Transformation) 驗證 (Validation) 建立與註冊 CLI 指令 1nest g pi &lt;pipe name&gt; 12345678import &#123; ArgumentMetadata, Injectable, PipeTransform &#125; from '@nestjs/common';@Injectable()export class ValidatePipe implements PipeTransform &#123; transform(value: any, metadata: ArgumentMetadata) &#123; return value; &#125;&#125; 是否有一種熟悉的感覺，就跟 Angular 的 Pipe 語法很類似，沒錯，基本上就是類似的運行方式，而註冊方式與註冊 Exception Filter 雷同 12345678910...@Controller('products')export class ProductsController &#123; @Post() @UsePipes(ValidatePipe) create(@Body('some data') body: ProductModel, @Res() response: Response) &#123; return response.status(HttpStatus.CREATED).send(body); &#125; ...&#125; Pipe 詳解 123transform(value: any, metadata: ArgumentMetadata) &#123; return value; &#125; transform 函式內有兩個參數，一個是value 另一個是 metadata，以下為 metadata 的格式 12345export interface ArgumentMetadata &#123; readonly type: 'body' | 'query' | 'param' | 'custom'; readonly metatype?: Type&lt;any&gt;; readonly data?: string;&#125; 實際取得的資訊如下 重新看一下使用 Pipe 的 Controller 12345@Post()@UsePipes(ValidatePipe)create(@Body('abc') body: ProductModel, @Res() response: Response) &#123; return response.status(HttpStatus.CREATED).send(body);&#125; @Body() : @Body可設定要從 Body 取哪一個值，類似 pluck 的功能，而相關的資訊會顯示在 Pipe 的 metadata.data，但必須為文字，如果不傳，metadata 的 data 會收到 undefined， 參數型別，body: ProductModel ，後面的型別會顯示在 metatype 上, metadata.type 會顯示接受到的資料是來自哪裡 既然可以取道完整的資料，就可以做到轉型或是驗證的功能。轉型比較簡單，我們先來看怎麼做 轉型 其實就將要改變的資料回傳回去就可以了 驗證 既然能轉型，就能做到驗證，因為驗證資料格式的方法有很多種，這裡我們就簡單示範一下 執行結果 結論 官方也有提供一些內建的 Pipe 可以直接使用，例如 ValiationPipe 和 ParseIntPipe ，至於詳細的用法，可以參考官方文件 (連結在此)，真的可以花點時間看一下 ValidationPipe 的部分，可以省去不少資料驗證的工作 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Exception Filters - Day 03]]></title>
    <url>%2F2019%2F05%2F06%2Fnestjs-filters%2F</url>
    <content type="text"><![CDATA[NestJS 有內建例外錯誤處理層，負責處理所以未處理的例外狀態，算是框架層級的錯誤處理機制，這裡 NestJS 使用一個名詞 exception filter，預設的處理型別為 HttpException 執行順序 Middleware 優先於 Exception Filter 例外狀態 如果例外狀態是沒有被處理的話，則會回傳預設訊息 1234&#123; "statusCode": 500, "message": "Internal server error"&#125; 既然我們知道可以手動處理例外狀態的回傳，在呼叫時就可以刻意的回傳正確的例外狀況，例如 1234@Get()async findAll() &#123; throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);&#125; 既然 HttpException 是可以被繼承的，那我們也可以自行建立克制的例外狀態，根據官網的範例 12345export class ForbiddenException extends HttpException &#123; constructor() &#123; super('Forbidden', HttpStatus.FORBIDDEN); &#125;&#125; 更多的例外狀態種類有以下 BadRequestException UnauthorizedException NotFoundException ForbiddenException NotAcceptableException RequestTimeoutException ConflictException GoneException PayloadTooLargeException UnsupportedMediaTypeException UnprocessableEntityException InternalServerErrorException NotImplementedException BadGatewayException ServiceUnavailableException GatewayTimeoutException 例外過濾 知道有各種例外狀態的種類，那就可以來寫過濾器，來攔截特定的例外狀況並回傳自訂的錯誤訊息。 1234567891011121314151617181920212223242526import &#123; ArgumentsHost, Catch, ExceptionFilter, HttpException,&#125; from '@nestjs/common';import &#123; Response, Request &#125; from 'express';// 攔截特定的例外狀態@Catch(HttpException)export class HttpExceptionFilter implements ExceptionFilter &#123; catch(exception: HttpException, host: ArgumentsHost) &#123; const ctx = host.switchToHttp(); // 取得 context 本身 const response = ctx.getResponse&lt;Response&gt;(); // 取得 Response 資訊 const request = ctx.getRequest&lt;Request&gt;(); // 取得 Request 資訊 const status = exception.getStatus(); // 回傳自訂錯誤訊息 response.status(status).json(&#123; statusCode: status, timestamp: new Date().toISOString(), path: request.url, &#125;); &#125;&#125; 套用 Filter 想要套用 Exception Filter 時，可以透過 @UseFilters() 的方式來設定，可以設定在 method 或是 class 層級。如果想套用多個 Filter 時，直接使用 , 做分隔即可 123456789@Controller('products')export class ProductsController &#123; @Get() @UseFilters(HttpExceptionFilter) // 設定 Exception Filter getAll(@Res() response: Response, @Query() query) &#123; throw new HttpException('Forbidden', HttpStatus.FORBIDDEN); &#125;&#125; 要設定成為 Application 層級時，可以這樣子設定 123456async function bootstrap() &#123; const app = await NestFactory.create(ApplicationModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000);&#125;bootstrap(); 應用發想 如果可以攔截到例外狀態，也有一個地方可以集中處理，那就可以很簡單的將例外狀態儲存到某一個地方，並且可以依種類回傳不同的錯誤訊息。 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] Middleware - Day 02]]></title>
    <url>%2F2019%2F05%2F05%2Fnestjs-middleware%2F</url>
    <content type="text"><![CDATA[什麼是 Middleware? Middleware 是介於 Client 端與後端路由中間的一層或是多層 Function，而該 Functions 能存取 Request 與 Request 資訊，也可以透過 next() 來控制流程。 NestJS 裡的 Middleware 基本概念與 express 的 Middleware 相同，所以相關的資訊也可以參考 express middleware。而以下的幾件事情是可以透過 Middleware 完成的 執行任何程式碼 改變 Request / Response 物件內容 結束 Request /Response 生命週期 執行下一個 Middleware ，表示可以串接多個 Middleware 建立 可以透過 CLI 的指令建立 Middleware 1nest g mi &lt;middleware-name&gt; 當建立完成後，以下為基本的 middleware 程式碼架構 12345678import &#123; Injectable, NestMiddleware &#125; from '@nestjs/common';@Injectable()export class CheckMiddleware implements NestMiddleware &#123; use(req: any, res: any, next: () =&gt; void) &#123; next(); &#125;&#125; 設定 當建立完一個 middleware 後，當然需要告訴 NestJS 說，這一個 Middleware 需要套用在那些路由規則上，這裡就先設定在最上層的 AppModule 內 實作 NestModule 介面 建立 configure 方法 123456789101112import &#123; Module, NestModule, MiddlewareConsumer &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';import &#123; ProductsController &#125; from './products/products.controller';@Module(&#123; imports: [], controllers: [ProductsController], providers: [AppService],&#125;)export class AppModule implements NestModule &#123; configure(consumer: MiddlewareConsumer) &#123;&#125;&#125; 利用 consumer 來設定 middleware 適用的路由範圍 12345export class AppModule implements NestModule &#123; configure(consumer: MiddlewareConsumer) &#123; consumer.apply(CheckMiddleware).forRoutes(ProductsController); &#125;&#125; apply 可以放多個 middleware，且會依序執行，但前提是每一個 middleware 都有執行 next() 可以設定排除規則， exclude( { path: 'products', method: RequestMethod.POST })，但根據官網說明，此規則並不適用於 functional middleware，在下面會介紹什麼是 functional middleware forRoutes 有以下的設定方式 直接放 Controller Class 指定路由 forRoutes('products') 指定路由與請求方式 forRoutes({path: 'products', method: RequestMethod.GET }) 也支援 Route wildcards 的方式，forRoutes({ path: 'ab*cd', method: RequestMethod.ALL }); 如果要設定成全域使用的 middleware 時，可以在 main.ts 內設定 123const app = await NestFactory.create(AppModule);app.use(CheckMiddleware);await app.listen(3000); Middleware 進一步說明 那到底 Middleware 可以做到怎樣的事情呢? 這裡有一個簡單的範例 攔截所有的 Request ，不給進 ProductController middleware 的設定如上，直接套用 ProductController 123456789import &#123; Injectable, NestMiddleware, HttpStatus &#125; from '@nestjs/common';import &#123; Request, Response &#125; from 'express';@Injectable()export class CheckMiddleware implements NestMiddleware &#123; use(req: Request, res: Response, next: () =&gt; void) &#123; res.status(HttpStatus.OK).send('哈，你被攔截了'); &#125;&#125; 接下來用 Postman 來打 /products ，看結果是什麼 當然可以加上一些條件，例如 Request 的內容中，如果 queryParams 的 name 是 Kevin 時，就會直接回傳，不然就進入 ProductController 內處理 12345678910111213import &#123; Injectable, NestMiddleware, HttpStatus &#125; from '@nestjs/common';import &#123; Request, Response &#125; from 'express';@Injectable()export class CheckMiddleware implements NestMiddleware &#123; use(req: Request, res: Response, next: () =&gt; void) &#123; if (req.query.name === 'Kevin') &#123; res.status(HttpStatus.OK).send('哈，你被攔截了'); &#125;else&#123; next(); &#125; &#125;&#125; Functional Middleware 如果 Middleware 不需要任何使用到其他的服務，就沒有寫成 Class 的必要性，可以單純的使用 Function 來完成 1234export function logger(req, res, next) &#123; console.log(`Request...`); next();&#125;; 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NestJS] 進入 NestJS 的世界 - Day 01]]></title>
    <url>%2F2019%2F05%2F04%2Fnestjs-getting-start%2F</url>
    <content type="text"><![CDATA[NestJS 問世已經有好一段時間了，一直到現在才時間開始研究 NestJS 這一個以 Angular 風格著稱的後端 Node.js 框架，支援 JavaScript 和 TypeScript 語言且擁有 OOP、FP、FRP 的特性，還有其他強大的功能，更多的資訊可以在 NestJS 的文件裡找到。 工具/環境 NestJS 有提供 CLI 工具，可以讓我們透過指令的方式建立專案及其他的元件，就跟 Angular CLI 一樣，可以透過 npm/yarn 安裝成全域工具 1npm i -g @nestjs/cli 當安裝完成後，就可以使用 nest CLI 提供的指令建立 nest 專案了 1nest new &lt;project-name&gt; 這行指令可以建立一個完整的 nest 專案，包含測試的環境等，最基礎的專案結構分為 src 與 test 兩個資料夾，分別放要執行的程式碼與測試碼，其他的就是一些執行要用的設定檔 至於要怎麼將專案執行起來，在 package.json 內提供了一些 script 可以執行 12345678910111213141516171819&#123; ... "scripts": &#123; "build": "tsc -p tsconfig.build.json", "format": "prettier --write \"src/**/*.ts\"", "start": "ts-node -r tsconfig-paths/register src/main.ts", "start:dev": "nodemon", "start:debug": "nodemon --config nodemon-debug.json", "prestart:prod": "rimraf dist &amp;&amp; npm run build", "start:prod": "node dist/main.js", "lint": "tslint -p tsconfig.json -c tslint.json", "test": "jest", "test:watch": "jest --watch", "test:cov": "jest --coverage", "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand", "test:e2e": "jest --config ./test/jest-e2e.json" &#125;, ...&#125; 在命令視窗內執行 npm start 即可以將執行環境給跑起來，預設網站的連接埠為 3000，打開瀏覽器並輸入 http://localhost:3000 即可看到以下的畫面 基本架構 Main main.ts : 進入點。決定要啟動哪一個 Module 跟要使用哪一個連接埠，預設為 3000 有兩種平台可以選擇，express (default) 與 fastify，要設定使用哪一種平台也十分容易，只要在 create 時指定平台就可以了 123import &#123; NestExpressApplication&#125; from '@nestjs/platform-express';...const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule); fastify 版本 npm i @nestjs/platform-fastify 123456789101112131415import &#123; NestFactory &#125; from '@nestjs/core';import &#123; FastifyAdapter, NestFastifyApplication,&#125; from '@nestjs/platform-fastify';import &#123; AppModule &#125; from './app.module';async function bootstrap() &#123; const app = await NestFactory.create&lt;NestFastifyApplication&gt;( AppModule, new FastifyAdapter(), ); await app.listen(3000);&#125;bootstrap(); 如果是跑在 docker 的環境，app.listen 需要多設定 IP 1await app.listen(3000, '0.0.0.0'); Module app.module.ts : Root Module，內含 modules、controllers 與 providers 等設定 相關的觀念與 Angular 的 NgModule 相同 Global Module：如果有一個 Module 需要重複 import 到其他 Module 時，這時候使用 @Gloabl() 的方式標示，就可以讓該 module 成為 Gloabl 等級的模組，但只能被註冊一次。(文件說明) Controller app.controller.ts : 擁有基本路由設定的控制器 CLI 建立指令: nest g controller &lt;controller name&gt; 路由設定 可透過 @Controller(route) 的方式來設定最上層的路由，例如 @Controller('products') ，當瀏覽到 http://localhost:3000/products 就會進入到這個 Controller ，然後再去找相對應的請求方式及路由設定 順序性很重要，讀取順序是由上而下，假設有程式碼的順序如下 123456789101112@Controller('products')export class CatsController &#123; @Get(':id') findOne(@Param('id') id: string) &#123; return `This action returns a #$&#123;id&#125; product`; &#125; @Get() getAll() &#123; // 因為 @Get(':id') 已經攔截了，所以這裡永遠不會執行到 &#125;&#125; 請求方式 網頁請求的方式有很多種，使用 decorator 的方式來標示 function ，其設定方式直覺 12345678910import &#123; Controller, Get, Req &#125; from '@nestjs/common';import &#123; Request &#125; from 'express';@Controller('products')export class ProductsController &#123; @Get() getAll(@Req() request: Request) &#123; return [1, 2, 3]; &#125;&#125; 請求時的相關資訊，可以透過 @Req() 來取得 12345678910import &#123; Controller, Get, Req &#125; from '@nestjs/common';import &#123; Request &#125; from 'express';@Controller('products')export class ProductsController &#123; @Get() getAll(@Req() request: Request) &#123; return [1, 2, 3]; &#125;&#125; 更多的資訊可以參考這裡的表格 非同步 支援 async / await 1234@Get()async findAll(): Promise&lt;any[]&gt; &#123; return [];&#125; 更支援 RxJS Observable 1234@Get()findAll(): Observable&lt;any[]&gt; &#123; return of([]);&#125; Request payload 如果是來自 C# ASP.NET MVC 的朋友，一定很習慣當 POST/PUT 這一類的請求，所傳進來的 payload 會配上一個資料模組 (Data model)，用來描述所取得的資料結構，而 nestjs 也提供一樣的功能 12345678910export class CreateCatDto &#123; readonly name: string; readonly age: number; readonly breed: string;&#125;@Post()async create(@Body() createCatDto: CreateCatDto) &#123; return 'This action adds a new cat';&#125; Provider 地位等同於 Angular Service，所有的邏輯跟相關操作都可以放在 provider 層，再透過 DI 的方式讓 Controller 或是其他的 service 使用 123456789101112@Injectable()export class CatsService &#123; private readonly cats: Cat[] = []; create(cat: Cat) &#123; this.cats.push(cat); &#125; findAll(): Cat[] &#123; return this.cats; &#125;&#125; 總結 到這裡只是介紹很基本很基本的 NestJS 的內容，還有更多更進階的設定需要被探索，那只能留在之後探勘了。 參考資料 NestJS Doc]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>NestJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Push Notification with SwPush]]></title>
    <url>%2F2019%2F04%2F20%2Fng-push-notification%2F</url>
    <content type="text"><![CDATA[自從 Angular 內建 Service Worker package 與 @angular/pwa 後，寫 PWA 就變得簡單很多了，但是在 Push Notification 的地方，一直找不到好的教學文章講如何與 Firebase Cloud Message 整合在一起，大多數找到的文章都是直接使用 firebase.js 所提供的方法做操作，這樣子就浪費了內建的 SwPush 的功能了，而這篇文章就是講如何將兩者整合再一起 基本環境套件安裝 首先，先建立一個新的專案並將 PWA 的功能設定起來 ng new ngpwa 進入 ngpwa 專案資料夾後，執行 ng add @angular/pwa，將 PWA 加入到 Angular 專案內 安裝 firebase，npm install firebase 完成上述 3 個步驟，就已將完成安裝所需的套件了，接下來要開始設定 push notification 的部分，但這之前，我們要先將自動更新 service worker 的功能加上去，在 app.module.ts 的地方加上這幾行程式碼 1234567export class AppModule &#123; constructor(swUpdate: SwUpdate) &#123; swUpdate.available.subscribe(() =&gt; &#123; window.location.reload(); &#125;); &#125;&#125; 以上的程式碼，可以 service worker (以下簡稱 SW) 自動檢查是否有新版本的程式，如果有就更新 cache 在 SW 內的程式，相關的介紹可以參考這篇 [Angular] Service Worker Update 設定推播訊息所需的參數 在 manifest.json 內，要加上一行參數，這是固定的，直接複製貼上到自己的 manifest.json 內即可 1"gcm_sender_id": "103953800507" 從 firebase 專案的地方，可以取得 messagingSenderId，相關位置請參考下圖，將該 id 記錄在 environement 變數檔內 到這邊，我們已經取得所需的設定參數了 設定 push notification Angular 內建的 SwPush 有實作與 Push Notifications 相關的方法，包含註冊訂閱，監聽訊息，處理訊息動作後續的行為等，在本次文章，會先著重於如何將 SwPush 與 Cloud Messaging 整合在一起。 在網路上面可以搜尋到的文章，都是講利用 firebase.messaging 的功能來監聽推播訊息，但這樣子就不能使用 SwPush 與必須要自己另外寫一個處理推播訊息的 SW，所以接下的程式碼，就是讓 firebase.messaging 的後續動作，交給 SwPush 來處理，先看程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Component, OnInit &#125; from '@angular/core';import &#123; SwPush &#125; from '@angular/service-worker';import * as firebase from 'firebase/app';import 'firebase/messaging';import &#123; environment &#125; from 'src/environments/environment';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit &#123; constructor(private swPush: SwPush) &#123;&#125; ngOnInit() &#123; firebase.initializeApp(&#123; messagingSenderId: environment.firebase.messagingSenderId &#125;); const messaging = firebase.messaging(); navigator.serviceWorker.ready.then(registration =&gt; &#123; if ( !!registration &amp;&amp; registration.active &amp;&amp; registration.active.state &amp;&amp; registration.active.state === 'activated' ) &#123; messaging.useServiceWorker(registration); messaging .requestPermission() .then(() =&gt; messaging.getToken()) .then(token =&gt; console.log('Permission granted!', token)); &#125; else &#123; console.warn( 'No active service worker found, not able to get firebase messaging' ); &#125; &#125;); this.swPush.messages.subscribe(msg =&gt; &#123; console.log(msg); &#125;); &#125;&#125; line 3, 4: import firebase/app 與 messaging 相關功能 line 13: 注入 SwPush 服務 line 15: 由於 SW 註冊的順序性，必須在 ngOnInit 的地方撰寫註冊 messaging 的功能。 line 16 ~ 17: 初始化 firebase 物件 line 19: 建立 firebase.messaging 服務 line 20: 判斷監聽瀏覽器 SW 是否已經準備完成，相關說明請參閱 MDN line 21~ 26: 判斷 SW 是否已經準備好可以使用 line 27: 告訴 firebase.messaging 服務，之後的訊息請交由此 SW 處理 line 28 ~ 31: 請求權限並取得 token，這 token 要存起來，後端要發訊息到前端時，需要這個 token，這個 token 在每一次 SW 註冊時都會改變 line 39~41: 利用 SwPush 監聽推播訊息 以上的幾行程式碼，就是將 firebase.messaging 的功能，改用 SwPush 來處理，因為 Angular PWA 只有在 production 模式下才會啟動，要測試是否成功，必須使用 --prod 來切換成 production 模式，所以建議使用 ng build --prod 後，再利用 lite-server 的方式將網站開啟，當網頁開啟後，第一次會被詢問是否允許開啟通知功能，點選允許，後續才可以接受到通知訊息 接下來再打開 F12 開發者工具並切換到 console 下，應可以看到 Permission granted! xxxxxxxxxxxxx 的訊息，而後面的那一串就是本次 SW 註冊後跟 FCM 取得 client token (先記起來，下面測試時用的到) 至於要怎麼測試有設定成功，以下提供一個簡單的測試方式 利用 Postman 來做 Push Notification 的測試 打開 Postman，並建立一個新的 Post 請求 網址輸入: https://fcm.googleapis.com/fcm/send Header 的地方需要新增兩項 &quot;Content-Type&quot; : &quot;application/json&quot; `「Authorization」 : 「key=&lt;伺服器金鑰&gt;」，伺服器金鑰取得的位置 Body 的內容 1234567891011121314&#123; "to" : "YOUR_FCM_TOKEN_WILL_BE_HERE", // 剛剛在 SW 註冊時，取得的 Client Token "collapse_key" : "type_a", "notification" : &#123; "body" : "Body of Your Notification", "title": "Title of Your Notification" &#125;, "data" : &#123; "body" : "Body of Your Notification in Data", "title": "Title of Your Notification in Title", "key_1" : "Value for key_1", "key_2" : "Value for key_2" &#125;&#125; 按下送出，如果有正常的送出，不論寄送成功失敗，在 postman 都會看到這個 response 的訊息 1234567891011&#123; "multicast_id": 6098520606839994749, "success": 1, "failure": 0, "canonical_ids": 0, "results": [ &#123; "message_id": "0:1555764770224963%e609af1cf9fd7ecd" &#125; ]&#125; 瀏覽器開發者工具的 Console 裡會看到，作業系統也會收到通知訊息 以上就是利用 postman 進行 Push Notifications 測試的方法 總結 網頁的 Push Notifications 可以做到很多事情，這留在後面再來研究，但至少利用 @angular/pwa 加上 SwPush 與 Firebase Cloud Messaging 的串接，可以少寫很多程式碼了。在此分享給各位]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VS Code] 自訂 Emmet 範本]]></title>
    <url>%2F2019%2F04%2F15%2Fvscode-custom-emmet%2F</url>
    <content type="text"><![CDATA[今天朋友問到，要如何修改 VS Code 內 Emmet 的預設範本。一開始想說是沒有辦法修改預設的，應該也沒有辦法覆蓋吧，所以稍微在網路上找了一下，果然沒有找到相關的資料，但其實在官方文件內有提到自訂範本的事情，那就來看看怎麼修改吧 首先，先根據這裡的說明，將自訂 snippet.json 檔案所處的資料夾位置，設定到 settings 裡 emmet.extensionsPath 的地方 我這裡先用 html 的部分做說明，CSS 依循一樣的規則，VS Code Emmet 內建所使用的 HTML Snippet 是使用這一份 html.json，假設我們想要修改 ! 所產生出來的預設 html 範本內容，我們只需要重新定義一個 doc 即可 (原始定義如下) 12"doc": "html[lang=$&#123;lang&#125;]&gt;(head&gt;meta[charset=$&#123;charset&#125;]+meta:vp+meta:edge+title&#123;$&#123;1:Document&#125;&#125;)+body", "!|html:5": "!!!+doc", 而自訂 snippet.json 的內容如下 1234567&#123; "html": &#123; "snippets": &#123; "doc": "html[lang=$&#123;lang&#125;]&gt;(head&gt;meta[charset=$&#123;charset&#125;]+meta:vp+meta:edge+title&#123;$&#123;1:Documentttt&#125;&#125;)+body" &#125; &#125;&#125; 我們只需要重新定義 doc 即可達到我們的需求，同樣的，如果想要擴充 Emmet 的功能，直接在此編寫即可 剩下的就看各位的想像力了 參考資料 html.json css.json VS Code - Using custom Emmet snippets]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 使用 Windows 驗證 (Windows Authentication)]]></title>
    <url>%2F2019%2F04%2F11%2Fng-windows-auth%2F</url>
    <content type="text"><![CDATA[Angular 使用 Windows Authentication，聽起來沒什麼，但是加上 CORS 就是不同的故事了 ※ 這篇文章的後端是使用 ASP.NET Core MVC ，但要處理的問題是一樣的，觀念通用 Angular 的 HttpClient 在發送請求時，如果在同一個網址下 (同一個網站)，自然會付上 cookie，但遇到不同站點下時又想要帶 cookie 時，該怎麼處理，這時候就必須將 withCredentials 開啟，這是 XMLHttpRequest 內建屬性，用途為判斷是否該使用類似 cookies, authorization headers 或者 TLS 客戶端認證這一類資格證書來建立一個跨站點訪問控制（cross-site Access-Control）請求。這裡是基本用法，當然如果要全域套用時，就會寫成 Http interceptor 1234this.http.get('https://localhost:44369/api/values', &#123; withCredentials: true &#125;) .subscribe(data =&gt; console.log(data)); Angular 端這樣子就可以算是設定完成了 問題是後端要怎麼設定，會遇到幾個問題 CORS Web 授權設定 簡單情境 當 Angular 的 Http 請求只有單純的設定 withCredentials: true 時，後端的設定就很單純，(這裡就假設已經會新增一個基本的 ASP.NET Core MVC 網站) 開啟 windowsAuthentication 的方法有兩種 直接修改 Properties/launchSettings.json 1234567891011&#123; "iisSettings": &#123; "windowsAuthentication": true, // 設定為 true "anonymousAuthentication": false, "iisExpress": &#123; "applicationUrl": "http://localhost:11235", "sslPort": 44369 &#125; &#125;, ....&#125; 透過 UI 的方式設定 在 API 的 Controller 的地方，加上 [Authorize] 啟動 CORS 在 Startup.cs 檔案新增以下程式碼 123456789101112131415161718public void ConfigureServices(IServiceCollection services)&#123; services.AddCors(o =&gt; o.AddPolicy("CORSPolicy", builder =&gt; &#123; builder.AllowAnyOrigin() .AllowAnyMethod() .AllowAnyHeader() .AllowCredentials() .WithOrigins("http://localhost:4200"); &#125;));&#125;public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; ... app.UseCors("CORSPolicy"); ...&#125; .WithOrigins(&quot;http://localhost:4200&quot;) 這一行很重要，當 CORS + withCredentials: true 時，沒有這一行就會噴出錯誤訊息 在 API 的 Controller 的地方，加上 [EnableCors(&quot;CORSPolicy&quot;)] 相關關於 ASP.NET Core MVC 如何加上 CORS 的文章，網路很多，搜尋一下應該很容易就找到了 當上述的兩的步驟完成後，應可以完成最基本的 Windows 驗證功能 至於之後驗證要做到多細，就與處理登入驗證的做法是一樣的了 稍微複雜情境 在實做的過程中發現了一個問題，當我的 Http 請求寫成這樣時，後端設定就變複雜許多 12345678this.http .get('https://localhost:44369/api/values', &#123; headers: new HttpHeaders(&#123; 'Access-Control-Allow-Origin': '*' &#125;), withCredentials: true &#125;) .subscribe(data =&gt; console.log(data)); 瀏覽器在請求時，因為會先發 Options 的 preflight 請求，但這時發的請求是不會有任何 credentials 的，當然後端會直接擋掉 這時候後端的設定要調整一下，要允許匿名登入，設定方式跟上面開啟 windowsAuthentication 類似，只要將 anonymousAuthentication 設定為真，或是將 啟動匿名驗證 打勾 當這樣子設定完後，重新啟動後端服務，當打開 https://localhost:44369/api/values 網址時會出現以下的錯誤畫面 只好再來調整一下 Startup.cs 的程式了 1234567public void ConfigureServices(IServiceCollection services)&#123; // 新增這行 services.AddAuthentication(IISDefaults.AuthenticationScheme); services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);&#125; 當修改完成後，重新整理一次網頁，之前的錯誤訊息就會消失了，打開 Networking 的地方，就會看到兩次對後端的請求都是正常的 參考資料 設定 Windows 驗證 XMLHttpRequest.withCredentials]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] gRPC with Visual Studio 2019 and .NET Core 3]]></title>
    <url>%2F2019%2F04%2F08%2Fgrpc-chat-server%2F</url>
    <content type="text"><![CDATA[微軟在去年年底發出一篇關於 .NET Core 3.0 會包含哪些新功能 (文章由此去)，而其中提到了 gRPC 專案將會成為 first-class support for .NET developers. A common question from customers is how to have an RPC (as in .NET Remoting and Windows Communication Foundation) experience on .NET Core. We are contributing to the gRPC (grpc.io) project to ensure gRPC will have first-class support for .NET developers. 而在 2019 年 .NET Core 3.0 preview 及 Visual Studio 2019 的釋出 (註: 必須使用 Visual Studio 2019 開發)，就將 gRPC Service 的專案範本內建了，真的從零到一個可以運行的 gRPC service 只需要幾個步驟就完成了，與早期那個什麼都需要自己刻的時代，整個幸福太多了。 gRPC 簡介 但開始介紹如何開發 gRPC 前，要先稍微了解 gRPC 是什麼? gRPC是一個高性能、通用的開源RPC框架，其由Google主要面向移動應用開發並基於HTTP/2協議標準而設計，基於ProtoBuf (Protocol Buffers)序列化協議開發，且支持眾多開發語言。 更多的細節，可以在 grpc.io 的網站上找到，建議可以好好的閱讀過後，在進行開發會比較順利 開發 環境準備 .NET Core 3.0 ：要安裝 preview 3 的版本，支援程度會比較高，下載網頁 Visual Studio 2019: 下載網址，可以下載 Community 版本的 (免費) 因為 Visual Studio 2019 正式版預設是不支援使用 .NET Core SDK Preview 版本，所以要手動開啟 確定後，關閉重啟 Visual Studio 即可使用 .NET Core SDK 預覽版本 建立新專案 開啟 VS 2019 建立新專案 選擇 【ASP.NET Core Web 應用程式】，下一步 設定專案名稱及專案儲存位置後，點選【建立】 選擇 【ASP.NET Core 3.0】，方可看到 gRPC Service 專案範本 選擇 【gRPC Service】專案範本後，點選【建立】 等待建立專案 完成專案建立後，會看到這兩個專案被建立在同一個方案下 這時候已經完成建立一個可以被執行的 gRPC 專案了，包含 Server 與 Client 端的程式碼 專案檔案解說 專案檔 (xxx.csproj)：在 VS2019 已經不需要將專案先卸載後才能看 csproj 檔案，可以直接開啟看，十分方便 經保哥提醒，在 VS2017 就有這個功能了，看我多久沒寫後端了 12345678910111213141516171819202122&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt; // 定義 proto 檔案的讀取位置 // 在 Client 端也有此設定，所以 server 與 client 是共用同一份 proto 檔案 &lt;ItemGroup&gt; &lt;Protobuf Include="..\Protos\*.proto" GrpcServices="Server" /&gt; &lt;Content Include="@(Protobuf)" LinkBase="" /&gt; &lt;/ItemGroup&gt; // gRPC 相關的套件 &lt;ItemGroup&gt; &lt;PackageReference Include="Grpc.AspNetCore.Server" Version="0.1.19-pre1" /&gt; &lt;PackageReference Include="Google.Protobuf" Version="3.6.1" /&gt; &lt;PackageReference Include="Grpc.Tools" Version="1.19.0-pre1" PrivateAssets="All" /&gt; &lt;/ItemGroup&gt;&lt;/Project&gt; Startup.cs 123456789101112131415public void ConfigureServices(IServiceCollection services)&#123; // 加入 gRPC 服務 services.AddGrpc();&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; ... // 設定 gPRC 實做 proto 的 service app.UseRouting(routes =&gt; &#123; routes.MapGrpcService&lt;GreeterService&gt;(); &#125;);&#125; greet.proto：gRPC 通訊的合約規範檔，當每次重建專案時，Visual Studio 會依據此檔案將相關的程式碼產生出來 (Code Gen) 123456789101112131415161718192021syntax = &quot;proto3&quot;;package Greet;// 定義 Greeter service 內有哪些方法可以使用// 可依 gRPC 的各種溝通模式定義之service Greeter &#123; // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;// 定義 Response 與 Request 的資料型別及結構// The request message containing the user&apos;s name.message HelloRequest &#123; string name = 1;&#125;// The response message containing the greetings.message HelloReply &#123; string message = 1;&#125; Services/GreeterService.cs ： 實做部分 123456789101112131415161718192021using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using Greet;using Grpc.Core;namespace gRPCDemo&#123; // 繼承 Greeter.GreeterBase (根據 proto 檔案所產生的檔案) public class GreeterService : Greeter.GreeterBase &#123; public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context) &#123; return Task.FromResult(new HelloReply &#123; Message = "Hello " + request.Name &#125;); &#125; &#125;&#125; Client 端的使用方式 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Threading.Tasks;using Greet;using Grpc.Core;namespace gRPCDemo&#123; public class Program &#123; static async Task Main(string[] args) &#123; // Include port of the gRPC server as an application argument var port = args.Length &gt; 0 ? args[0] : "50051"; // 預設連接 port // 建立連接頻道 var channel = new Channel("localhost:" + port, ChannelCredentials.Insecure); // 建立 client 實體 var client = new Greeter.GreeterClient(channel); // 呼叫使用 client 的方法 // service Greeter &#123; // rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125; // &#125; var reply = await client.SayHelloAsync(new HelloRequest &#123; Name = "GreeterClient" &#125;); Console.WriteLine("Greeting: " + reply.Message); // 關閉連線 await channel.ShutdownAsync(); Console.WriteLine("Press any key to exit..."); Console.ReadKey(); &#125; &#125;&#125; 實做 Chat Server 既然已經知道基本 gRPC Server 與 Client 端的檔案結構，那就來弄一個簡單的通訊軟體 修改 greet.proto 檔名至 chat.proto 修改 chat.proto 內容 123456789101112syntax = &quot;proto3&quot;;package Chat;service ChatRoom &#123; rpc join (stream Message) returns (stream Message) &#123;&#125; &#125;message Message &#123; string user = 1; string text = 2;&#125; 在 Services 資料夾下，新增 ChatService.cs 檔案 1234567891011121314151617181920using System.Collections.Generic;using System.Threading.Tasks;using Chat;using Grpc.Core;namespace chatwithgrpc&#123; public class ChatService: ChatRoom.ChatRoomBase &#123; public override async Task join(IAsyncStreamReader&lt;Message&gt; requestStream, IServerStreamWriter&lt;Message&gt; responseStream, ServerCallContext context) &#123; if (!await requestStream.MoveNext()) return; do &#123; // TODO: handle request chat message &#125; while (await requestStream.MoveNext()); &#125; &#125;&#125; 因為要記錄連上 gRPC 服務的連線 (就是 IServerStreamWriter&lt;Message&gt; responseStream 的部分)，所以需要另外建立一個 service 並註冊成 Singleton 模式，這裡就先建立一個服務叫做 ChatRoom.cs 123456// Startup.cs 檔案，註冊 ChatRoom 服務public void ConfigureServices(IServiceCollection services)&#123; services.AddGrpc(); services.AddSingleton&lt;Server.ChatRoom&gt;(); // add this line&#125; ChatRoom.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using Chat;using Grpc.Core;using System;using System.Collections.Generic;using System.Collections.Concurrent;using System.Linq;using System.Threading.Tasks;namespace chatwithgrpc.Server&#123; public class ChatRoom &#123; private ConcurrentDictionary&lt;string, IServerStreamWriter&lt;Message&gt;&gt; users = new ConcurrentDictionary&lt;string, IServerStreamWriter&lt;Message&gt;&gt;(); public void join(string name, IServerStreamWriter&lt;Message&gt; response) =&gt; users.TryAdd(name, response); public void Remove(string name) =&gt; users.TryRemove(name, out var s); public async Task BroadcastMessageAsync(Message message) =&gt; await BroadcastMessages(message); // 將某 Client 的請求內容，傳送到其他 Client 端去 private async Task BroadcastMessages(Message message) &#123; foreach (var user in users.Where(x =&gt; x.Key != message.User)) &#123; var item = await SendMessageToSubscriber(user, message); if (item != null) &#123; Remove(item?.Key); &#125;; &#125; &#125; private async Task&lt;Nullable&lt;KeyValuePair&lt;string, IServerStreamWriter&lt;Message&gt;&gt;&gt;&gt; SendMessageToSubscriber(KeyValuePair&lt;string, IServerStreamWriter&lt;Message&gt;&gt; user, Message message) &#123; try &#123; // 將訊息送到 Client 端 await user.Value.WriteAsync(message); return null; &#125; catch (Exception ex) &#123; Console.WriteLine(ex); return user; &#125; &#125; &#125;&#125; 在 ChatService.cs 內注入 ChatRoom 並完成相關實做 12345678910111213141516171819202122232425262728293031using System.Collections.Generic;using System.Threading.Tasks;using Chat;using Grpc.Core;namespace chatwithgrpc&#123; public class ChatService: ChatRoom.ChatRoomBase &#123; private readonly Server.ChatRoom _chatroomService; public ChatService(Server.ChatRoom chatRoomService) &#123; _chatroomService = chatRoomService; &#125; public override async Task join(IAsyncStreamReader&lt;Message&gt; requestStream, IServerStreamWriter&lt;Message&gt; responseStream, ServerCallContext context) &#123; if (!await requestStream.MoveNext()) return; do &#123; _chatroomService.Join(requestStream.Current.User, responseStream); await _chatroomService.BroadcastMessageAsync(requestStream.Current); &#125; while (await requestStream.MoveNext()); _chatroomService.Remove(context.Peer); &#125; &#125;&#125; line 19: 第一次 join 時，並不會收到任何由 client 傳來的請求，所以就加個條件排除第一次 line 21~25 : 當 client 發出任何請求時，處理其請求內容，這裡就是廣播到其他有連線到 gRPC 服務的 client 端 到這裡後端的實做可以算是完成了，接下來換寫 Client 端 Program.cs 1234567891011121314151617181920212223242526272829303132333435363738394041public class Program &#123; static async Task Main(string[] args) &#123; Console.WriteLine("請輸入使用者姓名"); var userName = Console.ReadLine(); // Include port of the gRPC server as an application argument var port = args.Length &gt; 0 ? args[0] : "50051"; var channel = new Channel("localhost:" + port, ChannelCredentials.Insecure); var client = new ChatRoom.ChatRoomClient(channel); using (var chat = client.join()) &#123; _ = Task.Run(async () =&gt; &#123; while (await chat.ResponseStream.MoveNext(cancellationToken: CancellationToken.None)) &#123; var response = chat.ResponseStream.Current; Console.WriteLine($"&#123;response.User&#125;: &#123;response.Text&#125;"); &#125; &#125;); await chat.RequestStream.WriteAsync(new Message &#123; User = userName, Text = $"&#123;userName&#125; has joined the room" &#125;); string line; while ((line = Console.ReadLine()) != null) &#123; if (line.ToLower() == "bye") &#123; break; &#125; await chat.RequestStream.WriteAsync(new Message &#123; User = userName, Text = line &#125;); &#125; await chat.RequestStream.CompleteAsync(); &#125; Console.WriteLine("Disconnecting"); await channel.ShutdownAsync(); &#125; &#125; line 13: 建立與 server 端串流 (streaming) 連線 line 15~22: 處理由 server 端回傳的訊息，這裡是由其他 Client 端所傳送的聊天訊息 line 24: 對 Server 端發出第一次 Request line 27~34: 持續讀取 Console 畫面上的輸入訊息後，發訊息給 Server 端 line 35: 結束由 join 建立的串流連線 line 38: 關閉與 gRPC 服務的連線 如果這時後直接執行 Server 與 Client 端時，會發現 Client 會很容易斷線。這是因為 gRPC 有預設 request timeout 的時間，這可以在 Server 端的 Program.cs 內做設定 1234567891011public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); webBuilder.ConfigureKestrel((context, options) =&gt; &#123; // 增加此設定避免閒置斷線的問題 options.Limits.MinRequestBodyDataRate = null; &#125;); &#125;); 執行效果 參考資料 grpc.io gRPC C# Quick Start gRPC for .NET GitHub 簡單聊天功能 Repo]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularDart] HttpClient]]></title>
    <url>%2F2019%2F03%2F26%2Fngdart-httpclient%2F</url>
    <content type="text"><![CDATA[當需要呼叫 API 時，該如何處理? Angular 有 HttpClient 可以使用，那 AngularDart 呢? 好家在的是 Dart 有 http 的 library 可以使用，只要在 pubspec.yaml 裡面加上 http: ^0.11.0 的 package，再調整一下程式碼，就可以呼叫 API 了 設定 設定 HTTP Service 的方式很簡單，只要在 main.dart 做一下設定即可完成 123456789101112131415import 'package:angular/angular.dart';import 'package:http/browser_client.dart';import 'package:http/http.dart';import 'package:helloNgDart/app_component.template.dart' as ng;import 'main.template.dart' as self;@GenerateInjector([ ClassProvider(Client, useClass: BrowserClient),])final InjectorFactory injector = self.injector$Injector;void main() &#123; runApp(ng.AppComponentNgFactory, createInjector: injector);&#125; 如果在 VSCode 上面開發時，self.injector$Injector 會出現紅色底線，但是在編譯時卻不會發現任何錯誤，主要的原因是因為 main.template.dart 會在編譯時產出，那時候就不會有任何錯誤 Issue 使用 123456789101112131415161718192021222324252627282930313233import 'dart:convert';import 'package:angular/angular.dart';import 'package:http/http.dart';@Component( selector: 'my-app', template: ''' &#123;&#123; todo | async | json &#125;&#125; ''', directives: [], pipes: [AsyncPipe, JsonPipe],)class AppComponent implements OnInit &#123; final Client _http; var todo; AppComponent(this._http); @override ngOnInit() &#123; todo = getAll(); &#125; Future getAll() async &#123; try &#123; return _http .get('https://jsonplaceholder.typicode.com/todos/1') .then((resp) =&gt; json.decode(resp.body)); &#125; catch (e) &#123; errorMessage = e.toString(); &#125; &#125;&#125; 在 constructor 的地方注入 Client (需 import package:http/http.dart) http.get 會回傳 Future&lt;Response&gt; 的資料，可以透過 .then 的方式做後續的處理 json.decode 可以做 JSON 文字轉為物件的動作，(來源: dart:convert) 記得要處理 Exception Send data 1234567891011static final _headers = &#123;'Content-Type': 'application/json'&#125;;Future&lt;Hero&gt; create(String name) async &#123; try &#123; final response = await _http.post(_heroesUrl, headers: _headers, body: json.encode(&#123;'name': name&#125;)); return Hero.fromJson(_extractData(response)); &#125; catch (e) &#123; throw _handleError(e); &#125; &#125; Http Client 介面 BrowserClient 常用的方法有 get(dynamic url, { Map&lt;String, String&gt; headers }) → Future post(dynamic url, { Map&lt;String, String&gt; headers, dynamic body, Encoding encoding }) → Future put(dynamic url, { Map&lt;String, String&gt; headers, dynamic body, Encoding encoding }) → Future patch(dynamic url, { Map&lt;String, String&gt; headers, dynamic body, Encoding encoding }) → Future delete(dynamic url, { Map&lt;String, String&gt; headers }) → Future head(dynamic url, { Map&lt;String, String&gt; headers }) → Future 參考資料 HTTP Client]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularDart] Pipe]]></title>
    <url>%2F2019%2F03%2F26%2Fngdart-pipe%2F</url>
    <content type="text"><![CDATA[上一篇 提到在 Angular Dart 版本的 Component 如果要使用到 ngIf 這一類的 directive 時，需要在該 component 將 coreDirectives 加到 component 的 metadata 內，而要使用內建 pipe 或是自訂 pipe 時，也需要比照辦理，但唯一的差異是必須分別加 內建 Pipe AngularDart 內建的 Pipe 有以下幾個 AsyncPipe CurrencyPipe DatePipe DecimalPipe JsonPipe LowerCasePipe PercentPipe ReplacePipe SlicePipe UpperCasePipe 自訂 Pipe 自訂 Pipe 的方式也很簡單，只需要實做 PipeTransform 介面即可，以下有一個簡單的範例 12345678910111213141516import 'dart:math' as math;import 'package:angular/angular.dart';/* * Raise the value exponentially * Takes an exponent argument that defaults to 1. * Usage: * value | exponentialStrength:exponent * Example: * &#123;&#123; 2 | exponentialStrength:10&#125;&#125; * formats to: 1024 */@Pipe('exponentialStrength')class ExponentialStrengthPipe extends PipeTransform &#123; num transform(num value, num exponent) =&gt; math.pow(value ?? 0, exponent ?? 1);&#125; 當寫完自訂 pipe 要在 component 使用時，務必記得要在 component 的 pipes 加入該 pipe class，不然會出現編譯錯誤的訊息 既然是自訂 Pipe，就一定會遇到 pure 與 impure pipe 的問題，因為 Dart 語言每一個型別都是 Object ，所以要稍微留意一下這部分，像是 List 的操作，就必須留意 pure 與 impure 的設定 設定為 impure 的方式為 1@Pipe('flyingHeroes', pure: false) AsyncPipe AsyncPipe 在 Angular 可以用來接 Promise 或是 Observable，而在 AngularDart 內，可以接 Future 或是 Stream 型別的資料，使用方法是一樣的 1234567891011121314151617181920212223242526272829303132import 'dart:async';import 'package:angular/angular.dart';@Component( selector: 'hero-message', template: ''' &lt;h2&gt;Async Hero Message and AsyncPipe&lt;/h2&gt; &lt;p&gt;Message: &#123;&#123; message | async &#125;&#125;&lt;/p&gt; &lt;button (click)="resend()"&gt;Resend&lt;/button&gt; ''', pipes: [commonPipes],)class HeroAsyncMessageComponent &#123; static const _msgEventDelay = Duration(milliseconds: 500); Stream&lt;String&gt; message; HeroAsyncMessageComponent() &#123; resend(); &#125; void resend() &#123; message = Stream.periodic(_msgEventDelay, (i) =&gt; _msgs[i]).take(_msgs.length); &#125; List&lt;String&gt; _msgs = &lt;String&gt;[ 'You are my hero!', 'You are the best hero!', 'Will you be my hero?' ];&#125; 參考文件 Pipes]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularDart] Component]]></title>
    <url>%2F2019%2F03%2F25%2Fngdart-component%2F</url>
    <content type="text"><![CDATA[Angular Dart 裡沒有 NgModule，在官方文件裡提到的 Module 是指每一個 Component 的檔案，這可以從 main.dart 看出來 123456import 'package:angular/angular.dart';import 'package:helloNgDart/app_component.template.dart' as ng;void main() &#123; runApp(ng.AppComponentNgFactory);&#125; 基本架構 基本 Angular Library 都是從 package:angular/angular.dart 來的，如果需要其他的功能，例如 Http ，則需要引用其他的 library。一個基本的 Component 會有 class 本體與 metadata 的部分，既有的 lifecyle hooks 依然存在，像是 OnInit、OnDestory 等。 123456789101112131415161718192021@Component( selector: 'hero-list', templateUrl: 'hero_list_component.html', directives: [coreDirectives, formDirectives, HeroDetailComponent], providers: [ClassProvider(HeroService)],)class HeroListComponent implements OnInit &#123; List&lt;Hero&gt; heroes; Hero selectedHero; final HeroService _heroService; HeroListComponent(this._heroService); void ngOnInit() async &#123; heroes = await _heroService.getAll(); &#125; void selectHero(Hero hero) &#123; selectedHero = hero; &#125;&#125; 硬要說 Angular 與 AngularDart Component 的差異，應該是在 directives 與 providers 的部分，因為 AngularDart 版本並沒有 NgModule 這一個元素，所以服務的部分必須定義在 Component 這一個層級，同樣的內建的 directive ，像是 ngIf 、ngFor 等，都必須額外在 directives 的地方註冊，連使用到的 component 也必須被註冊。 Directive 如果需要使用到 NgClass、NgFor、NgIf、NgTemplateOutlet、NgStyle、NgSwitch、NgSwitchWhen、NgSwitchDefault 的，需要加入 coreDirectives 至 directives 。 如果需要使用到 NgModel 時，需要加入 formDirectives 至 directives。並需加入 angular_forms: 2.1.1 套件 Dependency Injection AngularDart 版本的 Dependency Injection，基本運作原理與 Angular 版本是一樣的，所以我們只需要將 AppComponent 視為 RootComponent(RootModule)，任何 service 註冊在這一層的，都是 root level service，註冊 Service 的方式為 123@Component( ... providers: [ClassProvider(DataService)]) 對應到 Angular 的註冊方式 使用方式 Angular AngularDart Class Provider [Logger] ClassProvider(Logger) Use-Class Provider [{provide: Logger, useClass: BetterLogger}] ClassProvider(Logger, useClass: BetterLogger) Exisiting Provider [{provide, useExisting: BetterLogger}] ExistingProvider(Logger, BetterLogger) Value Provider [{ provide: Logger, useValue: silentLogger }] ValueProvider(Logger, silentLogger) Factory Provider { provide: HeroService,useFactory: heroServiceFactory, deps: [Logger, UserService]} FactoryProvider(HeroService, heroServiceFactory) Token 使用法 使用方式 Angular AngularDart Token export const APP_CONFIG = new InjectionToken(『app.config』); const appTitleToken = OpaqueToken(『app.title』); 註冊 [{ provide: APP_CONFIG, useValue: 『app config content』}] ValueProvider.forToken(appTitleToken, appTitle) 取得 constructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; } AppComponent(@Inject(appTitleToken) this.title); AppComponent(@appTitleToken this.title); 範例程式 app_component.dart 123456789101112131415161718192021222324import 'package:angular/angular.dart';import 'package:helloNgDart/app-detail.component.dart';import './services/data.service.dart';@Component( selector: 'my-app', template: ''' &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;app-detail&gt;&lt;/app-detail&gt; &lt;hr/&gt; &lt;div *ngFor="let item of list"&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt; ''', directives: [coreDirectives, AppDetailComponent], providers: [ClassProvider(DataService)])class AppComponent &#123; var name = 'Angular'; final DataService service; var list; AppComponent(this.service) &#123; this.list = this.service.list; &#125;&#125; app-detail.component.dart 123456789101112131415161718192021222324import 'package:angular/angular.dart';import './services/data.service.dart';import 'package:angular_forms/angular_forms.dart';@Component( selector: 'app-detail', template: ''' &#123;&#123; name &#125;&#125; &lt;input [(ngModel)]="t" /&gt; &lt;button (click)="add()"&gt;Add&lt;/button&gt; ''', directives: [formDirectives],)class AppDetailComponent &#123; var name = "App Detail Component"; var t; final DataService service; AppDetailComponent(this.service); add() &#123; this.service.add(this.t); &#125;&#125; services/data.service.dart 1234567class DataService &#123; var list = ['1', '2', '3']; add(value) &#123; this.list.add(value); &#125;&#125; pubspec.yaml 1234567891011121314name: helloNgDartdescription: An absolute bare-bones web app.environment: sdk: '&gt;=2.1.0 &lt;3.0.0'dependencies: angular: ^5.0.0 angular_forms: 2.1.1dev_dependencies: build_runner: ^1.1.2 build_web_compilers: ^1.0.0 pedantic: ^1.0.0 結論 Angular Dart 的基本開發觀念是，每一個 Component 都是獨立個體，除了 provider 的部分，其餘的部分都需要各自設定，而這一部分是和 Angular (TS版) 有很大的差異性的 參考資料 Architecture angular library API Dependecy Injection]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularDart] Angular Dart 版本起手式]]></title>
    <url>%2F2019%2F03%2F15%2Fng-dart-start%2F</url>
    <content type="text"><![CDATA[Angular 除了常見的 TypeScript 版本，其實還又另外一個 Dart 語言的版本，雖然是不同的團隊維護，但是基本概念是一樣的，因為最近開始在碰 Flutter，當然也要來玩一下 Angular Dart 了。 環境設定 首先，要先將 Dart 語言的環境設定起來，雖然編輯器沒有限定，官方推薦使用 webstorm，而我本身是使用 VSCode 做開發。Anyway，先來安裝 Dart SDK 安裝 Dart SDK 支援的作業系統有 Windows、Linux、Mac，因為我目前的環境是 Windows，所以我就先以 Windows 的環境為文章的設定環境 1choco install dart-sdk choco 是一套 windows 上的套件管理工具，詳細資訊可以參閱官網 如果原本已經有安裝 Dart ，想要升級的話 1choco upgrade dart-sdk Dart SDK 內容 安裝完 Dart SDK 後，在開發環境會擁有以下的工具 dart: The standalone VM dart2js: The Dart-to-JavaScript compiler (used only for web development) dartanalyzer: The static analyzer dartdevc: The Dart development compiler (used only for web development) dartdoc: The API documentation generator dartfmt: The Dart code formatter pub: The Dart package manager 安裝 CLI Tools 打開命令視窗，分別執行下列的指令，會將 webdev 和 stagehand 這兩套工具安裝起來 12pub global activate webdevpub global activate stagehand VSCode 安裝擴充套件 可安裝 Dart 套件，讓 VS Code 支援 Dart 語言的開發 第一個 Hello World 在還沒有正式進入 Angular Dart 之前，先簡單來一個 Web Dart 版本的 Hello World，首先，我們先將開發專案的環境建構出來 建立專案資料夾: mkdir helloNgDart 進入資料夾 cd helloNgDart 使用剛剛安裝的 CLI 工具來初始化環境 stagehand web-simple 安裝相依套件 pub get 啟動 webdev server，開啟網頁 http://localhost:8080，即可看到第一個 Dart 網頁 webdev serve 當看到上圖時，就表示使用 Dart 開發 Web 的環境已經準備好了 第一個 Angular Dart 網頁 安裝 Angular 套件 Angular Dart 要如何安裝呢? 很簡單，只需要在 pubspec.yaml 內，將 angular: ^5.0.0 放在 dependencies 下 12345678910111213141516name: helloNgDartdescription: An absolute bare-bones web app.# version: 1.0.0#homepage: https://www.example.com#author: Kevin Yang &lt;email@example.com&gt;environment: sdk: '&gt;=2.1.0 &lt;3.0.0'dependencies: angular: ^5.0.0dev_dependencies: build_runner: ^1.1.2 build_web_compilers: ^1.0.0 pedantic: ^1.0.0 當將 angular: ^5.0.0 加入到 pubspec.yaml 時，編輯器工具會在背景安裝此套件 撰寫 AngularDart 將 web 資料夾下的 index.html 檔案修改一下， 將 &lt;app-root&gt;&lt;/app-root&gt; 放到 &lt;body&gt; 區塊中 新增 &lt;base href...&gt; 標籤 修改 main.dart 檔案，先移除既有的程式碼，改寫成下列程式碼 123456import 'package:angular/angular.dart';import 'package:helloNgDart/app_component.template.dart' as ng;void main() &#123; runApp(ng.AppComponentNgFactory);&#125; 目前這階段，編輯器會提示第二行的 import 找不到，這問題之後會被修正掉 import 'package:&lt;pubspec 內設定的 name 值&gt;/&lt;檔案名稱&gt;' 預設會指到 lib 資料夾 新增 lib 資料夾並建立 app_component.dart 檔案 app_component.dart 檔案內容 123456789import 'package:angular/angular.dart';@Component( selector: 'my-app', template: '&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;',)class AppComponent &#123; var name = 'Angular';&#125; 重新執行 webdev serve 後開啟網頁 http://localhost:8080 ，應可以看到以下的畫面 如果能看到畫面，恭喜，Angular Dart 的開發環境也設定完成了 部署 如果想要將 Angular Dart 輸出成可以部署的狀態時，又該如何處理，這部分也可以透過指令來完成 webdev build --no-release --output web:build –no-release : 會輸出成開發狀態的檔案， 檔案數量會很多且檔案很大。 要輸出成 production mode ，將 --no-release 的參數拿掉即可，當拿掉參數時， webdev build 將使用 dart2js 的方式建置專案。如果想要額外設定 dart2js (dart2js 有自己的參數可以設定)，需要額外新增 build.yaml 檔案，並將相關設定檔案設定在裡面 12345678910111213141516targets: $default: builders: build_web_compilers|entrypoint: # These are globs for the entrypoints you want to compile. generate_for: - test/**.browser_test.dart - web/**.dart options: compiler: dart2js # List any dart2js specific args here, or omit it. dart2js_args: - --fast-startup - --minify - --trust-primitives - --trust-type-annotations 比較輸出結果 with --no-release without --no-release Conclusion Angular Dart 因為所使用語言的關係，可以享受到一些 TypeScript 所沒有提供的，但也由於是不同語言開發的，即使有 90% 的觀念相同，仍需要針對差異的部份去做了解，但那部份就留在以後分享了 參考資料 Start Guide]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ngClass with JavaScript Set]]></title>
    <url>%2F2019%2F03%2F12%2Fng-ngclass%2F</url>
    <content type="text"><![CDATA[Angular 的 ngClass 可以讓我們用 Object 的方式來動態設定 css class，其實我們還可以使用另外一種方式來控制 ngClass Set JavaScript 的 set 可以讓我們儲存任何資料，而且能確保該資料是唯一的，表示一個 set 裡面不會有重複的資料。基本用法如下 123456const set1 = new Set([1, 2, 3, 4, 5]);set1.has(1); // trueset1.add(1); // set1 還是只有一個 1set1.delete(1); // 將 1 從 set1 中移除set1.has(1); // false ngClass 在官方 API 文件中，提到 ngClass 可以接受 string、Array、Object 這三種格式的資料 123456789&lt;some-element [ngClass]="'first second'"&gt;...&lt;/some-element&gt;&lt;some-element [ngClass]="['first', 'second']"&gt;...&lt;/some-element&gt;&lt;some-element [ngClass]="&#123;'first': true, 'second': true, 'third': false&#125;"&gt;...&lt;/some-element&gt;&lt;some-element [ngClass]="stringExp|arrayExp|objExp"&gt;...&lt;/some-element&gt;&lt;some-element [ngClass]="&#123;'class1 class2 class3' : true&#125;"&gt;...&lt;/some-element&gt; 但其實，在程式碼內的型別定義卻多看到一個 Set&lt;String&gt; 的型別，這真的是一個好消息。因為我們就可以透過操作 set 的方式來控制顯示樣式 123@Input()set ngClass(value: string|string[]|Set&lt;string&gt;|&#123;[klass: string]: any&#125;) &#123;&#125; DEMO 12345678910111213141516171819202122232425262728import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'my-app', template: ` &lt;button (click)="showBlue()"&gt;Show Blue Text&lt;/button&gt; &lt;button (click)="removeBlue()"&gt;Remove Blue Color&lt;/button&gt; &lt;p [ngClass]="setClasses"&gt; Start editing to see some magic happen :) &lt;/p&gt; `, styles: [ ` .blue &#123; color: blue; &#125;`]&#125;)export class AppComponent &#123; setClasses = new Set(); showBlue() &#123; this.setClasses.add('blue'); &#125; removeBlue() &#123; this.setClasses.delete('blue'); &#125;&#125; 上面的範例程式碼簡單的顯示出透過操作 set 的方式就能控制要顯示的樣式，會比直接操作陣列來的簡單太多了，提供給各位參考看看 參考資料 stackblitz 範例程式碼 Set]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何取得所處上層的 Component 元件 ?]]></title>
    <url>%2F2019%2F02%2F27%2Fng-get-parent-component%2F</url>
    <content type="text"><![CDATA[我們知道 Angular 的系統是透過 Component 的方式堆疊起來的，而 Component 與 Component 的溝通方式有幾種，1. 透過 @Input 和 @Output ，2. 透過 service 的方式，或是 3. 直接將上層 Component 注入到目前的 Component 內使用。 但通常我是不建議使用第 3 種方式，可是，在某些情境下，還是得必須這樣子處理，而且還需要動態的取得上層的 Component，這篇文章就是分享如何取得上層 Component 取得上層 Component 的方式，我們會透過 Injector 機制來完成，以下介紹兩種方式可以達到一樣的效果 情境描述 當 Input 離開時，需要觸發執行某些動作，但又不想要每一個 Component 都要處理這一類的工作，所以希望能用一個 general 的解法來完成這需求 正規解 根據情境，看起來又是一個可透過 RxJS 來完成的需求，但我要怎麼知道我目前的 Input 離開時，要讓那一個 Component 工作呢? 所以只要能取得目前觸發的 Input 是在哪一個 Component 內，就可以完成這需求了。 初版 directive 12345678910111213141516171819import &#123; Directive, HostListener &#125; from '@angular/core';import &#123; ControlService &#125; from './control.service';@Directive(&#123; selector: 'input'&#125;)export class InputFocusDirective &#123; @HostListener('blur', ['$event']) inputBlur(event) &#123; const &#123; name, value &#125; = event.target; this.service.inputEvent$.next(&#123; type: 'blur', name, value &#125;) &#125; constructor(private service: ControlService) &#123; &#125;&#125; service 12345@Injectable()export class ControlService &#123; inputEvent$ = new Subject(); constructor() &#123; &#125;&#125; app.component.ts 1234567891011121314151617181920212223242526272829import &#123; Component, forwardRef &#125; from '@angular/core';import &#123; ControlService &#125; from './control.service';import &#123; ParentComponent &#125; from './parent-component';import &#123; filter &#125; from 'rxjs/operators';@Component(&#123; selector: 'my-app', template: ` &lt;hello title="&#123;&#123; name &#125;&#125;"&gt;&lt;/hello&gt; &lt;form name="test"&gt; &lt;input name="firstName" [(ngModel)]="firstName" /&gt; &lt;/form&gt; &lt;p&gt; Start editing to see some magic happen :) &lt;/p&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; name = 'AppComponent'; firstName; constructor(private service: ControlService) &#123; service.inputEvent$ .subscribe((x: any) =&gt; &#123; console.log(x); &#125;); &#125;&#125; 上述的寫法，只要在任何 Component 內的 &lt;input&gt; 離開時都會觸發並廣播訊息到所有註冊者 第二版 接下來就是加入觸發者所處的 Component 資訊就可以做過濾判斷了，但在這之前，先建立一個通用的 ParentComponent parent-component.ts 12export abstract class ParentComponent &#123;&#125; app.component.ts 123456789101112import &#123; Component, forwardRef &#125; from '@angular/core';import &#123; ParentComponent &#125; from './parent-component';@Component(&#123; ... providers: [ &#123; provide: ParentComponent, useExisting: forwardRef(() =&gt; AppComponent) &#125; ]&#125;)export class AppComponent &#123; ...&#125; 說明 利用 Injector 取 provider 的順序特性，我們就能利用該特性取得目前觸發 directive 事件元件的隸屬 component forwardRef: Allows to refer to references which are not yet defined. useExisting: 使用已經建立的 instance，這能確保取得的 instance 不是全新的 directive 1234567891011121314151617181920import &#123; Directive, HostListener &#125; from '@angular/core';import &#123; ControlService &#125; from './control.service';@Directive(&#123; selector: 'input'&#125;)export class InputFocusDirective &#123; @HostListener('blur', ['$event']) inputBlur(event) &#123; const &#123; name, value &#125; = event.target; this.service.inputEvent$.next(&#123; type: 'blur', comp: this.parent, name, value &#125;) &#125; constructor(private service: ControlService, private parent: ParentComponent) &#123; &#125;&#125; 程式碼說明 將 ParentComponent 注入後，在事件觸發時將 Component 的資訊傳入 app.component.ts 12345678910@Component(...)export class AppComponent &#123; constructor(private service: ControlService) &#123; service.inputEvent$ .pipe(filter((x:any)=&gt; x.comp === this)) .subscribe((x: any) =&gt; &#123; console.log(x) &#125;); &#125;&#125; 程式碼說明 因為 inputEvent$ 內傳回的資訊已經有包含 Component 的資訊，所以可以透過 filter 的 operators 來過濾廣播訊息 完成需求 1234567891011121314export class AppComponent &#123; constructor(private service: ControlService) &#123; service.inputEvent$ .pipe(filter((x:any)=&gt; x.comp === this)) .subscribe((x: any) =&gt; &#123; (x.comp as AppComponent).show(x.value); &#125;); &#125; show(value) &#123; console.log(value); &#125;&#125; 範例程式碼 暗黑解 ※ 注意: 此暗黑解法十分黑暗，心臟不夠強的千萬不要用，所以我不會做任何解釋 123456789101112131415161718192021import &#123; Directive, HostListener, Injector &#125; from '@angular/core';import &#123; ControlService &#125; from './control.service';@Directive(&#123; selector: 'input'&#125;)export class InputFocusDirective &#123; @HostListener('blur', ['$event']) inputBlur(event) &#123; const &#123; name, value &#125; = event.target; this.service.inputEvent$.next(&#123; type: 'blur', comp: this.injector['view'].component, name, value &#125;) &#125; constructor(private service: ControlService, private injector: Injector) &#123; &#125;&#125; 範例程式碼]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] using]]></title>
    <url>%2F2019%2F02%2F19%2Frxjs-using%2F</url>
    <content type="text"><![CDATA[RxJS 裡面有許多 Operators 或是建立 Observable 的方法，而這篇文章就是要介紹 using 這一個建立 Observable 的方法 根據官方文件的說明，Using 是 Creates an Observable that uses a resource which will be disposed at the same time as the Observable. 1using&lt;T&gt;(resourceFactory: () =&gt; Unsubscribable | void, observableFactory: (resource: Unsubscribable | void) =&gt; ObservableInput&lt;T&gt; | void): Observable&lt;T&gt; Parameters Parameters Description resourceFactory A function which creates any resource object that implements unsubscribe method observableFactory A function which creates an Observable, that can use injected resource object. Returns Observable&lt;T&gt;: An Observable that behaves the same as Observable returned by observableFactory, but which - when completed, errored or unsubscribed - will also call unsubscribe on created resource object. 看不懂沒關係，來看一個簡單的程式碼就了解了 1234567891011121314151617181920212223242526272829303132333435import &#123; using, Subject, merge, Subscription, interval &#125; from 'rxjs';import &#123; map, refCount, tap, publish, take &#125; from 'rxjs/operators';console.clear();const messages$ = new Subject();const rejected$ = new Subject();const source = using(() =&gt; &#123; // resourceFactory const subscription = new Subscription(); subscription.add( interval(500).pipe(tap(n =&gt; &#123; if (n === 4) &#123; // 這行會造成透過 observableFactory 建立出的 observable 發生錯誤而中斷 rejected$.error('oops, something wrong'); &#125; console.log('inner obs: ' + n) &#125;)).subscribe() ); subscription.add(() =&gt; &#123; console.log('obs unsubscribe'); &#125;) return subscription;&#125;, (subscription) =&gt; &#123; // observableFactory return merge(messages$, rejected$)&#125;).pipe( tap((x) =&gt; console.log(x)), publish(), refCount())interval(1000).pipe(tap(n =&gt; messages$.next(n))).subscribe()const sub = source.pipe(take(5)).subscribe(); 執行結果: 當 observableFactory 結束時也會同時執行 resourceFactory 內所回傳的 subscription 物件的 unsubscribe 方法 subscription subscription.add 裡面除了可以放入其他 subscription 外，也可以放入 function，當 unsubscribe 時，除了會將加到這一個 subscription 內的 subscriptions 給取消註冊外，也會執行所放入的 function，這個在特定情況下十分好用 參考資料 範例程式碼]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] 應用練習 - sequenceEqual]]></title>
    <url>%2F2019%2F02%2F14%2Frxjs-sequence%2F</url>
    <content type="text"><![CDATA[今天在 medium 上面看到一篇有趣的文章，他的主題是 How to detect a sequence of keystrokes in JavaScript，那讓我用 RxJS 來挑戰一下，順便回味一下以前打電動需要輸入一系列的指令才可以開啟密技的樂趣 挑戰 當使用者在畫面上輸入了 **上上下下左右左右 BA **，就跳出 密技開啟 的訊息 擷取 keyup 事件，這個簡單 1const keys = fromEvent(document, 'keyup'); 我們先用 code 來作為判斷的規則 1const keys = fromEvent(document, 'keyup').pipe(map(e=&gt; e.code)); 準備開啟密技所需要的條件 123456789101112const codes = [ 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA']; 這裡先暫停一下，要解這一個題目，只要將步驟 2 所收集到的 code 與步驟 3 的條件做比對，如果相同就可以啟動密技了 收集 10 個 keyup 事件 123const keyCorrection = keys.pipe( bufferCount(10)); bufferCount : 1bufferCount&lt;T&gt;(bufferSize: number, startBufferEvery: number = null) 比較陣列的值 1234const matches = keyCorrection.pipe( map(result =&gt; codes.every((item, idx) =&gt; item === result[idx])));matches.subscribe(x =&gt; console.log(x)); 這樣子當次輸入 10 次項目時，就會做一次比對結果，這樣子結果是對的，但好像沒那麼漂亮 漂亮一點的解法 先來調整一下 keyCorrection 的寫法，讓在第一次收集完 keyup 事件後，之後每一次的keyup 事件都會送出值 123const keyCorrection = keys.pipe( bufferCount(10,1)); 再來修正比較的部份，這裡介紹一個 operator, sequenceEqual，這一個方法的功用是比較兩個 Observable 的值發生的順序是否一樣 1sequenceEqual&lt;T&gt;(compareTo: Observable&lt;T&gt;, comparator?: (a: T, b: T) =&gt; boolean): OperatorFunction&lt;T, boolean&gt; 將 matches 的部份調整一下 123const matches = keyCorrection.pipe( mergeMap(result =&gt; from(result).pipe(sequenceEqual(from(codes))))); 經過這樣子的修正後，一樣可以達到一樣的效果，最後在修飾一下，完整的程式碼如下 1234567891011121314151617181920212223242526import &#123; fromEvent, from &#125; from 'rxjs';import &#123; map, bufferCount, tap, mergeMap, sequenceEqual &#125; from 'rxjs/operators';console.clear();const codes = from([ 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA']);const keys = fromEvent(document, 'keyup').pipe(map((e: KeyboardEvent) =&gt; e.code));const matches = keys.pipe( bufferCount(10, 1), tap(console.log), mergeMap(result =&gt; from(result).pipe(sequenceEqual(codes))));matches.subscribe(x =&gt; console.log(x)); 參考資訊 範例程式碼 RxJS API - sequenceEqual RxJS API - bufferCount]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] NgZone 的應用]]></title>
    <url>%2F2019%2F02%2F14%2Fng-ngzone%2F</url>
    <content type="text"><![CDATA[昨天在討論區上面有人問了一個問題，「Angular 要如何做到檢查使用是否有在活動，如果一定時間內都沒有任何動作時，要自動登出系統」，這一個需求最直覺的方式是定時去檢查最後一次使用者有動作的時間，但使用 setInterval 會讓 Angular 的效能變差，這時候要怎麼解呢? 首先要先說明為什麼使用 setInterval 會讓 Angular 損失效能，主要的原因是 Angular 預設有使用 zone.js 來監控所有的事件，zone.js 會監測以下的事件，如果有發生時，就會觸發 ChangeDetection，進而更新整個畫面 Events - 使用者的行為，像是 click、change、input、submit 等 XMLHttpRequests - 像是呼叫 API Timers - setTimeout() 與 setInterval() 既然 setInterval() 會觸發 ChangeDetection，那就不要讓 Angular 知道有這件事情就好了。 NgZone Angular 有好心的幫我們包了一個 NgZone 的 class，我們可以透過這一個 class 來進行一些簡單的 zone.js 的操作 An injectable service for executing work inside or outside of the Angular zone. 這是官方描述 NgZone 的功能，而 NgZone 是長這樣的 1234567891011121314151617class NgZone &#123; static isInAngularZone(): boolean static assertInAngularZone(): void static assertNotInAngularZone(): void constructor(__0) hasPendingMicrotasks: boolean hasPendingMacrotasks: boolean isStable: boolean onUnstable: EventEmitter&lt;any&gt; onMicrotaskEmpty: EventEmitter&lt;any&gt; onStable: EventEmitter&lt;any&gt; onError: EventEmitter&lt;any&gt; run&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[]): T runTask&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[], name?: string): T runGuarded&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[]): T runOutsideAngular&lt;T&gt;(fn: (...args: any[]) =&gt; T): T&#125; 而這一篇文章我們就先看 run 與 runOutsideAngular 這兩個方法就好，在實務上這兩個也是最常用的方法 runOutsideAngular runOutsideAngular 內所執行的 function 是不會觸發任何 change detection 的，介面如下 1runOutsideAngular&lt;T&gt;(fn: (...args: any[]) =&gt; T): T 使用範例 123456789101112131415161718192021222324252627import &#123; Component, NgZone &#125; from '@angular/core';console.clear();@Component(&#123; selector: 'my-app', template: ` &lt;p&gt; &lt;label&gt;Count :&lt;/label&gt; &#123;&#123; num &#125;&#125; &lt;/p&gt; `&#125;)export class AppComponent &#123; num = 0; constructor(private zone: NgZone) &#123; this.zone.runOutsideAngular(() =&gt; &#123; let i = 0; const token = setInterval(() =&gt; &#123; this.num = ++i; console.log(this.num); if (i == 10) &#123; clearInterval(token); &#125; &#125;, 1000); &#125;) &#125;&#125; 上面的程式碼會每秒更新 num 的變數值，但是真正執行時，會發現畫面並沒有跟著被更新，但實際上 num 的這個變數是有被更新的，如何證明呢? 我們來加一個按鈕來觸發 change detection (程式碼) 12345678910111213141516171819202122232425262728293031import &#123; Component, NgZone &#125; from '@angular/core';console.clear();@Component(&#123; selector: 'my-app', template: ` &lt;p&gt; &lt;label&gt;Count :&lt;/label&gt; &#123;&#123; num &#125;&#125; &lt;/p&gt; &lt;button (click)="c()"&gt;click&lt;/button&gt; `&#125;)export class AppComponent &#123; num = 0; constructor(private zone: NgZone) &#123; this.zone.runOutsideAngular(() =&gt; &#123; let i = 0; const token = setInterval(() =&gt; &#123; this.num = ++i; console.log(this.num); if (i == 10) &#123; clearInterval(token); &#125; &#125;, 1000); &#125;) &#125; c() &#123; &#125;&#125; 為什麼會這樣子，還記得在一開始的地方我提到 zone.js 所監控的事件如果發生事件的話，就會觸發 change detection，而 click 事件剛就是在 zone.js 的管轄範圍內，所以當然經過一輪的 change detection，畫面就會顯示出當下應顯示的內容了。 稍微小結一下，根據上面的範例程式，我們可以知道當程式碼寫在 runOutsideAngular 是不會觸發 Angular 的 change detection。接下來延伸的問題是，那我要怎麼手動觸發 change detection 呢? run 手動觸發 change detection 的方法有幾種，因為這裡我們的主題是 NgZone，所以當然要使用 NgZone 的方法。而 run 這一個方法，其目的就與 runOutsideAngular 是反過來的，這裡是任何方法只要是寫在 run 裡面，就會進入到 Angular zone 的管轄範圍，介面如下 Executes the fn function synchronously within the Angular zone and returns value returned by the function. 1run&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[]): T 而這方法常見的使用情境是使用一些第三方套件，因為一開始就不在 zone.js 的管轄內，所以就必須手動將其包進 run() 內，才可以讓畫面正常的顯示。 而我們也可以透過這個方式將上一小節的問題給解決掉，程式碼如下 123456789101112131415161718192021222324252627282930import &#123; Component, NgZone &#125; from '@angular/core';console.clear();@Component(&#123; selector: 'my-app', template: ` &lt;p&gt; &lt;label&gt;Count :&lt;/label&gt; &#123;&#123; num &#125;&#125; &lt;/p&gt; `&#125;)export class AppComponent &#123; num = 0; constructor(private zone: NgZone) &#123; this.zone.runOutsideAngular(() =&gt; &#123; let i = 0; const token = setInterval(() =&gt; &#123; this.zone.run(() =&gt; &#123; this.num = ++i; &#125;) console.log(this.num); if (i == 10) &#123; clearInterval(token); &#125; &#125;, 1000); &#125;) &#125;&#125; 透過 run 的方式就可以簡單的回到 Angular zone 的管轄範圍了。 進階討論 回到一開始提到的問題 Angular 要如何做到檢查使用是否有在活動，如果一定時間內都沒有任何動作時，要自動登出系統 最簡單的解法是在 localStorage 紀錄最後一次使用者動作的時間，然後寫一個 timer 每隔 n 秒檢查目前的時間與最後一次異動時間的間隔是否大於所設定的閒置時間，簡易版本如下 12345678910111213141516171819202122232425export class AppComponent implements OnInit &#123; notify$ = new Subject(); ngOnInit() &#123; this.notify$.subscribe(() =&gt; &#123; this.message = 'timeout'; &#125;) &#125; constructor(private zone: NgZone) &#123; localStorage.setItem('expiredDate', addMinutes(new Date(), 1).getTime().toString()); this.zone.runOutsideAngular(() =&gt; &#123; const i = setInterval(() =&gt; &#123; const expiredDate = +localStorage.getItem('expiredDate'); console.log(new Date().getTime() - expiredDate); if (new Date().getTime() - expiredDate &gt; 0) &#123; this.zone.run(() =&gt; &#123; this.notify$.next(); &#125;) clearInterval(i); &#125;; &#125;, 1000) &#125;) &#125;&#125; 而這樣子的程式碼就只會在符合設定條件時，通知 Angular 要處理之後的動作了。 另外一種解法，不透過 run() 的方式是利用回傳值，不論是 run 或是 runOutsideAngular 都會有回傳值，我們就可以透過回傳 Promise 的方式，來解一樣的問題 (程式碼) 1234567891011121314151617constructor(private zone: NgZone) &#123; localStorage.setItem('expiredDate', addMinutes(new Date(), 0.1).getTime().toString()); this.zone.runOutsideAngular(() =&gt; &#123; return new Promise((resolve) =&gt; &#123; const i = setInterval(() =&gt; &#123; const expiredDate = +localStorage.getItem('expiredDate'); console.log(new Date().getTime() - expiredDate); if (new Date().getTime() - expiredDate &gt; 0) &#123; resolve(true); clearInterval(i); &#125;; &#125;, 1000) &#125;) &#125;).then(() =&gt; &#123; this.message = 'timeout'; &#125;)&#125; 補充內容 zone.js 的維護者/高手在社群內提出以下說明(連結) 如果要更加提高性能可以使用window[Zone.__symbom__('setInterval')], 這樣會強制使用Native 的Delegate, ngZone.runOutsideAngular 雖然不會觸發ChangeDetection,但是仍然會在默認的RootZone裡,會有一定的性能損耗 解法如下 12345678910111213141516export class AppComponent &#123; num = 0; constructor(private zone: NgZone) &#123; const nativeSetInterval = window[Zone.__symbol__('setInterval')]; // 使用這個代替 setInterval let i = 0; const token = nativeSetInterval(() =&gt; &#123; this.zone.run(() =&gt; &#123; this.num = ++i; &#125;) console.log(this.num); if (i == 10) &#123; clearInterval(token); &#125; &#125;, 1000); &#125;&#125; 程式碼 小結 雖然 NgZone 是一個很冷門的主題，但是還是有使用到的機會，了解一下也不是件壞事 延伸閱讀 ZONES IN ANGULAR USING ZONES IN ANGULAR FOR BETTER PERFORMANCE]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ControlContainer 的應用]]></title>
    <url>%2F2019%2F01%2F04%2Fangular-controlContainer%2F</url>
    <content type="text"><![CDATA[來談談 ControlContainer 的用法，根據 API 文件解釋 A base class for directives that contain multiple registered instances of NgControl. Only used by the forms module. 而內建繼承使用的 class 有 AbstractFormGroupDirective NgModelGroup FormGroupName NgForm FormGroupDirective FormArrayName 我們又可以如何利用 ControlContainer 呢 場景 其實簡單的一句話，我們可以寫出可以重複使用的 FormGroupControl，但由於 Angular 表單有兩種模式，這兩種模式在使用 ControlContainer 的用法上有些微的差異，這裡會分別寫出 首先，我們先假設我們有一個表單的區塊，會重複出現在很多地方，那我們是否可以將該區塊抽成一個獨立的 component 12345678910111213141516171819202122232425&lt;form #myForm="ngForm"&gt; &lt;div&gt; &lt;label&gt;Firstname:&lt;/label&gt; &lt;input type="text" name="firstName" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Lastname:&lt;/label&gt; &lt;input type="text" name="lastName" ngModel&gt; &lt;/div&gt; &lt;fieldset ngModelGroup="address"&gt; &lt;div&gt; &lt;label&gt;Zip:&lt;/label&gt; &lt;input type="text" name="zip" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Street:&lt;/label&gt; &lt;input type="text" name="street" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;City:&lt;/label&gt; &lt;input type="text" name="city" ngModel&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;pre&gt;&#123;&#123; myForm.value | json &#125;&#125;&lt;/pre&gt; 假設我想將 &lt;fieldset&gt; 的部分抽成獨立的 component 時，該怎麼做呢? Template Form 很直覺的是直接建立一個新的 Component 然後把 html 搬進去 1234567891011121314&lt;fieldset ngModelGroup="address"&gt; &lt;div&gt; &lt;label&gt;Zip:&lt;/label&gt; &lt;input type="text" name="zip" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Street:&lt;/label&gt; &lt;input type="text" name="street" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;City:&lt;/label&gt; &lt;input type="text" name="city" ngModel&gt; &lt;/div&gt;&lt;/fieldset&gt; address.component.html 123456789101112&lt;form #myForm="ngForm"&gt; &lt;div&gt; &lt;label&gt;Firstname:&lt;/label&gt; &lt;input type="text" name="firstName" ngModel&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Lastname:&lt;/label&gt; &lt;input type="text" name="lastName" ngModel&gt; &lt;/div&gt; &lt;app-address&gt;&lt;/app-address&gt;&lt;/form&gt;&lt;pre&gt;&#123;&#123; myForm.value | json &#125;&#125;&lt;/pre&gt; 當我們這樣子搬完後，會看到一個錯誤訊息 造成這個錯誤訊息的兇手是 ngModelGroup 1234567891011export const modelGroupProvider: any = &#123; provide: ControlContainer, useExisting: forwardRef(() =&gt; NgModelGroup)&#125;;@Directive(&#123;selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup'&#125;)export class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy &#123; constructor( @Host() @SkipSelf() parent: ControlContainer, @Optional() @Self() @Inject(NG_VALIDATORS) validators: any[],... 根據原始碼，我們需要提供 ControlContainer，但這又要從那裡來呢? 當然是從上層 (Host) 的 NgForm 提供，所以需要在 app-address.component.ts 內加入這一行 123456789@Component(&#123; selector: 'app-address', templateUrl: `./app-address.component.html`, viewProviders:[&#123; provide: ControlContainer, useExisting: NgForm &#125;]&#125;)export class AddressComponent &#123;&#125; 請留意：是註冊在 viewProviders，而不是 providers，其中的差異可以參閱 [Angular] viewProviders V.S. providers 當然成註冊後，剛錯誤就會消失，而畫面又回到正常的運作了，範例程式碼 Reactive Form 上面 ControlContainer 的用法就不適用於 Reactive Form 的開發方式了，而 Reactive Form 應該要這樣子寫 12345&lt;form [formGroup]="formData"&gt; &lt;input type="text" formControlName="firstName" /&gt; &lt;address formGroupName="address"&gt;&lt;/address&gt;&lt;/form&gt;&#123;&#123; formData.value | json &#125;&#125; app.component.html 1234567891011121314151617181920212223242526import &#123; Component, Input &#125; from '@angular/core';import &#123; ControlContainer &#125; from '@angular/forms';@Component(&#123; selector: 'address', template: ` &lt;fieldset [formGroup]="controlContainer.control"&gt; &lt;div&gt; &lt;label&gt;Zip:&lt;/label&gt; &lt;input type="text" name="zip" formControlName="zip"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Street:&lt;/label&gt; &lt;input type="text" name="street" formControlName="street"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;City:&lt;/label&gt; &lt;input type="text" name="city" formControlName="city"&gt; &lt;/div&gt; &lt;/fieldset&gt; ` &#125;)export class AddressComponent &#123; constructor(private controlContainer: ControlContainer) &#123; &#125;&#125; [formGroup] 的來源是來自 ControlContainer，剩下的行為就一模一樣了 Reacitve Form 的開發方式看起來簡單多了，範例程式碼 參考資料 API - ControlContainer]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 測試含有 debounceTime 的程式碼]]></title>
    <url>%2F2019%2F01%2F01%2Fangular-testing-debounceTime%2F</url>
    <content type="text"><![CDATA[Angular 在測試非同步的程式碼，有提供 fakeAsync 與 tick 的方法，可以讓我們手動控制時間的快慢，進而做到程式碼的測試，可是，這個寫法遇到 RxJS 時間相關的 operators 就會出問題，那又該如何處理呢? 雖然在官方文件內寫了很多如何測試非同步的方法，但是我發現這一個方法比較不容易出錯，也可以在 wallaby.js 的測試環境下正常運作，在此筆記分享 假設我有一段程式碼要測試 1234567this.searchBox.valueChanges .pipe( debounceTime(500) ) .subscribe(value =&gt; &#123; this.searchInput = value; &#125;); 這一個行為是在 searchBox 在停止動作後的 500ms 才會觸發 emit value 的事件，屬於時間類的 operators, 在 spec 內可以這樣子寫 123456789101112it('測試 Searchox', done =&gt; &#123; let FakeAsyncTestZoneSpec = (Zone as any)['FakeAsyncTestZoneSpec']; let testZoneSpec = new FakeAsyncTestZoneSpec('name'); let fakeAsyncTestZone = Zone.current.fork(testZoneSpec); fakeAsyncTestZone.run(() =&gt; &#123; component.searchBox.setValue('something'); testZoneSpec.tick(500); expect(component.searchInput).toBe('something'); done(); &#125;);&#125;); ※上述寫法必須在 zone.js 0.8.26 版本才能使用 延伸閱讀 Angular Testing]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 有些關於 NgModel 的事情]]></title>
    <url>%2F2018%2F12%2F25%2Fng-ngmodel-validator-ExpressionChangedAfterItHasBeenCheckedError%2F</url>
    <content type="text"><![CDATA[NgModel 如果沒寫好，很容易出現 ExpressionChangedAfterItHasBeenCheckedError 的錯誤訊息，但這一個錯誤訊息可能也不是 NgModel 直接造成的。只好又將 source code 翻出來看了 緣由 有人在 FB 社群上詢問，問什麼以下的程式碼會出現 ExpressionChangedAfterItHasBeenCheckedError 的錯誤訊息 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; NgForm &#125; from '@angular/forms';@Component(&#123; selector: 'my-app', styles: [` .error &#123; background-color: yellow &#125; `], template: ` &lt;div&gt; &lt;button type="button" (click)="addOne()"&gt;Add One Person&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ng-container *ngFor="let x of people; let i=index;"&gt; &lt;div&gt; &lt;button type="button" (click)="delete(i)"&gt;Delete&lt;/button&gt; Age: &lt;input name="age_&#123;&#123;i&#125;&#125;" [(ngModel)]="x.age" required #age="ngModel" [ngClass]="&#123;'error': age.errors&#125;"&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; `,&#125;)export class AppComponent &#123; people = []; addOne() &#123; this.people.push(&#123;&#125;); &#125; delete(i: number) &#123; this.people.splice(i, 1); &#125;&#125; 當點下 Add One Person 後，就會出現以下的錯誤訊息，但到底為什麼呢? 這個錯誤訊息的產生是因為 [ngClass] 造成的，先說解法。 使用 Reactive Form 寫 使用 [class.error] 代替 [ngClass]=&quot;{'error': age.errors }&quot; 自訂 ng-invalid 的 class 樣式 追追追 這一切都要從 Angular 是如何將 Component / Directive 產生出來說起，所有的 Component 和 Directive 的 constructor 都是在 ApplicationRef.tick() 事件前，所以我們就得來看 NgModule 這一個 Directive 到底做了哪些事情 1234567891011121314151617181920212223Directive(&#123; selector: '[ngModel]:not([formControlName]):not([formControl])', providers: [formControlBinding], exportAs: 'ngModel'&#125;)export class NgModel extends NgControl implements OnChanges, OnDestroy &#123; public readonly control: FormControl = new FormControl(); ... constructor(@Optional() @Host() parent: ControlContainer, @Optional() @Self() @Inject(NG_VALIDATORS) validators: Array&lt;Validator|ValidatorFn&gt;, @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators: Array&lt;AsyncValidator|AsyncValidatorFn&gt;, @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[]) &#123; super(); this._parent = parent; this._rawValidators = validators || []; this._rawAsyncValidators = asyncValidators || []; this.valueAccessor = selectValueAccessor(this, valueAccessors); &#125; ...&#125; 任何 NgModel 都會建立一個 FormControl，這個時間點尚未進行任何 FormControl 的驗證與更新 在第一次的 tick() 發生時，會做以下的事情 1234567891011121314151617181920tick(): void &#123; if (this._runningTick) &#123; throw new Error('ApplicationRef.tick is called recursively'); &#125; const scope = ApplicationRef._tickScope(); try &#123; this._runningTick = true; this._views.forEach((view) =&gt; view.detectChanges()); if (this._enforceNoNewChanges) &#123; this._views.forEach((view) =&gt; view.checkNoChanges()); &#125; &#125; catch (e) &#123; // Attention: Don't rethrow as it could cancel subscriptions to Observables! this._zone.runOutsideAngular(() =&gt; this._exceptionHandler.handleError(e)); &#125; finally &#123; this._runningTick = false; wtfLeave(scope); &#125;&#125; line 9: detectChanges 會執行 checkAndUpdateView 方法 checkAndUpdateView 內的 execComponentViewsAction 會觸發 OnChanges 事件 但 Services.updateDirectives 卻是在 execComponentViewsAction 之前，所以 [ngClass] 這時候接受到的值是 null NgModel OnChanges 事件 123456789101112gOnChanges(changes: SimpleChanges) &#123; this._checkForErrors(); if (!this._registered) this._setUpControl(); if ('isDisabled' in changes) &#123; this._updateDisabled(changes); &#125; if (isPropertyUpdated(changes, this.viewModel)) &#123; this._updateValue(this.model); this.viewModel = this.model; &#125;&#125; line 3: 判斷是否為第一次執行，如果是，又會判斷是否是 standalone。如果是 standalong 或是沒有上層的 ngForm 的話，則會立刻執行 formControl.updateValueAndValidity({emitEvent: false})， 取得 controls.errors 如果不是前一種情形，則會將此 NgModel 加入到 ngForm.controls 裡 line10: 是當處在 devMode 時，_enforceNoNewChanges 的值會是 true (主要錯誤發生點是在這一階段發生的) 執行 checkNoChangesView 方法 執行到 updateDirectives 然後噴錯，因為 [ngClass] 這時候已經能正常地取得 controls.error 的值 因為上面的值在一次 tick 週期內被異動了，所以就噴出 ExpressionChangedAfterItHasBeenCheckedError 錯誤訊息了 重新整理一次流程 Component Constructor NgModel Constructor ApplicationRef.tick() view.detectChanges() checkAndUpdateView 12345678910111213141516171819202122232425262728293031323334export function checkAndUpdateView(view: ViewData) &#123; if (view.state &amp; ViewState.BeforeFirstCheck) &#123; view.state &amp;= ~ViewState.BeforeFirstCheck; view.state |= ViewState.FirstCheck; &#125; else &#123; view.state &amp;= ~ViewState.FirstCheck; &#125; shiftInitState(view, ViewState.InitState_BeforeInit, ViewState.InitState_CallingOnInit); markProjectedViewsForCheck(view); Services.updateDirectives(view, CheckType.CheckAndUpdate); execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate); execQueriesAction( view, NodeFlags.TypeContentQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate); let callInit = shiftInitState( view, ViewState.InitState_CallingOnInit, ViewState.InitState_CallingAfterContentInit); callLifecycleHooksChildrenFirst( view, NodeFlags.AfterContentChecked | (callInit ? NodeFlags.AfterContentInit : 0)); Services.updateRenderer(view, CheckType.CheckAndUpdate); execComponentViewsAction(view, ViewAction.CheckAndUpdate); execQueriesAction( view, NodeFlags.TypeViewQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate); callInit = shiftInitState( view, ViewState.InitState_CallingAfterContentInit, ViewState.InitState_CallingAfterViewInit); callLifecycleHooksChildrenFirst( view, NodeFlags.AfterViewChecked | (callInit ? NodeFlags.AfterViewInit : 0)); if (view.def.flags &amp; ViewFlags.OnPush) &#123; view.state &amp;= ~ViewState.ChecksEnabled; &#125; view.state &amp;= ~(ViewState.CheckProjectedViews | ViewState.CheckProjectedView); shiftInitState(view, ViewState.InitState_CallingAfterViewInit, ViewState.InitState_AfterInit);&#125; line 21: 觸發 NgModel.ngOnChanges 事件 開發模式下: view.checkNoChanges() service.checkNoChangesView() 12345678export function checkNoChangesView(view: ViewData) &#123; markProjectedViewsForCheck(view); Services.updateDirectives(view, CheckType.CheckNoChanges); execEmbeddedViewsAction(view, ViewAction.CheckNoChanges); Services.updateRenderer(view, CheckType.CheckNoChanges); execComponentViewsAction(view, ViewAction.CheckNoChanges); view.state &amp;= ~(ViewState.CheckProjectedViews | ViewState.CheckProjectedView);&#125; 上述就是一個 tick() 會做的事情，只要在一個 tick 循環內出現 ViewModel 不一致的情形，都會噴錯]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Router in 7: 一些新功能]]></title>
    <url>%2F2018%2F12%2F24%2Fng-router-new-feature%2F</url>
    <content type="text"><![CDATA[Angular 7 版以後 (7.1~7.2)，在 Router 的部份又新增了不少功能，一起來看看到底新增了那些功能吧 Allow guards to return UrlTree 適用版本: 7.1 功能: 允許在 Router Guards 內回傳 UrlTree 物件，來達到轉址功能，一但轉址就會取消既有的瀏覽行為 Interface 123interface CanActivate &#123; canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree&#125; 用法範例 12345678910111213141516@Injectable()class CanActivateTeam implements CanActivate &#123; constructor(private permissions: Permissions, private currentUser: UserToken, private router: Router) &#123;&#125; canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable&lt;boolean|UrlTree&gt;|Promise&lt;boolean|UrlTree&gt;|boolean|UrlTree &#123; if(!this.permissions.canActivate(this.currentUser, route.params.id)) &#123; return this.router.createUrlTree(['/login']); &#125; return false; &#125;&#125; runGuardsAndResolvers 在設定 RouterConfig 時，可以設定何時要觸發 Guards 和 Resolver ，目前有的選項有 1type RunGuardsAndResolvers = 'pathParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) =&gt; boolean); 設定方式 123const routes: Route[] = [ &#123; path: '', component: AppComponent, runGuardsAndResolvers: 'always' &#125;]; runGuardsAndResolvers: 'always' 可以與 RouterModule 的 onSameUrlNavigation: 'reload' 搭配使用，即可做到同一網址瀏覽可以重跑 Guards 與 Resolvers 的動作 版本 7.1 新增 pathParamsChange 模式 版本 7.2 新增 pathParamsOrQueryParamsChange 模式 版本 7.2 新增 predicate function 模式: 可以自訂觸發規則 Allow passing state to routerLink 適用版本: 7.2 功能: 允許在 routerLink 上傳 data object as state 用法: 123&lt;a [routerLink]="['/user/bob']" [state]="&#123;tracingId: 123&#125;"&gt; link to user component&lt;/a&gt; 1234router.events.pipe(filter(e =&gt; e instanceof NavigationStart)).subscribe(e =&gt; &#123; const transition = router.getCurrentTransition(); tracingService.trace(&#123;id: transition.extras.state&#125;); &#125;); 參考資料 Changelog]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何 E2E 測試 PrimeNG Dropdown 元件]]></title>
    <url>%2F2018%2F12%2F23%2Fng-e2e-primeng-dropdown%2F</url>
    <content type="text"><![CDATA[PrimeNG 元件很豐富沒錯，但是他所提供的原件在寫 E2E 測試時卻是一個讓人無法忍受的痛苦，主要原因是他為了畫面的呈現，使用各種非正統的方式呈現畫面，而 Dropdown 元件就是一個很標準的案例 基本型 我們先來準備一下基本的測試環境 1234&lt;p-dropdown [options]="cities1" [(ngModel)]="selectedCity1"&gt;&lt;/p-dropdown&gt; 1234567891011121314151617interface City &#123; name: string; code: string;&#125;export class AppComponent &#123; selectedCity1: City; cities1: SelectItem[] = [ &#123; label: 'Select City', value: null &#125;, &#123; label: 'New York', value: &#123; id: 1, name: 'New York', code: 'NY' &#125; &#125;, &#123; label: 'Rome', value: &#123; id: 2, name: 'Rome', code: 'RM' &#125; &#125;, &#123; label: 'London', value: &#123; id: 3, name: 'London', code: 'LDN' &#125; &#125;, &#123; label: 'Istanbul', value: &#123; id: 4, name: 'Istanbul', code: 'IST' &#125; &#125;, &#123; label: 'Paris', value: &#123; id: 5, name: 'Paris', code: 'PRS' &#125; &#125; ]; &#125; 以上就是最基本 PrimeNG dropdown list 的用法，這時候如果要取得這一個 dropdown list 的方法，不外乎透過 id、name、CSS 的方式取得，其實我這裡介紹另外一種作法，data-attribute 的方式，寫法可以變成這樣 12345&lt;p-dropdown data-pp="cities1" [options]="cities1" [(ngModel)]="selectedCity1"&gt;&lt;/p-dropdown&gt; 透過設定 data-pp (這裡可以自己取名字)，就可以賦予元件一個唯一值，但又不會占用 id/name 的情形，之後還可以透過 directive 的方式將這一個屬性取消掉 當設定完 data-attribute 後，E2E 要取得這元件就變得比較簡單了 12345678910it('dropdown without editable', () =&gt; &#123; page.navigateTo(); const dropdown = element(by.css('[data-pp=cities1]')); dropdown.click(); dropdown.all(by.tagName('li')).then((options: ElementFinder[]) =&gt; &#123; options[1].click(); &#125;); const dropdownSelected = dropdown.element(by.css('.ui-dropdown-label')); expect(dropdownSelected.getText()).toEqual('New York'); &#125;); 程式碼說明 const dropdown = element(by.css('[data-pp=cities1]')); : 取得 dropdown 元件 dropdown.click(); 點擊選單 dropdown.all(by.tagName('li')) : 找到顯示出來的選項，(沒錯，PrimeNG 是用 ul &gt; li 的方式呈現) .then((options: ElementFinder[]) =&gt; { options[1].click(); }); 由於 dropdown.all()回傳是 promise 物件，所以需要接 then 才能做下一步的動作 options 會取回所有的選項，因為是陣列，可以使用 index 的方式選擇想要點選的項目 const dropdownSelected = dropdown.element(by.css('.ui-dropdown-label')); 取得 dropdown 元件顯示結果的 DOM，這裡是顯示在一個 label 上，而這一個 label 會有 .ui-dropdown-label'的 CSS Class expect(dropdownSelected.getText()).toEqual('New York'); 既然可以取得顯示用的 Label ，當然可以透過 getText() 的方式做結果比對 這就是標準 不可編輯 dropdown 的 E2E 基本的測試寫法 延伸變化 由於 PrimeNG 的 dropdown 元件另外提供輸入的功能，可以透過 [editable]=true 的方式開啟 123456&lt;p-dropdown data-pp="cities1" [options]="cities1" [(ngModel)]="selectedCity1" [editable]="true"&gt;&lt;/p-dropdown&gt; 但這一個設定開啟時，上面所寫的 E2E 測試程式碼就會死掉，主要原因是呈現跟互動方式整個都不一樣了，要點出下拉選單，就無法直接點選 &lt;p-dropdown&gt; 本身，而需要點選旁邊的小圖示 1234567891011it('dropdown with editable', () =&gt; &#123; page.navigateTo(); const dropdown = element(by.css('[data-pp=cities1]')); const dropdownClicked = dropdown.element(by.css('.ui-dropdown-trigger')); dropdownClicked.click(); dropdown.all(by.tagName('li')).then((options: ElementFinder[]) =&gt; &#123; options[1].click(); &#125;); const dropdownSelected = dropdown.element(by.css('.ui-dropdown-label')); expect(dropdownSelected.getAttribute('aria-label')).toEqual('New York');&#125;); 程式碼說明 取得 dropdown 元件本體的作法是一樣的 const dropdownClicked = dropdown.element(by.css('.ui-dropdown-trigger')); 取得可以點選的部分 (參閱上圖) dropdownClicked.click(); 點擊打開選單 透過 index 設定要選取的選項 const dropdownSelected = dropdown.element(by.css('.ui-dropdown-label')); 取得顯示結果的元件 這裡要留意的是，因為是 [editable]=true 的關係，顯示結果的 Element 就在是 Label 了，而是 Input expect(dropdownSelected.getAttribute('aria-label')).toEqual('New York'); 比較結果 小結 以上就是 PrimeNG dropdown 元件兩種模式在 E2E 的基本寫法，當然這些動作應該要寫成一個 Page Object 模式的檔案，區隔出來好讓整個測試檔案看起來更乾淨。 延伸議題 為了讓輸出到 production 時，HTML 畫面上能減少一些不必要的東西，例如 data-pp，那可以怎麼處理，這裡就介紹一種方式，寫自訂 directive 來自我移除 Directive 12345678910111213import &#123; environment &#125; from './../environments/environment';import &#123; Directive, ElementRef, Renderer2 &#125; from '@angular/core';@Directive(&#123; // tslint:disable-next-line:directive-selector selector: '[data-pp]'&#125;)export class DataPpDirective &#123; constructor(private el: ElementRef, private renderer: Renderer2) &#123; if (environment.production) &#123; renderer.removeAttribute(el.nativeElement, 'data-pp'); &#125; &#125;&#125; 參考資料 Angular and Cypress: data-cy attributes]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Playground]]></title>
    <url>%2F2018%2F12%2F22%2Fng-playground%2F</url>
    <content type="text"><![CDATA[其實 Angular Playground 出來已經有好一段時間了，但是之前的環境設定會讓人懶得用。現在可以簡單的透過 ng add angular-playground 的方式完成整體的環境設定，這麼方便不用就說不過去了。 簡介 但什麼是 Angular Playground，如果你有聽過 React 的 Storybook ，那 Angular playground 也是要完成一樣的事情。簡單的說， Angular playground 提供一個乾淨的環境讓我們能就單一 Component 進行 UI 的測試。 有時候當 Angular 專案開發到很複雜時，某一個 Component 被藏在很多步驟後，但為了測試那個 Component 的畫面操作是否正常，就必須經過前面各種關卡的挑戰，那是否有更快更簡便的方式進行 Component UI 的測試呢? 其實 Angular playground 就可以做到這一點 安裝篇 透過 Angular CLI 的幫助，我們可以利用一行指令就將 Angular playground 的環境設定完成 1ng add angular-playground 當執行這一行指令後，會產生及變更以下的檔案 angular-playground.json 為 Angular playground 的設定檔案 src/main.playground.ts 是 Angular playground 啟動時的進入檔，用來設定起使用的 NgModule 更新 package.json ，新增 script 指令，可以透過 npm run playground 的方式啟動 更新 angular.json ，新增新的 playground 建置指令到 projects 區塊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051"playground": &#123; "root": "", "sourceRoot": "src", "projectType": "application", "architect": &#123; "build": &#123; "builder": "@angular-devkit/build-angular:browser", "options": &#123; "outputPath": "dist/playground", "index": "src/index.html", "main": "src/main.playground.ts", "polyfills": "src/polyfills.ts", "tsConfig": "src/tsconfig.app.json", "assets": [ "src/favicon.ico", "src/assets" ], "styles": [ "src/styles.css" ], "scripts": [] &#125;, "configurations": &#123; "production": &#123; "fileReplacements": [ &#123; "replace": "src/environments/environment.ts", "with": "src/environments/environment.prod.ts" &#125; ], "optimization": true, "outputHashing": "all", "sourceMap": false, "extractCss": true, "namedChunks": false, "aot": false, "extractLicenses": true, "vendorChunk": false, "buildOptimizer": false &#125; &#125; &#125;, "serve": &#123; "builder": "@angular-devkit/build-angular:dev-server", "options": &#123; "browserTarget": "playground:build", "port": 4201 &#125; &#125; &#125; &#125; 所以額外想加入的 assets / styles/ scripts 的部分，都可以設定在這個區塊內 當這些都建立完成後，就可以第一次 playground 的啟動 npm run playground ，執行指令後，將會做 Angular 專案的建置並啟動一個 web server，且將 port 開在 4201，所以可以打開瀏覽器並輸入 http://localhost:4201 就可以看到 playground 的頁面了 畫面上有寫了一些基本的操作指令 ctrl+p / F2 開啟命令視窗 esc 取消命令視窗 ↑ / ↓ 進行上下選擇場景 ctrl + ↑ / ctrl + ↓ 切換場景 建立 sandbox 既然能使用 ng add 的指令，playground 當然也提供了 schematics 的指令來建立 sandbox 檔案 ng generate angular-playground:sandbox [path]/[component name] 輸入這行指令就會根據所指定的 component 建立相對應的 sandbox 檔案，什麼是 sandbox 檔案，這個檔案的性質跟 spec 測試檔案性質一樣，只差在這裡並不寫讓任何的測試程式碼，只有測試環境的設定而已 1234567import &#123; sandboxOf &#125; from 'angular-playground';import &#123; HelloWorldComponent &#125; from '../hello-world.component';export default sandboxOf(HelloWorldComponent) .add('default', &#123; template: `&lt;app-hello-world&gt;&lt;/app-hello-world&gt;` &#125;); 一個基本的 sandbox 檔案大致上是長這個樣子的，會包含這些元素 你測試的 Component 是哪一個，使用 sandboxOf(type: any, config?: SandboxOfConfig) 的方式設定，這 sandboxOf 會回傳一個 SandboxBuilder 的 instance 1sandboxOf(HelloWorldComponent) SandboxOfConfig : 用來設定與這 Component 相關的 Dependency，如同設定一個 NgModule，比較常用的會是 imports 與 providers imports?: any[]; declarations?: any[]; entryComponents?: any[]; providers?: any[]; schemas?: any[]; label?: string; declareComponent?: boolean; SandboxBuilder Class 我們可以使用的方法只有一個， add(description: string, config: ScenarioConfig): SandboxBuilder; ScenarioConfig 可以設定項目有，這裡設定是針對 Component 執行的環境場景 template: string; styles?: string[]; context?: any; - 如果想要傳變數到 component 內，就可以在這個區塊作變數設定 providers?: any[]; 範例 我先建立一個 HelloWorldComponent ，並建立相對應的 sandbox 檔案 ng g c hello-world : 建立 HelloWorldComponent ng g angular-playground:sandbox hello-world : 為 HelloWorld 建立 sandbox 檔案 執行 npm run playground 12345678910111213141516import &#123; sandboxOf &#125; from 'angular-playground';import &#123; HelloWorldComponent &#125; from './hello-world.component';export default sandboxOf(HelloWorldComponent) .add('default', &#123; template: `&lt;app-hello-world&gt;&lt;/app-hello-world&gt;` &#125;) .add('with input', &#123; template: `&lt;app-hello-world [data]="data"&gt;&lt;/app-hello-world&gt;`, context: &#123; data: &#123; firstName: 'Kevin', lastName: 'Yang' &#125; &#125; &#125;); 當設定兩組場景時，命令視窗的選擇就可以看到這兩個場景，之後就可以透過 ↑ / ↓ 來選擇 進階使用小技巧 Component 的開發當然不可能這麼單純，如果有注入 Api Service 時，總不可能每次都去打真的 API，這時候就可以透過 provide DI 設定的技巧，有很多手法跟寫 spec 測試時是一樣的，簡單範例程式碼如下 12345export default sandboxOf(MyComponent, &#123; providers: [ &#123; provide: myService, useValue: &#123; doStuff: () =&gt; &#123;&#125; &#125; &#125; ]&#125;) 相關資源 Angular Playground]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Tree Shaking 真的有作用嗎?]]></title>
    <url>%2F2018%2F11%2F20%2Fng-treeshaking%2F</url>
    <content type="text"><![CDATA[Angular 在建置輸出時，如果加上 --prod 時，會將所有的 bundle 做最小化還有 Tree-Shaking 的行為，將沒有使用的程式碼從 bundle 檔案中移除，但是，實際上輸出結果是否如官方所說，還有什麼細節是需要知道的嗎? 為了驗證這一個功能，將進行以下的測試，首先先準備測試環境，測試環境如下 一個 lazy-loading Module，包含一個 DashComponent 一個 sharedModule 包含一個 TitleComponent 一個 service 測試項目集 測試項目一 這一個測試項目來測試 lazy-loading module 但是 lazy-loading 沒有設定任何的路由設定檔 page1.module.ts 檔案 1234567891011import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; RouterModule &#125; from '@angular/router';import &#123; DashComponent &#125; from './dash/dash.component';import &#123; SharedModule &#125; from '../shared/shared.module';@NgModule(&#123; declarations: [DashComponent], imports: [CommonModule, SharedModule]&#125;)export class Page1Module &#123;&#125; shared.module.ts 檔案內容 12345678910import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; TitleComponent &#125; from './title/title.component';@NgModule(&#123; declarations: [TitleComponent], imports: [CommonModule], exports: [TitleComponent]&#125;)export class SharedModule &#123;&#125; app.module.ts 檔案內容 123456789101112131415import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';import &#123; SharedModule &#125; from './shared/shared.module';import &#123; DataService &#125; from './data.service';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, SharedModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; app-routing.module.ts 123456789101112import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: 'page1', loadChildren: './page1/page1.module#Page1Module' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125; 為了方便辨識 Component 是否有被移出 bundle 檔案，所以在 Component 內都新增一個 name 屬性並給予 Component 名稱的文字值，經過 ng build --prod 後，產生了一下的檔案，並檢查了 4.f4517b1f3405740b1d81.js 檔案內容 (此為 lazy-loading module) 4.f4517b1f3405740b1d81.js 檔案內並沒有包含 DashComponent 的文字 這裡沒有看到 DashComponent 的原因是因為在 Page1Module 裡並沒有使用到 DashComponent 所以即使在 declarations 有宣告，程式碼仍不會被包含到 bundle 檔案內 測試項目二 延續上述的情境，如果直接在 DashComponent 內使用 TitleComponent，TitleComponent 是否會被包含至檔案內呢? dash.component.html 12&lt;p&gt;dash works!&lt;/p&gt;&lt;app-title&gt;&lt;/app-title&gt; 再次執行 ng build --prod，並檢視輸出內容 如預期般的沒有被包含進來，因為連 DashComponent 都沒有，怎麼可能會有 TitleComponent 測試項目三 延續上面的環境，將 Page1Module 設定路由，並檢查建置後的結果 1234567891011121314151617181920import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; RouterModule, Router &#125; from '@angular/router';import &#123; DashComponent &#125; from './dash/dash.component';import &#123; SharedModule &#125; from '../shared/shared.module';@NgModule(&#123; declarations: [DashComponent], imports: [ CommonModule, SharedModule, RouterModule.forChild([ &#123; path: '', component: DashComponent &#125; ]) ]&#125;)export class Page1Module &#123;&#125; 檢視 4.461b274d80afee68498a.js 內容 我們可以看到 TitleComponent 與 DashComponent 都被包含到輸出檔案內，也十分合理。這也表示如果我們將 &lt;app-title&gt; 從 dash.component.html 中移除，在輸出檔案裡會看不見 TitleComponent 地存在的 或許有人會很好奇，為什麼只要透過路由設定檔所定義的 Component，即使沒有在任何 template 使用，仍會被輸出到檔案中，這是因為路由設定的 component (routed entry component) 是另外一種定義成 entryComponent 的方法。(官方文件) 測試項目四 在這個測試項目中，我們將路由設定檔拿掉，但將 DashComponent 註冊在 entryComponent 的地方，來觀察一下結果 123456789101112import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; RouterModule, Router &#125; from '@angular/router';import &#123; DashComponent &#125; from './dash/dash.component';import &#123; SharedModule &#125; from '../shared/shared.module';@NgModule(&#123; declarations: [DashComponent], imports: [CommonModule, SharedModule], entryComponents: [DashComponent]&#125;)export class Page1Module &#123;&#125; 檢視輸出內容時，發現當 Component 註冊到 entryComponents 時，即使沒有任何人使用到該 Component，仍會被輸出 綜合測試項目一的結果與本項目的測試結果，我們可以發現 Component 註冊在 declarations 與 entryComponents 的差異，也可以驗證官方文件的描述 測試項目五 當 SharedModule 內的 Component 在不同的 Module 中都被使用到，該 component 程式碼會輸出成幾份? 答案: 一份 在這個測試裡，我將 &lt;app-title&gt; 同時在 app.component.html 與 dash.component.html 都有引用，根據輸出檔案的內容，只能在 main.4a9a348ca69cdb67065f.js 檔案內找到 TitleComponent (2018/11/21 Updated) 有朋友在留言提到，如果是在兩個 lazy-loading module 裡使用 sharedModule 的 component 時 (沒有在 app.component.html 內使用到)，會被輸出至 common 的 bundle 檔案中，當然有圖有真相 測試項目六 Service 新的註冊方式 provideIn 是否真的能被 tree-shake 掉呢? data.service.ts 123456789import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root'&#125;)export class DataService &#123; name = 'DataService'; constructor() &#123;&#125;&#125; 首先不在任何的 component 內注入 DataService，觀察輸出後的結果 在這兩個檔案內都找不到 DataService 的影子，看起來真的被排除了。 測試項目七 這帶來另外一下一個問題，如果將 DataSerivce 在 Page1Module 時，DataService 會在哪裡出現呢? dash.component.ts 1234567891011121314import &#123; Component, OnInit &#125; from '@angular/core';import &#123; DataService &#125; from 'src/app/data.service';@Component(&#123; selector: 'app-dash', templateUrl: './dash.component.html', styleUrls: ['./dash.component.css']&#125;)export class DashComponent implements OnInit &#123; name = 'DashComponent'; constructor(private dataService: DataService) &#123;&#125; ngOnInit() &#123;&#125;&#125; DataService 會被註冊在 Lazy-loading Module 裡。 但當 app.component.ts 裡也有注入 DataService 時，程式碼出現的地方也會不一樣，將會出現在 main 的檔案中 測試項目八 如果在兩個不同的 lazy-loading 內都有使用到 DataService 時， DataService 會出現在哪裡呢? 答案是會出現在 common 裡 可是當在 app.component.ts 注入 DataService 時，DataService 又會回到 main 的檔案中 測試項目九 將 DataService 註冊在 AppModule 的 providers 裡，且不在任何的 component 內使用，再來看輸出結果 123456789101112131415import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';import &#123; SharedModule &#125; from './shared/shared.module';import &#123; DataService &#125; from './data.service';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, SharedModule], providers: [DataService], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; data.service.ts 1234567import &#123; Injectable &#125; from '@angular/core';@Injectable()export class DataService &#123; name = 'DataService'; constructor() &#123;&#125;&#125; 建置輸出結果可以看出，不論是否有被使用，都會被輸出 測試項目十 在 Angular 外部寫 function 後，在 Angular component 內使用，會出現什麼事情? 1234567891011121314151617181920import &#123; Component &#125; from '@angular/core';import &#123; DataService &#125; from './data.service';function TreeShakingTest() &#123; console.log('TreeShakingTest Function'); return 'return from TreeShakingTest Function';&#125;@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; title = 'treeshakingtest'; constructor() &#123; console.log(TreeShakingTest()); &#125;&#125; 建置後的結果為 最終的輸出結果十分有趣，直接將 function 轉換到 Angular 內部了 結論 這一篇文章所整理的結果，在效能調整上十分重要，我們知道 main.js 檔案算是一開始要載入的檔案，為了減少 main.js 檔案的大小，service 的註冊與使用就很小心，因為一個不小心就會增加 main.js 的檔案大小，同樣的在 app.component.html 內使用其他 component 時，也會造成 main.js 檔案變大。 另外，我們也不用多擔心 sharedModule 過多的載入會造成檔案肥大，因為如果真的沒有使用到，是不會被輸出的，可以安心使用]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 該如何使用設定 RouteReuseStrategy]]></title>
    <url>%2F2018%2F11%2F06%2Fng-RouteReuseStrategy%2F</url>
    <content type="text"><![CDATA[Angular 路由機制中，有一個選項是 routeReuseStrategy，這一個設定可以讓我們設定路由轉換的過程中，是否要保留 component 並重複使用，而相關的使用方式如下 設定 首先，先建立一個 Class 並實作 RouteReuseStrategy 介面，RouteReuseStrategy 介面包含了五個方法需要被實作 1234567abstract class RouteReuseStrategy &#123; abstract shouldDetach(route: ActivatedRouteSnapshot): boolean abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void abstract shouldAttach(route: ActivatedRouteSnapshot): boolean abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean&#125; shouldDetach : 判斷路由是否能重複使用 store : 將脫離的路由內容暫存起來 shouldAttach : 當路由進入時，可判斷是否還原路由暫存內容 retrieve : 從 Cache 中取得對應的暫存內容 shouldReuseRoute : 判斷是否同一路由 基本範例程式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; RouteReuseStrategy, DefaultUrlSerializer, ActivatedRouteSnapshot, DetachedRouteHandle&#125; from '@angular/router';export class AppRoutingCache implements RouteReuseStrategy &#123; public static handlers: &#123; [key: string]: DetachedRouteHandle &#125; = &#123;&#125;; // 判斷路由是否能重複使用 public shouldDetach(route: ActivatedRouteSnapshot): boolean &#123; // 默認所有的路由設定都可以重複使用 // 可透過 route.data 的方式來設定重複使用的規則 return true; &#125; // 當路由離開時，會觸發此方法 public store( route: ActivatedRouteSnapshot, handle: DetachedRouteHandle ): void &#123; // 將目前路由內容暫存起來 AppRoutingCache.handlers[route.routeConfig.path] = handle; &#125; // 當路由進入時，可判斷是否還原路由的暫存內容 public shouldAttach(route: ActivatedRouteSnapshot): boolean &#123; return ( !!route.routeConfig &amp;&amp; !!AppRoutingCache.handlers[route.routeConfig.path] ); &#125; // 從 Cache 中取得對應的暫存內容 public retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123; if (!route.routeConfig) &#123; return null; &#125; return AppRoutingCache.handlers[route.routeConfig.path]; &#125; // 判斷是否同一路由 public shouldReuseRoute( future: ActivatedRouteSnapshot, current: ActivatedRouteSnapshot ): boolean &#123; return future.routeConfig === current.routeConfig; &#125;&#125; 註冊 將寫好的 class 註冊在 RootModule 的 proivders 的區塊中即可 1providers: [&#123; provide: RouteReuseStrategy, useClass: AppRoutingCache &#125;], 當這樣子設定完成後，Angular 路由機制就會依照我們實作的 RouteReuseStrategy 來管理路由的相關資訊，內包含 ComponentRef ，效果會是當我們重新返回該路由時，原本輸入的資料還會存在。因為是使用當時離開時的 Component 而不是重新建立一個新的。 實際的操作效果可以參考 範例程式 參考資料 API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] Subscription]]></title>
    <url>%2F2018%2F11%2F05%2Frxjs-subscription%2F</url>
    <content type="text"><![CDATA[在 RxJS 裡在建立 Observable 時，都會回傳一個 subscription 物件，而這一個物件允許我們手動取消 Observable 的動作，其實 Subscription 裡還有其他細節的。這一篇文章就來探討 Subscription。 介面 1234export interface SubscriptionLike extends Unsubscribable &#123; unsubscribe(): void; readonly closed: boolean;&#125; 這一個介面定義是 RxJS 6.x 版，也是我們常見的使用方法，但事實上在 Subscription 內還有兩個 method 是沒有定義，而這一個問題在 RxJS 7 版有被修正 1234567// RxJS 7 版的 Subscription 介面export interface Subscription &#123; unsubscribe(): void; add(...teardowns: TeardownLogic[]): void; remove(...teardowns: TeardownLogic[]): void; readonly closed: boolean;&#125; 基本功能 unsubscribe unsubscribe 應該不需要多解釋了，就是將 Observable 給取消訂閱，當 Observable 被取消訂閱時就會停止運作了。這裡有一個觀念要知道，一個 Observable 被 unsubscribe 時，是不會進到 complete 階段的，如果有什麼動作是希望在 Observable 完成時或是被取消時執行的話，就必須使用 finalize 這一個 operator，finalize 會在 complete 之後執行 closed 當 subscription 被 unsubscribe 時，closed 這一個屬性就會被標示成 true，可以利用這個來判斷 subscription 的狀態 進階功能 管理 Observable 的 subscription 是一件大工程，常見的管理方式，就是利用 takeUntil 來做管理 123456someMethod()&#123; obs.pipe(takeUntil(this.destroy$)).subscribe();&#125;ngOnDestroy()&#123; this.destroy$.next(); &#125; 這裡介紹另外一種管理方式，我們也可以透過 Subscription 來做管理，使用方式是先建立一個空的 Subscription，然後透過 add 和 remove 的方式來管理 123import &#123; Subscription, interval &#125; from 'rxjs';// 建立空的 Subscription 物件const sub = new Subscription(); add 將 Observable 的 subscription 加入至 Subscription 物件裡，使用方法如下 12const obsSub = interval(1000).subscribe();sub.add(obsSub); remove 將 Observable 的 subscription 從 Subscription 物件裡移除，使用方法如下 1sub.remove(obsSub); unsubscribe 當要取消所有 Observable 的動作時，這時候只需要將 Subscription 物件做 unsubscribe，任何註冊在此 Subscription 物件裡的 subscription 也同時會執行 unsubscribe 的動作 12345678const sub = new Subscription();someMethod()&#123; this.sub.add(obs.subscribe());&#125;ngOnDestroy()&#123; this.sub.unsubscribe();&#125; 秘密篇 在深入研究 RxJS Subscription 的程式碼，發現 add 這一個方法是接受 TeardownLogic 型別的物件，而 TeardownLogic 的介面是 1export type TeardownLogic = Unsubscribable | Function | void; 沒錯，我們也可以 add Function 至 Subscription 內，而這執行的時機點就是在 Subscription unsubscribe 時，執行順序會依 add 的順序，這一個祕密將為我們打開另外一道門，將 RxJS 的寫法提供更彈性的寫法 12345678910111213const sub = new Subscription();someMethod()&#123; this.sub.add(obs.subscribe()); this.sub.add(()=&gt;&#123; console.log('do something after unsubscribe'); &#125;)&#125;ngOnDestroy()&#123; this.sub.unsubscribe(); // 會將 observable unsubscribe // 並 console.log 'do something after unsubscribe'&#125; FYI 目前 RxJS 6 的 Subscription 種類只有一種，但在 RxJS 7 有推出另外一種 Subscription，可以說是原本 Subscription 的延伸版本，但在 RxJS 7 定版前，先不介紹這一個 Subscription ，等有進一步消息時，在另外寫文章介紹]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[O365] Excel 新功能 - Dynamic Array Functions]]></title>
    <url>%2F2018%2F10%2F30%2Fexcel-dynamic-array-unique%2F</url>
    <content type="text"><![CDATA[使用 O365 的好處是，所使用的 Excel 等相關應用程式， 都是處於最新的功能狀態。如果心臟夠大顆，也可以加入 Insider 計畫取得更新的功能，例如這篇文章要介紹的 Dynamic Array Function。 介紹幾個跟 Dynamic Array 相關的新函數 ，這些新函數能在篩選資料上可以簡化以往要用很複雜的公式才能完成的功能 UNIQUE 顧名思義，根據清單排除重複出現的資料，留下沒有重複的清單 函示的使用方法 =UNIQUE(array,[by_col],[occurs_once]) array 指定套用的清單範圍 by_col: 設定比較條件，根據 row 時為 FALSE，根據 col 時為 TRUE occurs_once: 設定 True 時，只會顯示出現一次的項目，設定 False 時，顯示不重複清單 如果在篩選後的清單中，誤輸入不存在的項目時，會出現 #SPILL! 的錯誤訊息 排除的方法是將顯示的文字刪除後即可恢復正常 SORT =SORT(array, [sort_index], [sort_order],[by_col]) array: 設定要排序的清單 [sort_order]: 排序欄位的 index (起於 index 1) [sort_order]: 排序方法，1 : 遞增; -1: 遞減 [by-col]: 設定比較條件，根據 row 時為 FALSE，根據 col 時為 TRUE 如果 Array 是動態產生出來的，可以搭配 # 使用 (Dynamic Array Reference)，這樣子當動態清單長度改變時，函示所使用的清單範圍也會跟著改變 FILTER FILTER 提供動態過濾資料來源的功能，過濾的清單的欄位會跟資料來源一樣，而且是動態的列出清單。 =FILTER(資料來源，資料來源內要比較的欄位) RANDARRAY =RANDARRAY([row],[col]) 回傳設定介於 0 和 1 之間的亂數陣列清單 SEQUENCE =SEQUENCE(row,[col],[start],[step]) 根據設定產生數字序列表 row: 列數 col: 行數 start: 起始數字 step: 間隔數字 還有另外兩個 SINGLE 與 SORTBY 有興趣的也可以參閱官方文件， 要請留意的是，本篇文章所介紹的功能，在這個時間點(2018/10/30) 都還是屬於 insider 的範圍內，尚未正式釋出到正式版中 參考文件 SORTBY SINGLE]]></content>
      <categories>
        <category>O365</category>
      </categories>
      <tags>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] RouterModule Options 篇]]></title>
    <url>%2F2018%2F10%2F29%2Fangular-router-config%2F</url>
    <content type="text"><![CDATA[Angular 的路由功能很強大，內建也提供很多路由上會用到的功能，但是你知道 RouterModule 有哪些選項可以設定嗎? RouterModule 選項 enableTracing enabledTracing 可以開啟路由變更時的所有事件，並 console.log 出來，設定方式是 enabledTracking: true useHash 有時候主機環境不允許我們設定 rewrite URL 規則時，就必須使用 hash 的方式來呈現網址的變化，設定方式是 useHash: true initialNavigation 設定初始路由瀏覽是否要開啟，設定方式 1initialNavigation: true | false | &apos;enabled&apos; | &apos;disabled&apos; | &apos;legacy_enabled&apos; | &apos;legacy_disabled&apos;; true、false 、legacy_enabled 、legacy_disabled 在 Angular v4 時就被標示為 deprecated enabled: 在 root component 建立前，會先開始初始瀏覽事件，在初始瀏覽事件未完成前，整個啟動流程會被 block 住 disabled: initial navigation 不會被執行，但是監聽 location 會在 root component 建立前設定好 errorHandler 可以指定路由發生錯誤時，應該要如何處理的，設定自己的錯誤處理程序 errorHandler: ErrorHandler 1234567891011121314function treatCertainErrorsAsCancelations(error) &#123; if (error isntanceof CancelException) &#123; return false; //cancelation &#125; else &#123; throw error; &#125;&#125;@NgModule(&#123; imports: [RouterModule.forRoot(ROUTES, &#123; errorHandler: treatCertainErrorsAsCancelations &#125;)]&#125;)class MailModule &#123;&#125; preloadingStrategy 設定 preloading 策略，針對延遲載入模組的相關處理動做，詳細細節可以參閱 PreloadingStrategy onSameUrlNavigation 當瀏覽到相同網址時的處理行為，設定方式 onSameUrlNavigation: 'reload' | 'ignore' 預設的行為是當遇到相同網址時，並不會重新觸發重整動作，當有需要重整動作時，可以設定為 reload 12345678910111213141516171819export class Page2Component implements OnInit, OnDestroy &#123; constructor(private router: Router) &#123; this.router.events.subscribe((event) =&gt; &#123; if (event instanceof NavigationEnd) &#123; console.log(event); // when onSameUrlNavigation: 'reload'，會重新觸發 router event &#125; &#125;); &#125; ngOnInit() &#123; console.log('page2 init') &#125; ngOnDestroy() &#123; console.log('page2 destroy') &#125;&#125; 這部分需要留意的是，只有 router 事件會被重新執行一次，而非整個 Component 被 destroy 掉在重新建立 scrollPositionRestoration scrollPositionRestoration?: 'disabled'|'enabled'|'top'; 當開啟時，在操作瀏覽器上下頁時，會保留之前瀏覽畫面的位置 anchorScrolling anchorScrolling: 'disabled': 'enabled' 目前預設值為 disabled，當開啟時，會有 anchor 的效果 1&lt;li&gt;&lt;a routerLink="/page2" [fragment]="'a'"&gt;Page 2 with anchor A&lt;/a&gt;&lt;/li&gt; 這樣的連結會跳到 page2 頁 id='2' 的地方 scrollOffset 設定 scroll offset 的值，可以給予數字，或是 function 1scrollOffset?: [number, number]|(() =&gt; [number, number]); [number, number] =&gt; [left, top] 這背後其實是去執行 ViewportScroller 的 setOffset 的方法，當進行 scrollToElement 時，會將設定的 offset 值帶入進算 1234567private scrollToElement(el: any): void &#123; const rect = el.getBoundingClientRect(); const left = rect.left + this.window.pageXOffset; const top = rect.top + this.window.pageYOffset; const offset = this.offset(); this.window.scrollTo(left - offset[0], top - offset[1]);&#125; paramsInheritanceStrategy paramsInheritanceStrategy?: 'emptyOnly'|'always'; 設定路由 params 、data、resolve data 的合併方式 emptyOnly 預設值，只會繼承沒有 path 或是 component 設定的路由 12345&#123; path: 'page3/:id', children: [ &#123; path: 'b', component: Page3Component &#125; // 取得到 id ] &#125; 1234567&#123; path: 'page3/:id', component: EmptyComponent, children: [ &#123; path: 'b', component: Page3Component &#125; // 取不到 id ] &#125;, always 一律繼承 1234567&#123; path: 'page3/:id', component: EmptyComponent, children: [ &#123; path: 'b', component: Page3Component &#125; // 取得到 id ]&#125;, urlUpdateStrategy 何時更新瀏覽器 URL urlUpdateStrategy?: 'deferred'|'eager'; deferred 預設值，當路由事件跑完後才會更新瀏覽器網址 eager 在事前開始前更新瀏覽器網址 malformedUriErrorHandler 當網址瀏覽發生錯誤時，可以自訂 redirect 網址 123malformedUriErrorHandler: // redirects the user to `/invalid-uri` (error: URIError, urlSerializer: UrlSerializer, url: string) =&gt; urlSerializer.parse('/invalid-uri') 亮點設定 onSameUrlNavigation scrollPositionRestoration anchorScrolling paramsInheritanceStrategy 這些選項設定是我認為在開發時，有可能會用的到的選項。 參考資料 範例程式碼 Angular Source Code What’s new in Angular 6.1?]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Secondary routes]]></title>
    <url>%2F2018%2F10%2F24%2Fangular-secondary-routes%2F</url>
    <content type="text"><![CDATA[一般的情況下，&lt;router-outlet&gt; 一組就已足夠，但當畫面的複雜度提高，使用一個 &lt;router-outlet&gt; 可能會讓程式碼的可維護性降低，如果能在多幾組 &lt;router-outlet&gt; 該有多好。而 Angular 的 &lt;router-outlet&gt; 確實支援此功能。 基本 將 &lt;router-outlet&gt; 賦予 name 的值，就可以創造出第二組或是多組的 routes。但有幾下幾點要注意 每一組 routes 是獨立的。 可以結合其他路由使用 會顯示在指定的 names outlet 裡 設定 Routes 但要怎麼設定使用呢? 首先針對路由設定的部分 12345&#123; path: 'compose', component: ComposeMessageComponent, outlet: 'popup'&#125;, outlet: 設定所歸屬的 names outlet，可以多組 連結寫法 網頁上連結的寫法 1&lt;a [routerLink]="[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]"&gt;Contact&lt;/a&gt; 網址列的樣子會是這樣子呈現的 1.../details(popup: compose) 在更複雜一點，假設有多個 names routes 時，又需要怎麼寫，即網址會怎麼呈現呢? 1&lt;a [routerLink]="[&#123; outlets: &#123; popup: ['compose'], detail: ['detail'] &#125; &#125;]"&gt;Contact&lt;/a&gt; 1.../details(popup:compose//detail:detail) 清空 secondary routes 要如何清除呢? 單純的將 outlets 裡的 names 指定的路徑清空即可 1&lt;a [routerLink]="[&#123; outlets: &#123; popup: null &#125; &#125;]"&gt;Contact&lt;/a&gt; 12345closePopup() &#123; // Providing a `null` value to the named outlet // clears the contents of the named outlet this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);&#125; 更多的細節，可以參考我準備稍微複雜的範例程式碼，連結在此]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 與 O365 跳舞系列 - MAIL]]></title>
    <url>%2F2018%2F10%2F20%2Fangular-with-o365-2%2F</url>
    <content type="text"><![CDATA[一旦登入成功後，接下來的工作就比較簡單了，因為查詢的 endpoint 都是一樣的，所以只需要在意後面所傳項目的變化即可，而這篇筆記包含了取得信件資料夾，信件清單，寄信等動作 取得郵件資料夾 權限需求：需要 Mail.Read 呼叫URL： 12GET /me/mailFoldersGET /users/&#123;&#123;id | userPrincipalName&#125;&#125;/mailFolders 回傳資料結構 123456789101112&#123; "value": [ &#123; "displayName": "displayName-value", "parentFolderId": "parentFolderId-value", "childFolderCount": 99, "unreadItemCount": 99, "totalItemCount": 99, "id": "id-value" &#125; ]&#125; id 是查詢該資料夾下信件時所需要的資訊 取得郵件列表 權限需求：需要 Mail.Read 呼叫URL： 12GET /me/mailFolders/&#123;id&#125;/messagesGET /users/&#123;userId | userPrincipalName&#125;/mailFolders/&#123;id&#125;/messages id 為資料夾 ID 回傳資料結構 回傳為 Message 的資料集 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "value": [ &#123; "bccRecipients": [&#123;"@odata.type": "microsoft.graph.recipient"&#125;], "body": &#123;"@odata.type": "microsoft.graph.itemBody"&#125;, "bodyPreview": "string", "categories": ["string"], "ccRecipients": [&#123;"@odata.type": "microsoft.graph.recipient"&#125;], "changeKey": "string", "conversationId": "string", "createdDateTime": "String (timestamp)", "flag": &#123;"@odata.type": "microsoft.graph.followupFlag"&#125;, "from": &#123;"@odata.type": "microsoft.graph.recipient"&#125;, "hasAttachments": true, "id": "string (identifier)", "importance": "String", "inferenceClassification": "String", "internetMessageHeaders": [&#123;"@odata.type": "microsoft.graph.internetMessageHeader"&#125;], "internetMessageId": "String", "isDeliveryReceiptRequested": true, "isDraft": true, "isRead": true, "isReadReceiptRequested": true, "lastModifiedDateTime": "String (timestamp)", "parentFolderId": "string", "receivedDateTime": "String (timestamp)", "replyTo": [&#123;"@odata.type": "microsoft.graph.recipient"&#125;], "sender": &#123;"@odata.type": "microsoft.graph.recipient"&#125;, "sentDateTime": "String (timestamp)", "subject": "string", "toRecipients": [&#123;"@odata.type": "microsoft.graph.recipient"&#125;], "uniqueBody": &#123;"@odata.type": "microsoft.graph.itemBody"&#125;, "webLink": "string", "attachments": [&#123;"@odata.type": "microsoft.graph.attachment"&#125;], "extensions": [&#123;"@odata.type": "microsoft.graph.extension"&#125;], "multiValueExtendedProperties": [&#123;"@odata.type": "microsoft.graph.multiValueLegacyExtendedProperty"&#125;], "singleValueExtendedProperties": [&#123;"@odata.type": "microsoft.graph.singleValueLegacyExtendedProperty"&#125;] &#125; ]&#125; 上下頁 由於每次取回來的資料只有 10 筆(預設值)，所以必須透過 skip 的方式來取得之後頁數的信件清單 呼叫URL： 12GET /me/mailFolders/&#123;id&#125;/messages?$skip=&lt;number&gt;GET /users/&#123;userId | userPrincipalName&#125;/mailFolders/&#123;id&#125;/messages?$skip=&lt;number&gt; id 為資料夾 ID number：以 10 為單位 這是我寫的範例程式 1234567891011121314151617181920212223242526272829303132333435363738mailQuery$ = new BehaviorSubject&lt;&#123; mailFolderId: string; skip: number &#125;&gt;(&#123; mailFolderId: '', skip: 0&#125;); mails$ = this.mailQuery$.pipe( filter((&#123; mailFolderId, skip &#125;) =&gt; !!mailFolderId), switchMap((&#123; mailFolderId, skip &#125;) =&gt; this.graphHelper.query( `mailfolders/$&#123;mailFolderId&#125;/messages?$skip=$&#123;skip&#125;` ) ), map((data: any) =&gt; data.value) );getMail(id: string) &#123; this.mailQuery$.next(&#123; ...this.mailQuery$.value, mailFolderId: id, skip: 0 &#125;);&#125;nextPage() &#123; this.mailQuery$.next(&#123; ...this.mailQuery$.value, skip: this.mailQuery$.value.skip + 10 &#125;);&#125;prevPage() &#123; if (this.mailQuery$.value.skip &gt;= 10) &#123; this.mailQuery$.next(&#123; ...this.mailQuery$.value, skip: this.mailQuery$.value.skip - 10 &#125;); &#125;&#125; OData 在上下頁功能時，我們看到有 $skip 的參數出現，在細看文件後，發現 Graph API 其實也有支援 OData 的查詢語法，這表示我們可以透過 OData 的查詢語法來改變 API 的回傳結果。 例如，我想要一次取回 25 封信件內容，因為預設是一次取 10 筆，這時就需要搭配 $top 的設定來改變。或是說取回來資料欄位太多，我只需要特定的幾個欄位就可以，就可以使用 $select 的方式來做設定，更多的資訊可以看文件 (列在參考文件中) 寄信 權限需求：需要 Mail.Send 呼叫URL： 12POST /me/sendMailPOST /users/&#123;id | userPrincipalName&#125;/sendMail 送出資料結構: 123456789101112131415161718192021222324&#123; "message": &#123; "subject": "Meet for lunch?", "body": &#123; "contentType": "Text", // 'Text' | 'HTML' "content": "The new cafeteria is open." &#125;, "toRecipients": [ &#123; "emailAddress": &#123; "address": "fannyd@contoso.onmicrosoft.com" &#125; &#125; ], "ccRecipients": [ &#123; "emailAddress": &#123; "address": "danas@contoso.onmicrosoft.com" &#125; &#125; ] &#125;, "saveToSentItems": "false"&#125; message 為 Message 型別 saveToSentItems 設定是否要存儲至寄件備份中 回傳結果 1HTTP/1.1 202 Accepted 心得 至於其他的相關操作，基本上與上述的大同小異，大家可以自己試試看 參考文件 官方文件 Message Type Use query parameters to customize responses]]></content>
      <categories>
        <category>Angular</category>
        <category>O365</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 與 O365 跳舞系列 - 登入]]></title>
    <url>%2F2018%2F10%2F20%2Fangular-with-o365-1%2F</url>
    <content type="text"><![CDATA[身為微軟 MVP，沒將 Angular 與 O365 做整合，好像說不過去。Microsoft O365 系列，其生態系其實算是很完整了，也提供了相當不錯的 API 供開發者做延伸應用。基於這個理由，我也決定要來玩看看 O365 了。但在開始之前，要先搞定登入 MS 帳號並取得通行 Token。所以這篇筆記就是記錄如何登入並取得 Token. 環境準備 在開發之前，需要先到微軟的 Application Registration Portal 新增應用程式並取得應用程式識別碼。操作步驟如下 (2019/7/26) 目前註冊應用程式的方法 登入 Azure portal 前往 Azure Active Directory 點選【應用程式註冊】 依自己的需求選擇註冊位置 註冊要新增的內容與舊有的註冊流程類似，可以參閱下面的填寫內容 (以下步驟失效) 登入 MS 帳號 按 【新增應用程式】 輸入應用程式名稱 新增【平台】 選擇 Web 設定【重新導向 URL】，這裡必須設定正確，不然會出現無法操作的錯誤畫面。因為我們會使用 Angular 做開發，預設的網址是 http://localhost:4200 。 將應用程式識別碼先記錄起來，待會會用到 最後，按下【儲存】即完成第一步的設定 Angular 部分 完成了新增應用程式並取得應用程式識別碼後，就可以開始來寫 Angular 的部分了。這次會使用到 msal 這個套件 (npm套件位置) The MSAL library preview for JavaScript is the core library which enables JavaScript web applications to authenticate enterprise users using Microsoft Azure Active Directory (AAD), Microsoft account users (MSA), users using social identity providers like Facebook, Google, LinkedIn etc. and get access to Microsoft Cloud OR Microsoft Graph. 基本環境設定 建立 Angular 專案 ng new &lt;project name&gt; 安裝 msal 套件 npm install msal 新增一個 service ，等一下會將登入的相關邏輯寫在這個 service 內，名稱自取 在 environment.ts 內新增一個 APPLICATION_CONFIG ，內放要給 msal 使用的設定檔 1234567APPLICATION_CONFIG: &#123; clientID: '放剛剛記下來的應用程式識別碼', redirectUri: 'http://localhost:4200/', interactionMode: 'popUp', graphEndpoint: 'https://graph.microsoft.com/v1.0/me', graphScopes: ['user.read'] &#125; clientID: 應用程式識別碼 graphScopes: 設定此應用程式需要與使用者請求的授權範圍 使用者登入 service 建立 Msal.UserAgentApplication 12345678910111213141516171819202122import &#123; environment &#125; from '../environments/environment';import * as Msal from 'msal';...export class GraphHelperService &#123; readonly APPLICATION_CONFIG = environment.APPLICATION_CONFIG; private clientApplication: Msal.UserAgentApplication; constructor(private http: HttpClient) &#123; this.clientApplication = this.createApplication(); this.clientApplication.handleRedirectCallback((error, response) =&gt; &#123; // handle redirect response or error &#125;); &#125; private createApplication() &#123; const msalConfig = &#123; auth: &#123; clientId: this.APPLICATION_CONFIG.clientID &#125; &#125;; return new Msal.UserAgentApplication(msalConfig); &#125;&#125; 建立 login() 方法 1234567891011121314151617181920212223242526272829303132333435363738login() &#123; const acquireTokenSilent = () =&gt; from( this.clientApplication.acquireTokenSilent(&#123; scopes: this.APPLICATION_CONFIG.graphScopes &#125;) ); const acquireTokenPopup = () =&gt; from( this.clientApplication.acquireTokenPopup(&#123; scopes: this.APPLICATION_CONFIG.graphScopes &#125;) ).pipe( catchError(error =&gt; &#123; window.alert('Error acquiring the popup:\n' + error); return EMPTY; &#125;) ); from(this.clientApplication.loginPopup(&#123;scopes:this.APPLICATION_CONFIG.graphScopes&#125;)) .pipe( mergeMap(token =&gt; &#123; return acquireTokenSilent().pipe( catchError(err =&gt; acquireTokenPopup()) ); &#125;) ) .subscribe( accessToken =&gt; &#123; localStorage.token = accessToken; window.location.reload(); &#125;, error =&gt; &#123; window.alert('Error during login:\n' + error); &#125; ); &#125; loginPopup 會開啟一個邀情登入微軟帳號的畫面，輸入完帳號密碼時，會進入下一個步驟 acquireTokenSilent : 取得 accessToken 再將取到的 accessToken 存入到 localStorage 內 將整個畫面重整 (這個動作可以替換成更合適的行為) 建立 logout() 方法，這個比較簡單 12345logout() &#123; this.clientApplication.logout(); delete localStorage.token; delete localStorage.user;&#125; 直接呼叫 logout() 方法 刪除儲存在 localStorage 內的相關資訊 component 當 Service 建立完成後，我們就可以在 Component 的地方使用該 service 做使用者登入的動作了 123456789101112export class AppComponent implements OnInit &#123; ... constructor(private graphHelper: GraphHelperService) &#123;&#125; login() &#123; this.graphHelper.login(); &#125; logout() &#123; this.graphHelper.logout(); &#125;&#125; 取得使用者資訊 當成功登入後，我們就可以利用取得的 accessToken 來使用 MS Graph，什麼是 MS Graph ？MS Graph 是一個可以使用 Microsoft 365 服務的 API，透過這個 API 可以存取使用 O365 的服務內容，例如信件、行事曆、OneDrive 等。 這篇筆記，先來做個基本資料的取得，如帳號的顯示名稱跟 Email service 可以透過呼叫 https://graph.microsoft.com/v1.0/me 來取得登入帳號的基本資訊 123456789me() &#123; const header = new HttpHeaders().append( 'Authorization', `Bearer $&#123;localStorage.token&#125;` ); return this.http.get('https://graph.microsoft.com/v1.0/me', &#123; headers: header &#125;);&#125; component 呼叫 service 的 me() 12345this.graphHelper.me().subscribe(user =&gt; &#123; localStorage.setItem('user', JSON.stringify(user)); this.displayName = user.displayName; this.emailAddress = user.mail || user.userPrincipalName;&#125;); 如果想要進一步知道取回來使用者資料有哪些項目，可以使用 console.log 的方法觀看 Recap 當正常登入後，就可以使用 Graph REST API 了。O365 的服務種類很多，可以透過延伸服務創造出另外一種的應用程式。但相關的開發文件又不多，所以在多次撞牆後，還是覺得將過程記錄起來，方便其他有興趣的人可以少走一些路。 參考資料 npm-msal Graph REST API v1.0 reference Users API]]></content>
      <categories>
        <category>Angular</category>
        <category>O365</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>O365</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Akita 第一次接觸]]></title>
    <url>%2F2018%2F10%2F14%2Fangular-akita-first-impression%2F</url>
    <content type="text"><![CDATA[沒錯，又是另外一套 Angular 狀態管理的工具，這一套 Akita 根據介紹，是融合 Flux + Redux + RxJS 以 OOP 的方式呈現。有別於其他 Redux 風格的狀態管理，是以 FP 的方式完成，就來嘗鮮看看，多一種選擇也不錯 介紹 什麼是 Akita，Akita 是結合多家的精神，以物件導向的方格完成的狀態管理工具，減少產稱不必要的程式碼，讓習慣物件導向開發模式的人，也可以享受 Flux 風格的狀態管理方式 安裝 Akita 12345yarn add @datorama/akita或是npm install @datorama/akita 基本元素 (以下範例皆來自官方文件) Model Model 是用來描述 Store 內資料存放的結構。 12345678910111213141516171819import &#123; ID &#125; from '@datorama/akita';export type Session = &#123; id: ID; firstName: string; lastName: string; token: string;&#125;;export function createSession(&#123; id = null, firstName = '', lastName = '', token = ''&#125;: Partial&lt;Session&gt;) &#123; return &#123; id, firstName, lastName, token &#125;;&#125;; 官方建議新增 type 和 factory function ，讓其負責 store 初始值的建立 Store Store 是一個用來記載狀態的一個物件，建立一個 store 物件繼承 Akita Sotre 並傳入型別(Model) 被給予初始值 12345678910111213141516171819import &#123; Store, StoreConfig &#125; from '@datorama/akita';import &#123; Session &#125; from './session.model';export interface SessionState &#123; token: string;&#125;export function createInitialState(): SessionState &#123; return &#123; token: '' &#125;;&#125;@StoreConfig(&#123; name: 'session' &#125;) // 在 store 要存放的名字export class SessionStore extends Store&lt;SessionState&gt; &#123; constructor() &#123; super(createInitialState()); &#125;&#125; 當建立 store 後，當在 service 使用時，可以透過 setState 的方式來更新 store 內的狀態 1setState(newStateFn: (state: Readonly&lt;S&gt;) =&gt; S) 使用範例: 12345678910111213141516171819import &#123; SessionStore &#125; from './session.store';import &#123; SessionDataService &#125; from './session-data.service';export class SessionService &#123; constructor(private sessionStore: SessionStore, private sessionDataService: SessionDataService) &#123;&#125; login(creds) &#123; this.sessionDataService.login(creds).subscribe(user =&gt; &#123; this.sessionStore.setState(state =&gt; &#123; return &#123; ...state, ...createSession(user) &#125; &#125;); &#125;); &#125;&#125; setState 的做法比較像是 redux 風格的 reducer，而 Akita 有提供另外一種方法可以快速地更新 Store 的值， 可透過 update 的方法來完成，update(newState: Partial&lt;S&gt;) 1234567891011121314import &#123; SessionStore &#125; from './session.store';import &#123; SessionDataService &#125; from './session-data.service';export class SessionService &#123; constructor(private sessionStore: SessionStore, private sessionDataService: SessionDataService) &#123;&#125; login(creds) &#123; this.sessionDataService.login(creds).subscribe(user =&gt; &#123; this.sessionStore.update(createSession(user)); &#125;); &#125;&#125; update 也可以接受 callback 方法。(詳情請閱讀官方文件) 也有其他的方法可以使用 setLoading(isLoading: boolean) : 設定 store 的讀取狀態 setError(error: any) 設定 store 的錯誤狀態 Service Service 內的使用與一般在寫 Service 是一樣的，只是要將 store class 注入到 service 內使用 12345678910111213import &#123; SessionStore &#125; from './session.store';import &#123; SessionDataService &#125; from './session-data.service';export class SessionService &#123;constructor(private sessionStore: SessionStore) &#123;&#125;login(creds) &#123; http.login(creds).subscribe(user =&gt; &#123; this.sessionStore.update(createSession(user)); &#125;); &#125;&#125; Query Akita 的 Query 的地位，等同於 ngrx 的 selector，是用來撈取 Store 使用，回傳的型別為 Observable 123456789import &#123; Query &#125; from '@datorama/akita';export class SessionQuery extends Query&lt;Session&gt; &#123; isLoggedIn$ = this.select(session =&gt; !!session.token); constructor(protected store: SessionStore) &#123; super(store); &#125;&#125; 當繼承 Query&lt;T&gt; 時，會擁有 select&lt;R&gt;(project?: (store: S) =&gt; R): Observable&lt;R&gt; 的方法可以使用，雖然在 component 可透過 select 的方式讀取 store 的狀態，但一般建議是寫在 Query Class 內部，以方便重複使用 select() 方法回傳的 Observable 是會執行 distinctUntilChanged() 的，這表示該 select 只會當有資料異動時才會被觸發 selectOnce() 行為類似於 select() ，但只會被觸發一次 1this.query.selectOnce(state=&gt; state.key); getSnapshot() 回傳 store 的 raw value 1this.query.getSnapshot(); selectLoading() : 取得 store 的 loading 狀態 selectError() 取得 store 的錯誤狀態 感想 雖然少了許多不必要的程式碼跟流程，但操作的複雜度似乎需要多花點時間研究，主要是 API 部分需要熟悉，這動作能不能自己刻，這當然是可以的，但透過學習其他的狀態管理工具並了解其背後的設計原理，也是有很大的幫助的。 單純就基本結構元素來看，Akita 所提供的 store 是比較關鍵的功能，其他的操作應該是大同小異。初步看來，真正的應用應該會是在 Entity 的地方，如何上用 Entity 來管理複雜的狀態會是需要思考的部分。 至於實際上怎麼使用，可以先參考這篇文章，先抓個感覺 參考資料 官方文件]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Component Host Style]]></title>
    <url>%2F2018%2F10%2F14%2Fangular-host-style%2F</url>
    <content type="text"><![CDATA[Angular 內有提供針對 Component 本體樣式描述的特別語法，分別是 :host 與 :host-context 這兩者使用，可以讓 Component 的樣式更模組化。而這篇文章就針對這兩者的用法做說明 :host :host 可用來描述本體 component 的樣式呈現方式，例如 12345:host&#123; display: block; height: 100px; background: grey;&#125; 這樣就可以針對 Component 本身做樣式設定 如果想要透過外部做額外的樣式複寫，這時候可以搭配 :host(selector) 的方式做設定 123:host(.active)&#123; background: red;&#125; 外部 html 的部分，當加上 class=&quot;active&quot; 時，就會套用此樣式規則 1&lt;app-counter class="active"&gt;&lt;/app-counter&gt; :host-context 進一步來看，如果想要依更外層的 class 來做判斷呢? 這時候可以使用 :host-context(selector) 的方式做設定 123:host-context(.theme-light) &#123; background-color: #eef;&#125; 123&lt;div class="theme-light"&gt; &lt;app-counter class="active"&gt;&lt;/app-counter&gt;&lt;/div&gt; 套用順序 :host 與 :host-context 的樣式會依 css 優先權規則套用。 參考資料 範例程式]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#] Collection]]></title>
    <url>%2F2018%2F10%2F04%2Fcsharp-collection%2F</url>
    <content type="text"><![CDATA[C# 的集合種類有很多種，每一種集合都有不同的特性，趁著在看 ImmutableList 將這個區塊的資訊整理一下。C# 跟及何有關的命名空間，都會放在 System.Collections 下 集合的種類 System.Collections 因為不指定型別，所以都會以 Object 的類型儲存，常用的類別有 類別 描述 ArrayList 會視需要動態增加大小的物件陣列。(對應 List) Hashtable 根據索引鍵的雜湊程式碼，所整理的索引鍵/值組集合 (對應 Dictionary) Queue 具有先進先出(FIFO)特性的清單 Stack 具有先進後出(LIFO)特性的清單 System.Collections.Generic 在這一個命名空間下的集合都屬泛型集合，常見的有 類別 描述 Dictionary&lt;TKey, TValue&gt; KeyValue Pair 集合 List&lt;T&gt; 依照索引存取的物件清單，可搜尋、排序、修改 Queue&lt;T&gt; 具有先進先出(FIFO)特性的清單 SortedList&lt;TKey, TValue&gt; 根據 Key 值排序的 KeyValue 集合 Stack&lt;T&gt; 具有先進後出(LIFO)特性的清單 System.Collections.Concurrent 針對多執行緒情境所設計的集合，包含 BlockingCollection&lt;T&gt; 、ConcurrentDictionary&lt;TKey, TValue&gt; 、ConcurrentQueue&lt;T&gt; 和 ConcurrentStack&lt;T&gt; System.Collections.Immutable 涉及多個執行緒時，要控制好可變狀態會是個挑戰。 一般作法是利用可在不同執行緒之間自由傳遞的不可變狀態。 不可變的集合不同於唯讀集合，因為集合的提供者或消費者無法變更不可變的集合，這點和唯讀集合並不相同。 例如，如果您要列舉唯讀集合，該集合有可能會在其他執行緒上變更，而導致資料損毀。 如果您是使用不可變的集合，就不會發生這種情形。 根據 MSDN 的說明，使用不可變的集合有以下的優點 安心共用集合，消費者可以確保集合永遠不會變更。 在多執行緒應用程式中提供隱含的執行緒安全性 (不需要鎖定，即可存取集合)。 依照函式程式設計作法進行。 在列舉期間修改集合，並可確保原始集合不會變更。 一樣有上述的 List、Dictionary、HashSet 等集合，只是變成 ImmutableList&lt;T&gt;、ImmutableDictionary&lt;TKey, TValue&gt;、ImmutableHashSet&lt;T&gt;。 各集合的詳細說明 ArrayList 透過新增、移除，可以動態改變陣列大小。實作 IList 界面 範例程式碼 12345 // Creates and initializes a new ArrayList.ArrayList myAL = new ArrayList();myAL.Add("Hello");myAL.Add("World");myAL.Add("!"); 關於 ArrayList，有些事情是需要知道的 設計用來保存物件的異質集合，不保證最佳效能，官方建議使用 List&lt;Object&gt; 效能討論，可參閱 List 主題 不保證排序，需透過 Sort 的方式來進行排序，如果要確保順序，使用 SortedSet&lt;T&gt; 類別 由於是動態產生，所以每一次增加 ArrayList 數量都會重新配置(指增不減)，為了減少使用空間，使用 TrimToSize 或是明確指定陣列大小，可以解決空間浪費的問題 可透過整數索引取值，從 0 開始 接受 null 並可以重複 不支援多維 需透過 Cast&lt;T&gt; 才可以使用 Linq 1myAL.Cast&lt;string&gt;().FirstOrDefault(x =&gt; x == &quot;!&quot;); Hashtable 根據索引鍵的雜湊程式碼，所整理的索引鍵/值組集合 範例程式 12345Hashtable openWith = new Hashtable();openWith.Add("txt", "notepad.exe");openWith.Add("bmp", "paint.exe");openWith.Add("dib", "paint.exe");openWith.Add("rtf", "wordpad.exe"); 關於 Hashtbale，有些事情是需要知道的 Key 不能是 null Key 值物件必須是不可變的 foreach 取的值是 DictionaryEntry 型別，只允許讀取 (read only) 1234foreach(DictionaryEntry de in myHashtable)&#123; // ...&#125; Queue 先進先出 (FIFO) 集合 範例程式 123456789101112Queue myQ = new Queue();myQ.Enqueue("Hello");myQ.Enqueue("World");myQ.Enqueue("!");WriteLine(myQ.Peek()); // HellomyQ.Dequeue(); // 移除 HelloWriteLine(myQ.Peek()); // WorldmyQ.Dequeue(); // 移除 WorldWriteLine(myQ.Peek()); // !myQ.Dequeue(); // 移除 !WriteLine(myQ.Peek()); // 出現錯誤，因為 Queue 已經是 Empty 了 關於 Queue，有些事情是需要知道的 三個主要作業 Enqueue : 新增至結尾 Dequeue: 移除最舊的項目 Peek: 傳回最舊的項目 可透過 TrimToSize 來節省沒在使用的配置空間 允許 null 並允許重複項目 Stack 後進先出 (LIFO) 非泛型集合 範例程式 12345678910111213// Creates and initializes a new Stack.Stack myStack = new Stack();myStack.Push("Hello");myStack.Push("World");myStack.Push("!");WriteLine(myStack.Count); // 3WriteLine(myStack.Pop()); // !WriteLine(myStack.Count); // 2WriteLine(myStack.Peek());// WorldWriteLine(myStack.Count); // 2WriteLine(myStack.Pop()); // WorldWriteLine(myStack.Count); // 1 關於 Stack，有些事情是需要知道的 三個主要作業 Push : 將物件插入 Stack 的頂端。 Pop: 移除並傳回在 Stack 頂端的物件 Peek: 傳回 Stack 頂端的物件而不需移除它 List&lt;T&gt;的延伸 List 可以透過方法來轉換成不同的集合類型，而其中的 ReadOnlyCollection 與 ImmutableList 我比較想拿出來比較 這兩著在本質上還是有差異的，範例程式 12345678910111213141516171819var list = new List&lt;string&gt;() &#123; "a", "b" &#125;;var readonlyList = list.AsReadOnly();var immutableList = list.ToImmutableList();WriteLine("List Count: " + list.Count); // 2WriteLine("ReadonlyList Count: " + readonlyList.Count); // 2WriteLine("ImmutableList Count: " + immutableList.Count); // 2list.Add("c");WriteLine("List Count: " + list.Count); // 3WriteLine("ReadonlyList Count: " + readonlyList.Count); // 3WriteLine("ImmutableList Count: " + immutableList.Count); // 2immutableList = immutableList.Add("3");WriteLine("List Count: " + list.Count); // 3WriteLine("ReadonlyList Count: " + readonlyList.Count); // 3WriteLine("ImmutableList Count: " + immutableList.Count); // 3 根據上面的執行結果，我們可以得知，一但轉換成 ImmutableList 時，就與原本的 List 是脫離關係的，不論原本的集合做怎樣的變更，ImmutableList 都不會改變。但 ReadonlyCollection 卻不是這樣，ReadonlyCollection 會跟 List 一起連動。只是他不能被修改而已。 那什麼時候要用 ReadonlyCollection 什麼時候要用 ImmutableList ? 其實可以看 ImmutableList 的是用情境，就大概知道哪些狀況下要使用 ImmutableList了 結論 C# 內的集合類別很多種，也有針對不同的情境設計實作集合類別，有空的時候，是可以花點時間讀一下官方文件，並熟悉 LINQ 的操作，LINQ 對於集合的操作能力可是很厲害的，可以用少少的程式碼完成很多工作，而且閱讀性也不會太差。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Material Table API 筆記]]></title>
    <url>%2F2018%2F09%2F19%2Fangular-material-table-hidden-api%2F</url>
    <content type="text"><![CDATA[Angular Material Table 很好用，但是文件資訊不足是痛點。整理一些會用的到的 API 。之後可以少一點痛苦 Angular Material Table 可以操作的 selector 大概有以下這些 matTable 預設 ChangeDetection 策略為 onPush trackBy：用法與 *ngFor 的 trackBy 是相同的 dataSource：餵資料給 table，可以餵食的資料格式有三種 Simple data array (each object represents one table row) 如果資料異動，可透過 renderRows() 的方法來處發化面更新 如果是 data array 的參考改變 (assign new array)，則 table 會自動更新。 Stream that emits a data array each time the array changes DataSource object that implements the connect/disconnect interface. multiTemplateDataRows：設定允許多行呈現。預設值為 false 如果設定為 false ，顯示資料的地方只能一行，但可配合 matRowDef 的 when 來決定要顯示哪一個 row 設定 設定為 true 時，可以多行顯示 123456789101112131415161718192021222324252627282930313233343536&lt;table mat-table [dataSource]="dataSource" class="mat-elevation-z8" multiTemplateDataRows="true"&gt; &lt;!-- Position Column --&gt; &lt;ng-container matColumnDef="position"&gt; &lt;th mat-header-cell *matHeaderCellDef rowspan="2"&gt; No. &lt;/th&gt; &lt;td mat-cell *matCellDef="let element" rowspan="2"&gt; &#123;&#123;element.position&#125;&#125; &lt;/td&gt; &lt;/ng-container&gt; &lt;!-- Name Column --&gt; &lt;ng-container matColumnDef="name"&gt; &lt;th mat-header-cell *matHeaderCellDef colspan="3"&gt; Name &lt;/th&gt; &lt;td mat-cell *matCellDef="let element" colspan="3"&gt; &#123;&#123;element.name&#125;&#125; &lt;/td&gt; &lt;/ng-container&gt; &lt;!-- Weight Column --&gt; &lt;ng-container matColumnDef="weight"&gt; &lt;th mat-header-cell *matHeaderCellDef&gt; Weight &lt;/th&gt; &lt;td mat-cell *matCellDef="let element"&gt; &#123;&#123;element.weight&#125;&#125; &lt;/td&gt; &lt;/ng-container&gt; &lt;!-- Symbol Column --&gt; &lt;ng-container matColumnDef="symbol"&gt; &lt;th mat-header-cell *matHeaderCellDef&gt; Symbol &lt;/th&gt; &lt;td mat-cell *matCellDef="let element"&gt; &#123;&#123;element.symbol&#125;&#125; &lt;/td&gt; &lt;/ng-container&gt; &lt;!-- Symbol Column --&gt; &lt;ng-container matColumnDef="tt"&gt; &lt;th mat-header-cell *matHeaderCellDef&gt; Symbol &lt;/th&gt; &lt;td mat-cell *matCellDef="let element"&gt; &#123;&#123;element.symbol&#125;&#125; &lt;/td&gt; &lt;/ng-container&gt; &lt;tr mat-header-row *matHeaderRowDef="['position', 'name']"&gt;&lt;/tr&gt; &lt;tr mat-header-row *matHeaderRowDef="['weight', 'symbol']"&gt;&lt;/tr&gt; &lt;tr mat-row *matRowDef="let row; columns: ['position', 'name'];"&gt;&lt;/tr&gt; &lt;tr mat-row *matRowDef="let row; columns: ['weight', 'symbol']"&gt;&lt;/tr&gt;&lt;/table&gt; matHeaderCellDef 繼承 cdkHeaderCellDef *cdkHeaderCellDef 指定目前所在 element 為要顯示在 header 區塊的內容 matCellDef 會根據 multiTemplateDataRows 決定回傳的內容 true: 回傳 CdkCellOutletMultiRowContext 12345678910111213141516171819202122232425export interface CdkCellOutletMultiRowContext&lt;T&gt; &#123; /** Data for the row that this cell is located within. */ $implicit?: T; /** Index of the data object in the provided data array. */ dataIndex?: number; /** Index location of the rendered row that this cell is located within. */ renderIndex?: number; /** Length of the number of total rows. */ count?: number; /** True if this cell is contained in the first row. */ first?: boolean; /** True if this cell is contained in the last row. */ last?: boolean; /** True if this cell is contained in a row with an even-numbered index. */ even?: boolean; /** True if this cell is contained in a row with an odd-numbered index. */ odd?: boolean;&#125; false: 回傳 CdkCellOutletRowContext 12345678910111213141516171819202122export interface CdkCellOutletRowContext&lt;T&gt; &#123; /** Data for the row that this cell is located within. */ $implicit?: T; /** Index of the data object in the provided data array. */ index?: number; /** Length of the number of total rows. */ count?: number; /** True if this cell is contained in the first row. */ first?: boolean; /** True if this cell is contained in the last row. */ last?: boolean; /** True if this cell is contained in a row with an even-numbered index. */ even?: boolean; /** True if this cell is contained in a row with an odd-numbered index. */ odd?: boolean;&#125; matHeaderRowDef 繼承 CdkHeaderRowDef columns：要顯示的欄位名稱 sticky: 是否要固定表頭 matRowDef 繼承 CdkRowDef columns：要顯示的欄位名稱 when : 設定要顯示 row 的條件 如果 multiTemplateDataRows 為 false, matRowDef 只能有一個沒有設定 when 1when: (index: number, rowData: T) =&gt; boolean; matColumnDef 繼承 CdkColumnDef name : 設定欄位名稱 sticky 、stickyEnd 可以使用，固定 column 參考資料 Angular Material CDK Table Source Code]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Angular Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Service Worker Update]]></title>
    <url>%2F2018%2F09%2F07%2Fangular-sw-update%2F</url>
    <content type="text"><![CDATA[Angular 所提供的 @angualr/pwa 套件，可以讓我們快速地完成加入 service worker 並建立起 PWA 網站。但由於 service worker 會將內容暫存住，要用怎樣的方法才能讓 service worker 更新暫存內容呢? Angular 很好心的有想到這一部份，提供了內建 API 可以使用。相關的使用方法請繼續閱讀下去 SwUpdate Angular 提供了 SwUpdate 的 service 可以讓我們透過程式碼的方式來更新 service 內容， SwUpdate 包含了四個動作 available：唯讀屬性，Observable&lt;UpdateAvailableEvent&gt; 型別，如果有新版本可以被更新，會發出事件 123456constructor(updates: SwUpdate) &#123; updates.available.subscribe(event =&gt; &#123; console.log('current version is', event.current); console.log('available version is', event.available); &#125;);&#125; activated：唯讀屬性，Observable&lt;UpdateActivatedEvent&gt; 型別，當有新版本被更新時，會發出事件 123456constructor(updates: SwUpdate) &#123; updates.activated.subscribe(event =&gt; &#123; console.log('old version was', event.previous); console.log('new version is', event.current); &#125;); &#125; isEnabled：判斷 service worker 是否有啟動 checkForUpdate()：要求 service worker 檢查是否有新版本可以更新 123constructor(updates: SwUpdate) &#123; interval(6 * 60 * 60).subscribe(() =&gt; updates.checkForUpdate()); &#125; activateUpdate()：要求 service worker 進行新版本更新動作 12345updates.available.subscribe(event =&gt; &#123; if (promptUser(event)) &#123; updates.activateUpdate().then(() =&gt; document.location.reload()); &#125; &#125;); 在文件中，有提到這一個動作可能會讓 lazy-loading 的模組壞掉。 Doing this could break lazy-loading into currently running apps, especially if the lazy-loaded chunks use filenames with hashes, which change every version. 範例 此段程式碼是 Angular Taiwan 2018 活動網站 使用的程式碼，就當作此篇文章的範例程式碼 12345678910111213141516if (this.swUpdate.isEnabled) &#123; this.swUpdate.available.subscribe(() =&gt; &#123; const snackBarRef = this.snackBar.open( this.translate.instant('needUpdate'), '', &#123; duration: 1500, horizontalPosition: 'center', verticalPosition: 'top' &#125; ); snackBarRef.afterDismissed().subscribe(() =&gt; &#123; window.location.reload(); &#125;); &#125;); &#125; 結論 在 angular.io 關於 Service Workers 的內容寫得很詳細，建議大家花點時間閱讀，會對 Service Worker 有更進一步的了解 參考資料 Service worker communication API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] Scheduler]]></title>
    <url>%2F2018%2F08%2F31%2Frxjs-scheduler%2F</url>
    <content type="text"><![CDATA[來探討 RxJS 的 Scheduler 吧 前言 在開始探討 RxJS 的 scheduler 機制之前，要先談談 JavaScript 本身的三個機制 Event Loop 、Micro Task 和 Macro Task。 我們知道 JavaScript 處理 function 的方式是將要執行的 function 放到 stack 中，如果遇到非同步動作時，JavaScript 會將其非同步執行結束後的 callback function 放到 Queue 中，等待 stack 的動作全部完成後(即清空)，再來執行 queue 裡的工作，而將 queue 裡的工作轉到 stack 的人就是 event loop。所以我們可以說 event loop 的工作是監控 stack 與 queue ，並決定什麼時候要將 queue 的工作拉到 stack 內處理。 更多關於 Event loop 運行方式，可以看這個影片 實際上 Event loop 內在分細一點，針對不同的非同步行為，有著執行的優先順序。這裡要介紹 Micro Task 與 Macro Task ，簡單的說，就是將上述的 Queue 在分成兩種 Queue，一個是記載著 Micro Task 的 (這裡我們先稱為 Micro Task Queue)，另外一個是記載著 Macro Task (這裡我們先稱為 Macro Task Queue)。 在每一個事件循環，會先處理記載 Micro Task 的 Queue，然後當 Micro Task Queue 清空後，才會處理 Macro Task Queue 。 那些動作是 Micro Task，哪些又是 Macro Task 呢? Micro Task process.nextTick() promise Object.observe MutaionObserver Macro Task setImmediate setTimeout setInterval 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 執行結果 RxJS Scheduler RxJS 裡面的 Scheduler 有幾種，而我們可以透過改變 scheduler 來改變執行順序。RxJS Scheduler 有以下幾種，還記得我們上面提到的 Micro 和 Macro Task 嗎? 每一個 Scheduler 也有相對應的類別 queueScheduler：Sync queue，將任務放到 queue 中，如果有設定 delay，行為跟 async 一樣 asapScheduler： Micro Task asyncScheduler：Macro Task，與 setTimeout 的相同。 animationFrameScheduler：paint event ，根據每一個 frame 做觸發 讓我們直接來看 code 123456789101112import &#123; of, range, interval, asapScheduler, asyncScheduler, animationFrameScheduler, queueScheduler &#125; from 'rxjs';import &#123; observeOn, subscribeOn &#125; from 'rxjs/operators';// observeOn 可以被使用多次，控制 emissionrange(0, 42).pipe(observeOn(queueScheduler));// subscribeOn 只會被使用一次，控制 subscriptionof(42).pipe(subscribeOn(asapScheduler));// 可用引數的方式設定 scheduler，很容易改變interval(1000, asyncScheduler)interval(0, animationFrameScheduler) scheduler 的執行順序 123456789101112131415161718192021import &#123; of, merge, asapScheduler, asyncScheduler, queueScheduler, animationFrameScheduler &#125; from 'rxjs';import &#123; filter, startWith, observeOn &#125; from 'rxjs/operators';const delay = 0;const async$ = of('async') .pipe(observeOn(asyncScheduler, delay));const asap$ = of('asap') .pipe(observeOn(asapScheduler, delay));const queue$ = of('queue') .pipe(observeOn(queueScheduler, delay));const animate$ = of('animate') .pipe(observeOn(animationFrameScheduler, delay));merge(async$, asap$, queue$, animate$) .pipe(filter(x =&gt; !!x)) .subscribe(console.log);console.log('after subscription') 執行結果 這次，我們將 scheduler 加上 delay 的設定，在看一次跑出來的結果 12345678910111213141516171819202122import &#123; of, merge, asapScheduler, asyncScheduler, queueScheduler, animationFrameScheduler &#125; from 'rxjs';import &#123; filter, startWith, observeOn &#125; from 'rxjs/operators';const delay = 1;const async$ = of('async') .pipe(observeOn(asyncScheduler, delay));const asap$ = of('asap') .pipe(observeOn(asapScheduler, delay));const queue$ = of('queue') .pipe(observeOn(queueScheduler, delay));const animate$ = of('animate') .pipe(observeOn(animationFrameScheduler, delay));merge(async$, asap$, queue$, animate$) .pipe(filter(x =&gt; !!x)) .subscribe(console.log);console.log('after subscription') 執行結果 整個執行順序大改變，十分有趣的結果。根據結果可以推測，當加上 delay 時，全部的 scheduler 都會轉變成 asyncScheduler的行為模式。 其實從原始碼的地方可以看到，AsapScheduler 與 QueueScheduler 都是繼承 AsyncScheduler 來的，AsapScheduler 與 AsyncScheduler 的差異點在於 flush 的實作內容而已 123export class AsapScheduler extends AsyncScheduler &#123;...&#125;export class QueueScheduler extends AsyncScheduler &#123;&#125;export class AsyncScheduler extends Scheduler &#123;...&#125; 而真正觸發的動作都是一樣，在下面的小結會更進一步的探討 scheduler 的執行步驟。 Dive In 底層 scheduler 到底是怎麼運作的，scheduler 會包含 4 個元素 scheduler：建立並執行 action work：一段可以被執行的程式 action：執行 work，回傳 subscription subscription：用來取消 observable Work 一段可以被執行的程式碼 123(state)=&gt; &#123; console.log('state:', state);&#125; Action 建立 Action 可透過 scheduler.schedule(work, delay, state) 的方式，且會根據 delay 決定執行時間，並回傳 subscription 1asyncScheduler.schedule((state)=&gt; console.log(state), 0, 42); Subscription Subscription 是用來取消 Observable 的物件，本身也可以加入其他的 subscription，當本身執行 unsubscription 時，加到本體的其他 subscription 也會執行 unsubscription 1234567const sub = new Subscription();const sub1 = queueScheduler.schedule((state)=&gt; console.log(state), 0, 42);const sub2 = queueScheduler.schedule((state)=&gt; console.log(state), 0, '123');sub.add(sub1);sub.add(sub2);sub.unsubscribe(); Reacp 為什麼要了解 scheduler，透過 scheduler 我們可以寫出很多有趣的東西。使用 work 搭配 scheduler，可以更有彈性的非同步與同步的工作整合在一起，表示並一定要使用 operators，也可以享受 RxJS 的好處 參考資料 observeOn subscribeOn AsyncScheduler.ts AsapScheduler.ts]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 自訂 RxJS Operator]]></title>
    <url>%2F2018%2F08%2F28%2Frxjs-custom-operator%2F</url>
    <content type="text"><![CDATA[RxJS 6.x 使用 pipe 之後，建立 operators 的方法就又更簡單了。不論是重構將部分的動作成一個自訂 operator ，或是整合其他 library 成為另外一個新的 operator，都遠比之前版本簡單，以下提供一些方法及方向供參考 重構抽離 以常見的 autocomplete 的功能來說，以下是範例程式碼 1234567this.clients = this.searchTerms .pipe( debounceTime(300), distinctUntilChanged(), switchMap(term =&gt; this.clientSearchService.search(term)), catchError(error =&gt; of([])) ); 有時候我們可以將幾個動作先抽離成一個單獨的 functions 然後再串接到 pipe 裡面，主要是方便程式碼的閱讀，畢竟太細節的操作步驟並不是我們真的後續維護要看的重點，重構後的程式碼如下 1234567891011const avoidTriggerTooFast = (timeWindow) =&gt; obs =&gt; obs.pipe( debounceTime(timeWindow), distinctUntilChanged(), );this.clients = this.searchTerms .pipe( this.avoidTriggerTooFast(300), switchMap(term =&gt; this.clientSearchService.search(term)), catchError(error =&gt; of([])) ); 重構步驟 建立一個接受一個 Observable 回傳一個 Observable 的 function 將想要抽離的 operators 搬到新方法下 將原本位置替換成新的 function 自訂 Operators 既然重構的起手式是 建立一個接受一個 Observable 回傳一個 Observable 的 function ，那創造出一個新的 operators 也可以跟隨相同的規則 12345678910111213import &#123; Observable, from &#125; from 'rxjs';const multiply = (multiplyBy) =&gt; (source: Observable&lt;any&gt;) =&gt; new Observable(observer =&gt; &#123; return source.subscribe(&#123; next(n) &#123; observer.next(n * multiplyBy); &#125;, error(err) &#123; &#125;, complete() &#123; &#125; &#125;);&#125;);const source$ = from([1, 2, 3]);source$.pipe(multiply(2)).subscribe(console.log); 建立步驟 從 rxjs 取得 Observable 建立一個接受一個 Observable 回傳一個新的 Observable 物件 在 subscribe 處理，next、error 和 complete，將相關的動作對應到上層 (new Observable()) 的 observer 上面是最原始的作法，但我們能發現很多自訂 operators 的動作都是在進行資料轉型，所以我們可以直接透過 map 的 operators 來完成相同的動作 12345678import &#123; Observable, from &#125; from 'rxjs';import &#123; map &#125; from 'rxjs/operators';const multiply = (multiplyBy) =&gt; map((n: number) =&gt; n * multiplyBy);const source$ = from([1, 2, 3]);source$.pipe(multiply(2)).subscribe(console.log); 這樣的寫法，是否乾淨許多。當然其他內建的 RxJS operators 也可以拿來使用 整合 Library 在往進階一點看，如果整合其他的 JS Library 或是自己寫的 helper function 呢? 類似 lodash ， 其實做法都一樣，以下給個範例，應該很快就能掌握住方向， 1234567891011import &#123; from &#125; from 'rxjs';import &#123; filter &#125; from 'rxjs/operators';import _isNumber from 'lodash/isNumber';const isNumber = () =&gt; filter(_isNumber);const source$ = from([1, 2, '3']);source$.pipe( isNumber()).subscribe(console.log); 結論 其實 RxJS 寫到後面，會使用到一些 FP 的開發技巧，趁著這機會，了解一下 FP 的開發模式，對於寫 RxJS 會有很大的幫助。 參考資料 Custom RxJS Operators by Example]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular CLI - angular.json 檔說明]]></title>
    <url>%2F2018%2F08%2F23%2Fangular-json-guide%2F</url>
    <content type="text"><![CDATA[Angular CLI 6 版以後的設定檔大改版，現在終於有時間可以仔細看一下與了解內部是如何運行的。所以就讓我們來看一下 angular.json 檔案吧 angular.json 設定檔 基本設定 $schema ：angular.json 定義檔的位置 version ：版本設定 newProjectRoot： 設定新專案產生的路徑位置 defaultProject： CLI 指令預設執行的 project 名稱 projects：各專案的設定檔設定位置，會在下面章節詳細說明 cli：一些關於 CLI 設定 12345678"cli": &#123; "defaultCollection": "@ionic/schematics-angular", "packageManager": "yarn", "warnings": &#123; "versionMismatch": false, "typescriptMismatch": false &#125; &#125; defaultCollection ：指定預設使用的 schematics 範本 packageManager ：安裝 package 時要使用的套件管理工具，有 npm、cnpm 和 yarn 三種可以設定 warnings ：可設定是否要提示版本不符合的警示訊息 versionMismatch 全域 Angular CLI 版本與本地的版本不同時，是否要顯示提示訊息 typescriptMismatch TypeScript 版本不符合時，是否要顯示提示訊息 schematics：schematics 範本命令預設參數設定位置 12345"schematics": &#123; "@schematics/angular:component": &#123; "changeDetection": 'OnPush' &#125; &#125; schematics-package:schematics-name : 可設定該命令可設定的預設值，以下是 @schematics/angular 常用可設定的命令 @schematics/angular:component 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#123; "inlineStyle": &#123; "description": "Specifies if the style will be in the ts file.", "type": "boolean", "default": false, "alias": "s" &#125;, "inlineTemplate": &#123; "description": "Specifies if the template will be in the ts file.", "type": "boolean", "default": false, "alias": "t" &#125;, "viewEncapsulation": &#123; "description": "Specifies the view encapsulation strategy.", "enum": ["Emulated", "Native", "None"], "type": "string", "alias": "v" &#125;, "changeDetection": &#123; "description": "Specifies the change detection strategy.", "enum": ["Default", "OnPush"], "type": "string", "default": "Default", "alias": "c" &#125;, "prefix": &#123; "type": "string", "format": "html-selector", "description": "The prefix to apply to generated selectors.", "alias": "p" &#125;, "styleext": &#123; "description": "The file extension to be used for style files.", "type": "string", "default": "css" &#125;, "spec": &#123; "type": "boolean", "description": "Specifies if a spec file is generated.", "default": true &#125;, "flat": &#123; "type": "boolean", "description": "Flag to indicate if a dir is created.", "default": false &#125;, "skipImport": &#123; "type": "boolean", "description": "Flag to skip the module import.", "default": false &#125;, "selector": &#123; "type": "string", "format": "html-selector", "description": "The selector to use for the component." &#125;, "module": &#123; "type": "string", "description": "Allows specification of the declaring module.", "alias": "m" &#125;, "export": &#123; "type": "boolean", "default": false, "description": "Specifies if declaring module exports the component." &#125;&#125; @schematics/angular:directive 123456789101112131415161718192021222324252627282930313233343536373839&#123; "prefix": &#123; "type": "string", "format": "html-selector", "description": "The prefix to apply to generated selectors.", "default": "app", "alias": "p" &#125;, "spec": &#123; "type": "boolean", "description": "Specifies if a spec file is generated.", "default": true &#125;, "skipImport": &#123; "type": "boolean", "description": "Flag to skip the module import.", "default": false &#125;, "selector": &#123; "type": "string", "format": "html-selector", "description": "The selector to use for the directive." &#125;, "flat": &#123; "type": "boolean", "description": "Flag to indicate if a dir is created.", "default": true &#125;, "module": &#123; "type": "string", "description": "Allows specification of the declaring module.", "alias": "m" &#125;, "export": &#123; "type": "boolean", "default": false, "description": "Specifies if declaring module exports the directive." &#125;&#125; @schematics/angular:module 12345678910111213141516171819202122232425262728293031323334&#123; "routing": &#123; "type": "boolean", "description": "Generates a routing module.", "default": false &#125;, "routingScope": &#123; "enum": ["Child", "Root"], "type": "string", "description": "The scope for the generated routing.", "default": "Child" &#125;, "spec": &#123; "type": "boolean", "description": "Specifies if a spec file is generated.", "default": true &#125;, "flat": &#123; "type": "boolean", "description": "Flag to indicate if a dir is created.", "default": false &#125;, "commonModule": &#123; "type": "boolean", "description": "Flag to control whether the CommonModule is imported.", "default": true, "visible": false &#125;, "module": &#123; "type": "string", "description": "Allows specification of the declaring module.", "alias": "m" &#125;&#125; @schematics/angular:service 123456789101112&#123; "flat": &#123; "type": "boolean", "default": true, "description": "Flag to indicate if a dir is created." &#125;, "spec": &#123; "type": "boolean", "default": true, "description": "Specifies if a spec file is generated." &#125;&#125; @schematics/angular:pipe 12345678910111213141516171819202122232425262728&#123; "flat": &#123; "type": "boolean", "default": true, "description": "Flag to indicate if a dir is created." &#125;, "spec": &#123; "type": "boolean", "default": true, "description": "Specifies if a spec file is generated." &#125;, "skipImport": &#123; "type": "boolean", "default": false, "description": "Allows for skipping the module import." &#125;, "module": &#123; "type": "string", "default": "", "description": "Allows specification of the declaring module.", "alias": "m" &#125;, "export": &#123; "type": "boolean", "default": false, "description": "Specifies if declaring module exports the pipe." &#125;&#125; @schematics/angular:class 1234567&#123; "spec": &#123; "type": "boolean", "default": true, "description": "Specifies if a spec file is generated." &#125;&#125; 專案設定 Angular CLI 6.x 針對多專案的設定方式，有很大的改變，但彈性也相對的自由。以下為設定說明 root：專案根目錄 sourceRoot：專案檔案的位置，如靜態檔案， index.html 等 projectType：專案類型，有 application 與 library 兩種 prefix：selector 的 prefix 設定，預設 app schematics：schematics 範本命令預設參數設定位置，設定方式如最上層的 schematics 設定 architect：建置、測試等執行指令設定 targetName 命令名稱 builder 命令會使用的 builder 名稱，package-name:builder-name options builder 所需要的執行參數設定 configurations 延伸 builder 參數設定 configurationName 參數設定 CLI 指令執行流程 12345678910111213141516171819202122232425262728293031323334"build": &#123; "builder": "@angular-devkit/build-angular:browser", "options": &#123; "progress": false, "outputPath": "www", "index": "src/index.html", "main": "src/main-user.ts", "polyfills": "src/polyfills.ts", "tsConfig": "src/tsconfig.app.json", "assets": [ ... ], "styles": [ ... ], "scripts": [] &#125;, "configurations": &#123; "production": &#123; ... &#125; &#125; &#125;, "serve": &#123; "builder": "@angular-devkit/build-angular:dev-server", "options": &#123; "browserTarget": "app:build" &#125;, "configurations": &#123; "production": &#123; "browserTarget": "app:build:production" &#125; &#125; &#125; 當我們下 ng serve 的指令時，Angular CLI 實際執行命令的流程如下 因為沒有指定 project 名稱，所以會使用 defaultProject (預設為：app) 執行 ng run app:serve 指令 。 ng run projectName:architect-targetName:configuration-configurationName 因為 server 內的 options 的 browserTarget 設定使用 app:build 指令，還要看 build 指令所設定的內容 完成指令動作 內建 builder @angular-devkit/build-angular:app-shell @angular-devkit/build-angular:browser @angular-devkit/build-angular:dev-server @angular-devkit/build-angular:extract-i18n @angular-devkit/build-angular:karma @angular-devkit/build-angular:protractor @angular-devkit/build-angular:server @angular-devkit/build-angular:tslint 結論 Angular CLI 新版的設定檔的架構，可以讓我們很容易的建立要執行的指令與工作流程，當然也可以自訂 builder，花點時間了解一下，在開發上會更順暢]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TypeScript] Compiler API 第一次接觸]]></title>
    <url>%2F2018%2F08%2F17%2Ftypescript-compiler%2F</url>
    <content type="text"><![CDATA[TypeScript 提供了編譯 (compiler) 的 API 出來，可以讓我們用程式的方式建立或是編輯 ts 檔案。但為什麼要了解 TypeScript 的 Compiler API 呢? 主要原因是當在寫 Angular Schematics 時，加減都會碰到編輯 TypeScript 檔案的時候，這時候透過 TS Compiler API 來操作會比較保險一點，但這主題有點大，這一篇文章就稍微了解一下如何入門就好 環境準備 環境的準備很簡單，基本上安裝 TypeScript 1.6 版本以上的都可以，目前的版本是 3.0 1npm install -g typescript 起手式 123456789101112import * as ts from 'typescript';const printer: ts.Printer = ts.createPrinter();const sourceFile: ts.SourceFile = ts.createSourceFile( 'test.ts', 'const x : number = 42', ts.ScriptTarget.ES2015, true, ts.ScriptKind.TS);console.log(sourceFile);console.log(printer.printFile(sourceFile)); 執行結果 第一個 console.log 結果 第二個 console.log 結果 程式碼說明 line 1：從 typescript 載入所有並指定別名 line 2：建立 Printer，用來列印內容用 line 3：createSourceFile 建立 SourceFile 1function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile; sourceFile 的檔名 sourceText 檔案內容 languageVersion TypeScript 版本 Node factories TypeScript Compiler API 內件很多建立的方法， 以下舉出幾個 method 的用法集效果 createAdd ：將兩個 ts.Expression 用 + 串接在一起 12const add = ts.createAdd(ts.createLiteral(42), ts.createLiteral(50));const result = printer.printNode(ts.EmitHint.Unspecified, add, sourceFile); createArrayLiteral ：建立 array 1234const display = ts.createArrayLiteral( /* elements?: ReadonlyArray&lt;Expression&gt; */ [ts.createLiteral('a'), ts.createLiteral('b')], /* multiLine?: boolean */ true); createArrowFunction： 建立 arrow function 1234567891011121314151617const arrowFunction = ts.createArrowFunction( /* modifiers */ [], /* typeParameters */ [], /* parameters */ [ ts.createParameter( [], [], undefined, 'x', undefined, ts.createTypeReferenceNode('number', []) ) ], /* type */ ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), /* equalsGreaterThanToken */ undefined, /* body */ ts.createLiteral(42)); createArrayTypeNode：建立某型別陣列型別 123ts.createArrayTypeNode( ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)); createAsExpression：建立 as 型別 的程式碼 123456const display = ts.createAsExpression( ts.createObjectLiteral([ ts.createPropertyAssignment('name', ts.createLiteral('Kevin')) ]), ts.createTypeReferenceNode('Person', undefined)); createAssignment： 建立指定程式碼 1234ts.createAssignment( ts.createIdentifier('firstName'), ts.createLiteral('Kevin')); createVariableDeclarationList ：建立變數 1234ts.createVariableDeclarationList( [ts.createVariableDeclaration('name', undefined, ts.createLiteral('yooo'))], ts.NodeFlags.Const); 在 TypeScript Compiler 裡面有超級多方法可以用來建立 typescript 的程式碼，但因為在網路上並沒有看到完整的 API 文件，這個就要慢慢花時間一個一個得看了 AST AST 是 Abstract Syntax Tree 的縮寫，基本上就是將 TypeScript 檔案的內容轉換成樹狀結構的資料格式，可以透過分析 AST 的結構，進而做一些有趣的變化，但這邊就先針對結構做些了解，結構如下圖 sourceFile (例如透過 ts.createSourceFile 建立) 內的所有訊息都會被轉換成 node 資訊 (同時也是一份 sourceFile)，每一個 node 資訊都會包含一個 kind 的類別，而這個類別與 ts.SyntaxKind 是對應上的，當然 TypeScript 內也有一些內建的方法來判斷目前的 node 是屬於哪種性質的，例如，使用 ts.isVariableDeclarationList 就可以判斷這一個 node 是否為宣告變數的程式，或是透過 node.kind === ts.SyntaxKind.xxxx 來判斷 TypeScript 編譯的步驟(如上圖)大致上是這樣子，我們可以在中間加上轉換外掛的功能，然後將輸出的結果變成我們想要的，可以在 tsconfig 內做設定 12345678910111213141516171819202122import * as ts from 'typescript';const printer: ts.Printer = ts.createPrinter(&#123; newLine: ts.NewLineKind.LineFeed&#125;);const sourceFile: ts.SourceFile = ts.createSourceFile( 'test.ts', `import * as ts from 'typescript''; `, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);visit(sourceFile);function visit(node: ts.Node) &#123; if (node.kind === ts.SyntaxKind.ImportDeclaration) &#123; console.log('變數定義', node.kind); &#125; node.forEachChild(visit);&#125; 這裡提供一個簡單的程式碼做個開始，在搭配上一小結的建立方法，就可以改變最終的輸出結果了 參考文件 Using the Compiler API AST Explorer How to Write a TypeScript Transform Angular Schematics ast-utils]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Schematics 內檔案系統基本操作]]></title>
    <url>%2F2018%2F08%2F16%2Fangular-schematics-filesystem%2F</url>
    <content type="text"><![CDATA[Schematics 跟檔案操作的元素有三種，分別是 Tree、Rule、Source ，但這三個元素到底是什麼? 又各自有哪些方法可以使用呢? 基本簡介 檔案系統的操作可以算是 Schematics 內核心的功能之一，也是大部分我們希望 schematics 幫我們處理的事情。所以熟悉 schematics 的檔案操作方式，在寫自己的 schematics 會輕鬆很多。 檔案系統操作 型別 Tree： 是檔案系統的結構描述，包含檔案的狀態與改變檔案的規則 (Rule) Source： 是一個建立空的新 Tree，常見的方法有 Url(path) Rule： 是描述要如何改變 Tree，所以 Rule 會回傳一個包含改變規則的 Tree 方法 Tree 當第一次建立空的 schematics 時，會看到這一段程式碼 12345export function blogdemo(options: any): Rule &#123; return (tree: Tree, _context: SchematicContext) =&gt; &#123; return tree; &#125;;&#125; 這裡取得的 Tree 會是當下的檔案系統，所以會包含目前目錄下的所有檔案與資料夾，當然也可以針對那些檔案去做操作，可使用的方法有 branch(): Tree ：複製一份目前 Tree 狀態的 Tree 物件 merge(other: Tree, strategy?: MergeStrategy): void ：合併兩個 Tree 物件，可決定合併衝突時的解決方式 MergeStrategy 有以下選項 AllowOverwriteConflict AllowCreationConflict AllowDeleteConflict Default Error：如果2個檔案存在於相同的位置就會丟出錯誤訊息 ContentOnly：只有內容衝突時才可以被覆寫 Overwrite：包含 AllowOverwriteConflict、AllowCreationConflict、AllowDeleteConflict，根據最後的異動做覆蓋 root: DirEntry (唯讀)：取得目前的資料夾資訊 (FileSystemDirEntry 型別) read(path: string): Buffer | null：讀取檔案並用 binary 的方式呈現 exists(path: string): boolean：檢查檔案是否存在 get(path: string): FileEntry | null：取得檔案 ( FileEntry 型別) getDir(path: string): DirEntry ：取得某資料夾的資訊 (FileSystemDirEntry 型別) visit(visitor: FileVisitor): void：拜訪目前 Tree 下的所有檔案 (list through folders) overwrite(path: string, content: Buffer | string): void：複寫特定位置的檔案內容 beginUpdate(path: string): UpdateRecorder：開始修改某個檔案 commitUpdate(record: UpdateRecorder): void：確認修改內容，需與 beginUpate 配合使用 create(path: string, content: Buffer | string): void：建立檔案並給予檔案內容 delete(path: string): void：刪除檔案 rename(from: string, to: string): void：重新命名檔案 apply(action: Action, strategy?: MergeStrategy): void：套用規則，但無法在 HostTree 使用 actions: Action[] (readonly)：列出該 Tree 目前所有的 actions，每一個 action 會有以下資訊 kind：動作種類 c：建立 d：刪除 o：複寫 r：重新命名 path ：路徑(from) to：路徑 (to) content：異動內容 基本上，屬於 Tree 型別的資料，都有上述的方法可以使用。在操作檔案系統時，Tree 是一個很重要的觀念，可以想像程他跟 Git 的 commit history 有雷同的運作方式。而所有的異動與規則，最終都得回到 Tree 上 Source Source 如上頭所介紹的，是用來建立一個全新空的檔案系統，有以下的方法可以產生 Source url(path: String) 12345678910// src/blogdemo/index.tsexport function blogdemo(_options: any): Rule &#123; return (tree: Tree, context: SchematicContext) =&gt; &#123; // 根據 index.ts 的位置為出發點 const files = url('./')(context) as Tree; // 列出該 Tree 下的所有檔案 files.visit(v =&gt; console.log(v)); return tree; &#125;;&#125; 執行結果 apply(source: Source, rules: Rule[])：套用規則到 Source 上，並回傳經處理後的 Source 12345678910export function blogdemo(_options: any): Rule &#123; return (tree: Tree, context: SchematicContext) =&gt; &#123; const filterRule = filter(x =&gt; x.endsWith('ts')); const files = apply(url('./'), [filterRule])(context) as Observable&lt;Tree&gt;; files.subscribe(tree =&gt; &#123; tree.visit(f =&gt; console.log(f)); &#125;); return tree; &#125;;&#125; source(tree: Tree)：將 Tree 轉換成 Source 型別 123456789101112export function blogdemo(_options: any): Rule &#123; return (tree: Tree, context: SchematicContext) =&gt; &#123; const filterRule = filter(x =&gt; x.endsWith('ts')); const files = apply(source(tree), [filterRule])(context) as Observable&lt; Tree &gt;; files.subscribe(tree =&gt; &#123; tree.visit(f =&gt; console.log(f)); &#125;); return tree; &#125;;&#125; empty()： 回傳一個空的 Tree asSource (rule: Rule) 將規則轉換成 source 這邊會發現我在 source 物件後面加上 (context) ，這個動作是將 source 型別進行處理並會回傳 Tree | Observable&lt;Tree&gt; 型別的資料，之後的操作就跟操作 Tree 是一模一樣的 1export type Source = (context: SchematicContext) =&gt; Tree | Observable&lt;Tree&gt;; Rule chain(rules: Rule[]): Rule ： 將 Rule 串接在一起 mergeWith(source: Source, strategy: MergeStrategy = MergeStrategy.Default): Rule 將 source 與 Tree 做合併 (直接修改) noop() : Rule：回傳沒有任何動作的 Rule filter(predicate: FilePredicate&lt;boolean&gt;): Rule：過濾規則 branchAndMerge(rule: Rule, strategy = MergeStrategy.Default): Rule：與目前的 Tree (複製) 合併並回傳一份新的 Tree partitionApplyMerge(predicate: FilePredicate&lt;boolean&gt;, ruleYes: Rule , ruleNo?: Rule): Rule：根據條件執行對應的 Rule forEach(operator: FileOperator): Rule：批次直型傳進的 FileOperator move(from: string, to?: string): Rule：移動檔案至資料夾 rename(match: FilePredicate&lt;boolean&gt;, to: FilePredicate&lt;string&gt;): Rule：將符合條件的檔案更換名稱 externalSchematic&lt;OptionT extends object&gt;(collectionName: string, schematicName: string, options: OptionT): Rule：執行第三方 schematics 的命令 schematic&lt;OptionT extends object&gt;(schematicName: string, options: OptionT): Rule：執行其他的 schematics 命令 template&lt;T&gt;(options: T): Rule：樣板套用，包含檔案內容與檔名路徑的部分轉換 pathTemplate&lt;T extends PathTemplateData&gt;(options: T): Rule：轉換檔名路徑至對應的內容 contentTemplate&lt;T&gt;(options: T): Rule：轉換檔名內容的變數至對應的內容 1export type Rule = (tree: Tree, context: SchematicContext) =&gt; Tree | Observable&lt;Tree&gt; | Rule | void; 總結 Tree、source 與 Rule 間的關係其實很密切，將這三者的控制弄熟之後，就可以寫出功能很強大的 schematics，而不是單純的從別人的 schematics 複製貼上，卻不懂每一個動作的意義。 參考資料 Schematics]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF6] Oracle with Code First 設定]]></title>
    <url>%2F2018%2F08%2F01%2Fef-oracle-code-first%2F</url>
    <content type="text"><![CDATA[近期有一個案子有可能會用到 Oracle， 所以在還沒有正式開跑之前，先來研究一下如何與 Entity Framework 搭配使用。但由於 EF Core 對 Oracle 的支援必須要等到下半年度才可能會有 Oracle 官方釋出的 drive，所以這邊還是先乖乖地使用 EF6 了。 至於如何架設自己的 Oracle 11g Express 資料庫，就要先從網路上面查詢怎麼架設了。這文章我之後再補 事前準備 在開始之前，先假設 Oracle 的環境是非常乾淨的，就只能用 system 帳號做連線，我們可以先用 Oracle SQL Developer 工具來測試連線，使用 system 的帳號登入後，我們要先新增使用者 建立 TableSpace 由於 Oracle 只能有一個資料庫 (Database)，當想要做到多資料庫的格式，就得透過 Tablespace 的方式來完成。Tablespace 可以想程式一個資料表的集合，而使用者也可以指定使用特定的 Tablespace，這表示一個使用者帳號就可以代表是一個資料庫 建立 tablespace 的方法，如果是使用 Oracle SQL Developer 者，就需要透過指令的方式來建立，建立後，似乎沒有辦法再改名稱了。所以要小心 1234CREATE TABLESPACE "NewTableSpace" DATAFILE 'C:\ORACLEXE\APP\ORACLE\ORADATA\XE\Northwind' SIZE 100 M -- 存放位置與預設初始檔案大小AUTOEXTEND ON NEXT 10 M -- 當資料大小已經增加到原先設定容量時，是否會自動依據設定增加容量MAXSIZE UNLIMITED ; -- 檔案無大小上限 建立使用者 來新增一個使用者，等一下做 EF 時可以用，新增步驟如下 (使用 Oracle SQL Developer Tool) 連線至 Oracle DB 其他使用者，滑鼠右鍵開啟選單，選擇建立使用者 輸入想要新增的使用者名稱與密碼 選擇剛剛所新增的 TableSpace 授權角色設定: (依自己的需要設定) CONNECT：授與使用者可以連線資料庫並執行基本的資料庫操作 RESOURCE：可以讓使用者去建立資料庫的物件，如TABLE. TRIGGER, PROCEDURE DBA：可以讓使用者存取所有其他使用者的資料庫物件與管理資料庫 系統權限設定: 我這邊基本上先全部開放，(一樣依自己的需求做設定) 完成設定後就按下【套用】執行，完成使用者建立 建立 .NET 專案 先建立一個 Console 專案 安裝 Oracle EntityFramework 套件 打開 Nuget 管理工具 搜尋 Oracle.ManagedDataAccess.EntityFramework 安裝 Oracle.ManagedDataAccess.EntityFramework，檢查 Reference 是否有安裝成功 ※ 在 readme.txt 的內容要稍微看一下 Note: The 32-bit 「Oracle Developer Tools for Visual Studio」 download from http://otn.oracle.com/dotnet is required for Entity Framework design-time features. This NuGet download does not enable design-time tools; it only provides run-time support. This version of ODP.NET for Entity Framework supports Oracle Database version 10.2 and higher. 設定連線 打開 app.config，在最後面可以看 oracle 連線的相關資訊 1234567891011&lt;oracle.manageddataaccess.client&gt; &lt;version number=&quot;*&quot;&gt; &lt;dataSources&gt; &lt;dataSource alias=&quot;SampleDataSource&quot; descriptor=&quot;(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=ORCL))) &quot;/&gt; &lt;/dataSources&gt; &lt;/version&gt;&lt;/oracle.manageddataaccess.client&gt;&lt;connectionStrings&gt; &lt;add name=&quot;OracleDbContext&quot; providerName=&quot;Oracle.ManagedDataAccess.Client&quot;connectionString=&quot;User Id=oracle_user;Password=oracle_user_password;Data Source=oracle&quot;/&gt;&lt;/connectionStrings&gt; 請依自己的環境做設定調整，例如 HOST 位置、SERVICE_NAME、User ID 、password 等 在 connectionString 內提到的 Data Source 是指上方的 &lt;dataSource&gt; 名稱 建立 DbContext 這裡的動作與一般操作 Entity Framework 是一樣的 OracleDbContext.cs 1234567891011121314151617using System.Data.Entity;namespace BlogDemo&#123; public class OracleDbContext : DbContext &#123; public DbSet&lt;Employee&gt; Employees &#123; get; set; &#125; protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; // 資料表隸屬位置，Oracle 內是以使用者帳號作為 table schema 的開頭 // 例如: BLOG_DEMO.Employees // Schema名稱一定要大寫 modelBuilder.HasDefaultSchema("BLOG_DEMO"); &#125; &#125;&#125; 建立 Employee.cs 檔案 12345678namespace BlogDemo&#123; public class Employee &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; &#125;&#125; 設定 program.cs ，啟動 EF 並塞入一筆資料 1234567891011121314151617181920212223using System.Data.Entity;namespace BlogDemo&#123; internal class Program &#123; private static void Main(string[] args) &#123; Database.SetInitializer(new DropCreateDatabaseAlways&lt;OracleDbContext&gt;()); using (OracleDbContext ctx = new OracleDbContext()) &#123; Employee emp = new Employee() &#123; Name = "Kevin" &#125;; ctx.Employees.Add(emp); ctx.SaveChanges(); &#125; &#125; &#125;&#125; 第一次執行，因為 DropCreateDatabaseAlways 的關係，所以會建立資料表，這模式不適合以在開發的系統，請留意!! 其他相關設定 1. CreateDatabaseIfNotExists : 預設規則，DB不存在時才建立，若Model與目前存在DB不相符會拋出例外錯誤 2. DropCreateDatabaseIfModelChanges : DB不存在時建立，若Model與目前存在DB不相符時會自動移除現有DB後再建立新DB 3. DropCreateDatabaseAlways : 無論如何，總是移除現有DB(如果存在的話)，再建立新DB 啟動 migration 開啟 package Manager Console 輸入 Enable-Migrations，這會啟動 code first 模式 修改 Employee 資料表內容，新增 address 欄位 123456public class Employee&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Address &#123; get; set; &#125;&#125; 新增 migrations 檔案，add-migration &lt;filename&gt; 201808010850326_table_employee_add_address_field.cs 123456789101112public partial class table_employee_add_address_field : DbMigration&#123; public override void Up() &#123; AddColumn("BLOG_DEMO.Employees", "Address", c =&gt; c.String()); &#125; public override void Down() &#123; DropColumn("BLOG_DEMO.Employees", "Address"); &#125;&#125; 執行 Update-Database ，將異動部分更新到資料庫 完成第一次遷移(migration)更新 結論 關於 EF 相關的操作方式，請參閱 Entity Framework 的相關文件，這邊只針對 Oracle Entity Framework 要怎麼連線及相關設定的說明。畢竟有些細節的部分與 MSSQL 的連線是不一樣的。 參考資料 Entity Framework Code First and Code First Migrations for Oracle Database ASP.NET MVC + Oracle 11g XE + Entity Framework. Part 2 【EF-Oracle-01】使用 Entity Framework 連結 Oracle 資料庫 ​]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>Entity Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Ionic 4 第一次接觸]]></title>
    <url>%2F2018%2F07%2F28%2Fionic-first-look%2F</url>
    <content type="text"><![CDATA[在前幾天， Ionic 團隊發布 Ionic 4 的 beta 版，這一版可以說是整個打掉重寫的產品。原本的元件程式碼，都從頭來過。那 Ionic 4 又有帶來什麼驚喜呢，為什麼團隊願意整個打掉重來呢? 在正式分享自己第一次玩弄 ionic 4 的心得之前，先從官方文件內擷取一些重點出來，在一次的重點更新有 web component : 所有的 component 都重新改寫成 web component，但是團隊並不是自己刻 web component，而是透過 Stencil 這工具完成的，(相關訊息在此)。 Framework Integration&amp; Compatibility: 因為基於 web component ，沒有相依於任何的 framework ，當然就可以拿到任何的 framework 下使用。 Angular CLI &amp; Router : 當然 ionic cli 提供建立 Angular 專案類型的指令，在 ionic 3 的路由設定與 Angular 的路由設定是完全不一樣的，而 ionic 4 的路由就跟 Angular 一樣，所以會寫 Angular 就會寫 ionic app. 建立第一個 ionic 4 專案 首先，要先安裝或更新 ionic cli 1npm install -g ionic 安裝完成後，建立第一個專案 1ionic start myApp tabs --type=angular –type=angular 是需要多加的參數，或許以後就可以有 --type=Vue 或是其他的 framework 的選擇 第一次建立時，其實會問蠻多問題的 當創建專案跑完後，用 VSCode 打開，就可以看到熟悉的 Angular 的專案架構 路由設定檔 因為建立的是 Tab 類型的專案，所以就來看一下 tabs.router.module.ts 內的設定 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule, Routes &#125; from '@angular/router';import &#123; TabsPage &#125; from './tabs.page';import &#123; HomePage &#125; from '../home/home.page';import &#123; AboutPage &#125; from '../about/about.page';import &#123; ContactPage &#125; from '../contact/contact.page';const routes: Routes = [ &#123; path: 'tabs', component: TabsPage, children: [ &#123; path: 'home', outlet: 'home', component: HomePage &#125;, &#123; path: 'about', outlet: 'about', component: AboutPage &#125;, &#123; path: 'contact', outlet: 'contact', component: ContactPage &#125; ] &#125;, &#123; path: '', redirectTo: '/tabs/(home:home)', pathMatch: 'full' &#125;];@NgModule(&#123; imports: [RouterModule.forChild(routes)], exports: [RouterModule]&#125;)export class TabsPageRoutingModule &#123;&#125; 在上一層的路有檔為 1234567891011import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: '', loadChildren: './tabs/tabs.module#TabsPageModule' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125; 是不是很熟悉。路由設定的部分都與常寫的 Angular 專案一模一樣 建立頁面 ionic cli 其實也有提供 generate 的功能，來看一下有哪些東西可以產生 新增後的路由異動內容為 1234const routes: Routes = [ ... &#123; path: 'profile', loadChildren: './pages/profile/profile.module#ProfilePageModule' &#125;]; 很好心的，把 lazyLoading 的功能設為預設行為，並且將每一個 page 頁面都以 NgModule 包起來.，其他的內容就與一般的 component 是一樣的 檢視 ionic 4 component 內容 ionic component 的用法其實沒有太大的改變，已經熟悉的人，稍微再調整一下，應該很快就可以上手了，但總要來驗證一下是否如 ionic 團隊所說，元件都重新改寫，來一個簡單的 alert 元件看一下程式碼 程式碼的部分 基本上，整個寫法就完全與框架脫鉤，只利用 stencil 建置工具的方法而已了。有興趣的人可以自行再去研究 手機服務 Ionic Native 透過 Ionic Native 就可以取得手機上的服務，這裡就簡單地舉一個範例程式 12$ ionic cordova plugin add cordova-plugin-camera$ npm install --save @ionic-native/camera 123456789101112131415161718192021import &#123; Camera, CameraOptions &#125; from '@ionic-native/camera';constructor(private camera: Camera) &#123; &#125;...const options: CameraOptions = &#123; quality: 100, destinationType: this.camera.DestinationType.FILE_URI, encodingType: this.camera.EncodingType.JPEG, mediaType: this.camera.MediaType.PICTURE&#125;this.camera.getPicture(options).then((imageData) =&gt; &#123; // imageData is either a base64 encoded string or a file URI // If it's base64 (DATA_URL): let base64Image = 'data:image/jpeg;base64,' + imageData;&#125;, (err) =&gt; &#123; // Handle error&#125;); 範例API Capacitor Plugin 1234567891011121314151617import &#123; Plugins, CameraResultType &#125; from '@capacitor/core';const &#123; Camera &#125; = Plugins;async takePicture() &#123; const image = await Camera.getPhoto(&#123; quality: 90, allowEditing: true, resultType: CameraResultType.Uri &#125;); // image.webPath will contain a path that can be set as an image src. You can access // the original file using image.path, which can be passed to the Filesystem API to // read the raw data of the image, if desired (or pass resultType: CameraResultType.Base64 to getPhoto) var imageUrl = image.webPath; // can be set to the src of an image now imageElement.src = imageUrl;&#125; 範例 API 因為 Capacitor 是新的工具，所以在於手機服務存取的 API 數量並沒有 Cordova 來的多，但是就程式碼風格來比較，個人是比較偏愛 Capacitor 的寫法 建置發布 建置與發佈的方式，有分兩種，一是使用 Cordova ，另外一種是使用 Capacitor。再根據分別的建置與發佈的方式處理 iOS 或 Android 平台即可。這邊的做法基本上是一樣的 結論 Ionic 4 的程式碼架構，我個人是比較喜歡，至少我可以用熟悉的 Angular 開發方式就可以寫了。不太會出現看起來很像又不一樣的 Angular 程式風格，但這也是我個人的偏好而已。 參考資料 Ionic Native stencil Capacitor Ionic 4 Doc]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] App-Shell]]></title>
    <url>%2F2018%2F07%2F19%2Fangular-app-shell%2F</url>
    <content type="text"><![CDATA[Angular CLI 在後期的版本，提供了建立 app shell 的功能，何謂 app shell ，基本上就是透過 universal 的功能，先將首頁的畫面，產生靜態的 DOM 內容並新增到 index.html 的頁面中，並透過 app-shell component (只是單純的 component) 顯示等待訊息。 為什麼要這樣子做，主要理由是讓使用者可以在第一時間得知他所開啟的網站，是有在執行的 那 Angular CLI 如何透過指令的方式，來完成建置 app shell 的效果呢? 操作步驟 為了方便展示，這裡我們重新建立一個全新的專案 1ng new shell-demo --routing 當建立完成時，在執行以下的指令來新增 app-shell 的功能 1ng g app-shell --client-project &lt;project name&gt; --universal-project server-app 需要換成自己要的專案名稱，已這裡的範例是 shell-demo 檢視變更檔案 angular.json 12345678910111213141516"server": &#123; "builder": "@angular-devkit/build-angular:server", "options": &#123; "outputPath": "dist/shell-demo-server", "main": "src/main.server.ts", "tsConfig": "src/tsconfig.server.json" &#125;&#125;,"app-shell": &#123; "builder": "@angular-devkit/build-angular:app-shell", "options": &#123; "browserTarget": "shell-demo:build", "serverTarget": "shell-demo:server", "route": "shell" &#125;&#125; 在所指定的 client-project 下新增這兩個指令，而在之後的建置指令，會執行 app-shell 這個指令 在 app-shell 指令內，分別設定了 browserTarget 和 serverTarget 要執行的指令是什麼 指定執行命令的方式 &lt;projectName&gt;:&lt;architect 內的 指令名稱&gt;:&lt;command 內的 configuration&gt; 例如 shell-demo:build main.ts 修改 bootstrap 的時機點，會等 index.html 頁面內容讀取完成後再啟動 Angular App 1234document.addEventListener('DOMContentLoaded', () =&gt; &#123; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err));&#125;); app.module.ts 新增 universal 相關的 NgModule 設定 12345imports: [ BrowserModule.withServerTransition(&#123; appId: 'serverApp' &#125;), AppRoutingModule, RouterModule ], 比較重要的檔案變更就是上述的這幾的檔案 建置 app-shell 的方式 由於內建的 cli 指令並沒有針對建置 app-shell，所以必須透過 ng run 的方式來執行 1ng run shell-demo:app-shell ng run 後面所接的指令，如我上面所描述的指令格式，例如 ng build，對等同於 ng run shell-demo:build 當執行完成後，在 dist 的資料夾可以看到兩個資料夾，一個是原本就會產生的網站資料夾，另外一個是 universal 用的資料夾 在輸出的 index.html 的內容，就會看到首頁的靜態 DOM 內容，這裡所產生的內容是從 app.module 所定義的 bootstrap component 來的 當執行起來時，使用者就可以很快速地看到網站內容，然後再等 Angular 的應用程式被啟動起來。就對使用者來說，使用體驗就會變好了 執行結果 結論 透過 App-shell 對於使用者體驗，是有某種程度上的幫助，畢竟一開始就可以看到一些網站內容，而不是一個 loading 的畫面。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core]GraphQL 超新手篇]]></title>
    <url>%2F2018%2F07%2F08%2Fdotnetcore-graphql%2F</url>
    <content type="text"><![CDATA[又再一次向 GraphQL 挑戰，什麼是 GraphQL，可以快速閱讀一下這篇文章 2018 GraphQL 漸進式導入的架構，ASP.NET Core 又該如何設定呢? 這裡先簡單的記錄一下，關於更細節的設定，就待以後再來研究了 測試環境 ASP.NET Core 2.x 版 套件 GraphQL 前端使用 Angular 來呼叫 GraphQL 後端 套件安裝 安裝 GraphQL for .NET 1dotnet add package GraphQL 基本設定 建立 Schema：GraphQL 解析的進入點，定義 Query 與 Mutation 1234567public class CaptionSchema: Schema&#123; public CaptionSchema(Func&lt;Type, GraphType&gt; resolveType) : base(resolveType) &#123; Query = (CaptionQuery)resolveType(typeof(CaptionQuery)); &#125;&#125; 建立 ObjectGraphType，設定可以查詢的欄位及資料撈取的方式 12345678910111213public class CaptionQuery : ObjectGraphType &#123; public CaptionQuery(ICaptionRepository captionRepository) &#123; // 資料回傳型別 Field&lt;ListGraphType&lt;CaptionType&gt;&gt;( "captions", // 查詢命令的名稱 arguments: new QueryArguments( new QueryArgument&lt;NonNullGraphType&lt;IntGraphType&gt;&gt; &#123;Name = "id", Description = "Category id"&#125; ),// 查詢參數 resolve: context =&gt;&#123; ... &#125; // 準備回傳資料 &#125; &#125; 定義 CaptionType ，回傳的資料型別 1234567891011121314public class CaptionType: ObjectGraphType&lt;Caption&gt;&#123; public CaptionType(StreamDbContext dbContext) &#123; Field(x =&gt; x.Id).Description("Caption Id"); Field(x =&gt; x.Uid).Description("User Unique ID"); // 可以使用 Query 裡面的定義方式建立其他關連欄位 Field&lt;ListGraphType&lt;ProductType&gt;&gt;( "products", resolve: context =&gt; productRepository.GetProductsWithByCategoryIdAsync(context.Source.Id).Result.ToList() ); &#125;&#125; 註冊到 Startup.cs 1234567891011121314public void ConfigureServices(IServiceCollection services)&#123; ... services.AddMvc(); // Register GraphQL QueryModel/Schema services.AddScoped&lt;CaptionQuery&gt;(); services.AddTransient&lt;CaptionType&gt;(); services.AddTransient&lt;ICaptionRepository, CaptionRepository&gt;(); services.AddScoped&lt;IDocumentExecuter, DocumentExecuter&gt;(); var sp = services.BuildServiceProvider(); services.AddScoped&lt;ISchema&gt;(_ =&gt; new CaptionSchema(type =&gt; (GraphType)sp.GetService(type)) &#123; Query = sp.GetService&lt;CaptionQuery&gt;() &#125;);&#125; 為 GraphQL 建立 API EndPoint 1234567891011121314151617181920212223242526272829303132333435[Route("graphql")]public class GraphQLController : ControllerBase&#123; private readonly IDocumentExecuter _documentExecuter; private readonly ISchema _schema; public GraphQLController(IDocumentExecuter documentExecuter, ISchema schema) &#123; _documentExecuter = documentExecuter; _schema = schema; &#125; [HttpPost] public async Task&lt;IActionResult&gt; Post([FromBody]GraphQLQuery query) &#123; if (query == null) &#123; throw new ArgumentNullException(nameof(query)); &#125; var executionOptions = new ExecutionOptions &#123; Schema = _schema, Query = query.Query, UserContext = HttpContext.User &#125;; try &#123; var result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false); if (result.Errors?.Count &gt; 0) &#123; return BadRequest(result); &#125; return Ok(result); &#125; catch (Exception ex) &#123; return BadRequest(ex); &#125; &#125;&#125; 建立 GraphQLQuery.cs 123456789using Newtonsoft.Json.Linq;...public class GraphQLQuery&#123; public string OperationName &#123; get; set; &#125; public string NamedQuery &#123; get; set; &#125; public string Query &#123; get; set; &#125; public JObject Variables &#123; get; set; &#125; &#125; ​ * 有些文章的 Variables 會用 string 型別，但這個在使用 Angular 呼叫時，會出現問題，必須改成 JObject 才不會有問題 到這邊為止，可以算大致上完成 GraphQL 在 asp.net core 後端的設定，以上的範例在 resolve 裡的程式碼實作，可以直接使用 EF 來讀取，或是透過 Repository 的方式來存取都可以 前端 套件安裝 1npm install apollo-angular apollo-angular-link-http apollo-link apollo-client apollo-cache-inmemory graphql-tag graphql --save 或是 1yarn add apollo-angular apollo-angular-link-http apollo-link apollo-client apollo-cache-inmemory graphql-tag graphql Angular 設定 在 app.modules.ts 新增以下設定 import ApolloModule 和 HttpLinkModule 在 constructor 的地方設定 apollo 123456789101112import &#123; ApolloModule, Apollo &#125; from 'apollo-angular';import &#123; HttpLinkModule, HttpLink &#125; from 'apollo-angular-link-http';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';...export class AppModule &#123; constructor(apollo: Apollo, httpLink: HttpLink) &#123; apollo.create(&#123; link: httpLink.create(&#123; uri: '[URL]' &#125;), cache: new InMemoryCache() &#125;); &#125;&#125; Angular 發出第一次 query 先在 component 寫第一次的 GraphQL query constructor 注入 apollo 服務 建立查詢語法 12345678910111213this.apollo .query&lt;any[]&gt;(&#123; query: gql` query &#123; captions &#123; id label colorClass &#125; &#125; ` &#125;) .subscribe(value =&gt; console.log(value)); 由於 apollo 建立出來的 query 指令是 Observable 型別, 後續的做法就跟 HttpClient 的 get 等相同了 當執行這一段理論上就可以從後端撈取所設定的資料集了 結論 剛開始在碰 GraphQL 時，最麻煩的是摸索設定的階段，一旦設定完成後，後續模組的設定，難度上就還好了。只是還是得規劃一下，希望用怎樣的資料結構讓前端做查詢，畢竟後端沒有設定的欄位，前端是沒有辦法做查詢的，如果前端查詢到後端沒有設定到的欄位時，就會出現錯誤訊息 當然就目前這階段，我並沒有辦法說 GraphQL 的好壞或是適用情境，但至少先完成環境的設置。之後要進一步的研究就比較容易了 參考資料 GraphQL sample project in ASP.NET Core 2.0 Introduction to GraphQL and Designing Simple Query API with ASP.NET Core 2.0 graphql-dotnet apollo-angular 2018 GraphQL 漸進式導入的架構 Why GraphQL: Advantages, Disadvantages &amp; Alternatives]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] NgModule]]></title>
    <url>%2F2018%2F06%2F26%2Fangular-ngmodule%2F</url>
    <content type="text"><![CDATA[Angular 的 NgModule 是架構中的核心元件，為什麼這麼說呢? 因為 NgModule 不論是要執行 AOT 或是 LazyLoading 或是製作Library ，都是以 NgModule 為單位，至於 NgModule 到底有哪些事情是我們需要知道的呢? 什麼是 NgModule NgModule 是 Angular 內管理元件的工具，他負責管理元件間、服務相依性的關係，也控制其他 NgModule 對自己的存取權限。NgModule 是透過 metadata (decorator) 來描述所管理的 component 、directive、pipe、NgModules 等 以下是一個簡單 NgModule 的範例程式 1234567891011121314@NgModule(&#123; imports: [ BrowserModule, ContactModule, CoreModule.forRoot(&#123;userName: 'Miss Marple'&#125;), AppRoutingModule ], providers: [], declarations: [ AppComponent ], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 至於 NgModule 與 application dependency injectors 間的關係，會在下面做說明。簡單的來說，於 NgModules provider 內註冊的服務，都會被註冊到 Application 層級 補充資訊 Angular 內的物件層級由上而下為，而在相關位置都可以取到以下物件的參考物件，例如 ApplicationRef Platform Application NgModule Directive / Component NgModule VS ES2015 Modules Angular 有使用到 NgModule 與 ES2015 Modules。 NgModule 與 ES2015 Module 是一樣的嗎? 答案是，他們是不一樣的東西 ES2016 Module 是以實體檔案為單位來管理程式碼，並透過 export 關鍵字來控制要對外公開的功能 1export class AppComponent &#123; ... &#125; 在其他檔案要使用到 AppComponent 時，必須透過 import 來載入 1import &#123; AppComponent &#125; from './app.component'; NgModule 是以 Class 搭配 @NgModule 修飾器來管理元件，並透過 export 來管理要對外公開的元件 NgModule 與 Dependency Injection 的關係 Angular 的 DI 系統的偉大已經不是一兩句話可以描述的，但 Angular DI 還是有很多細節要留意，不然會有鬼打牆的現象出現。先從基本的註冊服務的行為開始說起，Angular 在 Application 層級，有一個 Injector 中樞服務，這一個服務是用來管理所有註冊的 service，當在 class 中有使用到有註冊的 service，就會從 Injector 中將該實體注入到該 class 中，預設的註冊模式是 singleton Injector 在 Application 層級，那要怎麼註冊服務呢? Application 又沒有開可以註冊服務的窗口出來。這時候就是 NgModules 要上場了. 記得 NgModules 有一個 providers 的區塊可以做註冊 service 至 Injector 吧，這裡的運作流程是 當 platformBrowserDynamic() 啟動後，就會跟著啟動所指定的 NgModule (也是所謂的 Root Module)。 將 Root Module 內所設定的 provider 驗證並加入到 Injector Tree 中 將 Root Module 內所 import 的 NgModule 的 provider 驗證加入到 Injector Tree 中 每一次的 NgModule 的 import 都會產生一份新的 providers 清單，這也是為什麼在官方文件提到，如果想要 service 維持 singleton ，就必須將 service 註冊在 Core Module 且只會在 Root Module import。( providedIn 不在此範圍內) 啟動 NgModule 的模式 JIT (Just In Time compilation) Dynamic bootstrapping 是指 Angular 程式碼是在瀏覽器端才進行編譯工作。瀏覽器動態啟動是件成本很高的動作，所以不建議使用在正式環境上，會影響第一次頁面打開的執行速度，建議發佈上線時，要採用 AOT 模式 AOT (Ahead Of Time compilation) 何謂 AOT 模式，簡單的說，就是將編譯的動作挪至建置時間完成。AOT 有哪些好處 Faster rendering，因為程式已經先編譯過了，所以到瀏覽器端就只剩下執行了，執行速度會變快 Fewer asynchronous requests，將 HTML 與 CSS 編譯至 JavaScript 中了，不須要在從主機端下載 HTML 與 CSS 檔案 Smaller Angular framework download size，因為不需要將 Angular Compiler 的程式包到瀏覽器端，但並表示總的檔案大小是比較小的，因為 HTML Template 的部分也被編譯成 JavaScript 了 Detect template errors earlier，由於會先將 Template 編譯，可以先檢查出 Template 與 Component Class 間的錯誤，例如 template 裡有使用到未定義的方法或是變數 Better security，因為第二點的理由，可以避免一些 Injection 攻擊 比較 JIT 與 AOT 產生的檔案內容 JIT 版本的 app.component.ts AOT 版本的 app.component.ts 發現 AOT 版本的 template 等資訊都不見了，這一部分的資訊被編譯成 ngfactory 的內容 AOT 會將 Template 的部份解析並轉換成程式的一部分，而非用原本的型態呈現 另外一點 AOT 與 JIT 模式的差異是在於啟動方式 JIT 的啟動方式 1platformBrowserDynamic().bootstrapModule(AppModule); AOT 的啟動方式 1platformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 由於現在很多工作都被 Angular CLI 做掉了，但還是得了解一下這兩者在啟動的方法還是有所不同的 延伸閱讀 而完整的運作流程可以在 官方文件 裡找到，在文件中也點出哪一些寫法是不被 AOT 支援的，要多留意 Lazy Loading 何謂 Lazy Loading? 是將程式碼切割成不同的實體檔案，然後在需要時才將該檔案下載到瀏覽器中執行。這樣的做法，可以減少第一次載入的檔案大小，是效能調教的技巧之一 那怎麼才能做到 lazy loading 的效果呢? 可透過路由設定檔來控制 1234567891011const routes: Routes = [ &#123; path: 'customers', loadChildren: 'app/customers/customers.module#CustomersModule' &#125;, &#123; path: '', redirectTo: '', pathMatch: 'full' &#125;]; 利用 loadChildren 的方式指定要載入的 NgModules 的位置，建置工具就可以知道這一個 NgModules 是需要被單獨產生的 另外一種比較進階的技巧，可參閱這篇文章，[Angular] 手動創造出 Lazy Loading 的效果，如果要搭配動態顯示 Component 時，需要留意所要建立的 Component 是隸屬在哪一個 NgModules 裡，不然會出現錯誤訊息，抱怨說找不到該 Component，(參考 Issue) 結語 關於 NgModules 的資訊真的好多好多，無法單純的用一篇文章就可以涵蓋，官方文件就有單獨的一個單元來解釋 NgModules 的大小事，真心推薦一定要閱讀，NgModules 用得好不好，對系統的架構是有很大的影響的 參考資料 NgModules ES6 In Depth: Modules viewProviders vs provider AOT]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] CLI 進度顯示遇上字型的雷 (windows 限定)]]></title>
    <url>%2F2018%2F06%2F19%2Fangular-cli-progress-font%2F</url>
    <content type="text"><![CDATA[不確定從哪一版 CLI 開始，當執行 ng serve 時，命令視窗的進度表，就會出現很混亂的數字後，才會正常的顯示編譯結果，想說一開始就算了，GitHub 上也找不到相關的 Issue，就這樣子擺著。今天實在受不了，就開始追到底是什麼原因造成這神奇的現象 這神奇的現象，用簡單的影片表示一下 (使用字型: 細明體) 開始追蹤 當然一開始是從 Angular CLI 下手，但很不幸的，Angular CLI 所使用的進度顯示是透過 Webpack 的 ProgressPlugin 來完成的 123456...const ProgressPlugin = require('webpack/lib/ProgressPlugin');...if (buildOptions.progress) &#123; extraPlugins.push(new ProgressPlugin(&#123; profile: buildOptions.verbose, colors: true &#125;));&#125; 只好前往 ProgressPlugin 探索了，還好 ProgressPlugin 只是單純一隻 js 檔案，應該很容易找 (才怪) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const defaultHandler = (percentage, msg, ...args) =&gt; &#123; let state = msg; const details = args; if (percentage &lt; 1) &#123; percentage = Math.floor(percentage * 100); msg = `$&#123;percentage&#125;% $&#123;msg&#125;`; if (percentage &lt; 100) &#123; msg = ` $&#123;msg&#125;`; &#125; if (percentage &lt; 10) &#123; msg = ` $&#123;msg&#125;`; &#125; for (let detail of details) &#123; if (!detail) continue; if (detail.length &gt; 40) &#123; detail = `…$&#123;detail.substr(detail.length - 39)&#125;`; &#125; msg += ` $&#123;detail&#125;`; &#125; &#125; if (profile) &#123; state = state.replace(/^\d+\/\d+\s+/, ""); if (percentage === 0) &#123; lastState = null; lastStateTime = Date.now(); &#125; else if (state !== lastState || percentage === 1) &#123; const now = Date.now(); if (lastState) &#123; const stateMsg = `$&#123;now - lastStateTime&#125;ms $&#123;lastState&#125;`; goToLineStart(stateMsg); process.stderr.write(stateMsg + "\n"); lineCaretPosition = 0; &#125; lastState = state; lastStateTime = now; &#125; &#125; goToLineStart(msg); process.stderr.write(msg); &#125;; const goToLineStart = nextMessage =&gt; &#123; let str = ""; for (; lineCaretPosition &gt; nextMessage.length; lineCaretPosition--) &#123; str += "\b \b"; &#125; for (var i = 0; i &lt; lineCaretPosition; i++) &#123; str += "\b"; &#125; lineCaretPosition = nextMessage.length; if (str) process.stderr.write(str); &#125;; return defaultHandler;&#125;; 這是很接近尾巴的搜尋結果，我知道畫面顯示出亂子，一定是這裡面的某一行有問題。經過 1 個小時的驗證，上述的程式碼並沒有錯，但是有抓到一個關鍵點，當我把 … 換成其他符號時，執行結果就會很漂亮的顯示進度表， 這樣應該既是這個符號在作怪，但到底是哪裡出錯了。最後與保哥研究的結果，竟然是字型的關係 觀察結果 我電腦 windows 下命令視窗所使用的字型是預設字型，細明體，就我自己的了解，細明體應該是等寬字型，所謂的等寬字型是指，英文數字在畫面上所顯示的寬度是一樣的，而中文字因為是兩個字元，所以是兩個英文字的寬度 同樣的文字換成新細明體就會視不同的顯示方式 Fira Code 字型 到這裡，我們知道字型的不同，對於每一個字寬度的認定是不同的，而 webpack 的 ProgressPlugin 是使用字串長度做一些黑魔法的事情，(刪除原本的顯示文字，並在原本位置上顯示新的文字) 而 … 在不同字體上的顯示方式又是如何呢? 新細明體 細明體 Fira Code 沒錯，細明體的 … 竟然被判斷成全型字(兩個字元)，難怪在計算要刪除文字長度跟顯示時會出亂子，兇手就是你 驗證一下，將命令視窗的字型改成【點陣字體】後再跑一次，看看會不會正常 解決方案 無視他，既然知道是字型的問題而非程式問題，可以選擇無視他 修正命令視窗的預設字體，設定方式可以參考保哥這篇 讓你的命令提示字元或 WSL 擁有一個美麗等寬的字型設定 參考資料 「細明體」和「新細明體」差在哪裡？ 讓你的命令提示字元或 WSL 擁有一個美麗等寬的字型設定]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Custom Google Form - Angular Version]]></title>
    <url>%2F2018%2F06%2F18%2Fangular-google-form%2F</url>
    <content type="text"><![CDATA[網路上有許多文章介紹如何自訂表單並與Google Form 串接，很有趣的做法，但 Angular 該怎麼做呢? 這篇文章來整理一下做法 Google Form 是一個方便又快速的表單服務，但因為樣式很陽春，相信許多網頁設計師是無法接受的，所以才會有自訂 Google Form 表單樣式的教學出來。而 Angular 也可以做到類似的功能，但有幾個小地方要注意。 建立 Google 表單 前往 Google 表單，建立一個新表單 設計表單 開啟回覆中的 Excel 資料表 這個 Excel 資料表會存放所有的表單結果 Angular 自訂表單 使用 Angular 的表單功能設計一個我們想要的表單，當設計好之後，就需要將 Google 表單的欄位定應到自訂的欄位了，在 Google 表單欄位的名稱，都是以 entry.xxxx 命名的，所以我們只要將 Google 表單的 HTML 拿來分析，並將欄位名稱對應上，送到 &lt;form&gt; 的網址，就可以了 要送出的網址如上圖 對應的欄位名稱如上圖 其他注意事項 要使用 http.post 送出 要將表單資料使用 HttpParams 包裝起來 post header 的 Content-Type 要改成 application/x-www-form-urlencoded 如果是多選的 checkbox，送出的欄位名稱是一樣的 要使用 HttpParams.append radio 或是 checkbox 資料即顯示名稱 剩下的可以參考 Sample Code 參考資料 Sample Code Google Form Customization]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何寫出一個可以被 ng add 使用的 schematics?]]></title>
    <url>%2F2018%2F06%2F15%2Fangular-schematics-ng-add%2F</url>
    <content type="text"><![CDATA[Angular CLI 6 新增了一個指令 ng add &lt;library&gt; ，我們可以透過這個指令來安裝各式各樣的 schematics 套件，進而擴充 Angular CLI 的功能。如果想要寫一個自己的 schematics 又可以透過 ng add 來安裝。這一篇文章的內容或許是一個開始 Angular CLI schematics 可以視為一個指令產生範本的任務集合，所以 Angular CLI 也是透過指令的方式去執行某一個 schematics 裡面的某一個動作。所以在開始寫之前，須了解 Angular CLI 的 ng add 到底做了哪些動作 預設 CLI 所使用的命令清單中，有一個 add.ts ，這個命令就是這次的主角，他的執行步驟有 檢查 ng add 後面使否有輸入引述，需要提供要安裝的套件名稱 npm install 套件 解析是否有相關設定引數是要給 schematics 命令使用的 建立執行命令設定 123456789const runOptions = &#123; schematicOptions: options, workingDir: this.project.root, collectionName, // 集合名稱 schematicName: 'ng-add', // 執行命令 allowPrivate: true, dryRun: false, // 實際產生檔案 force: false, &#125;; 執行 schematics 命令 自訂 Schematics 根據上面的執行命令，可以得知 CLI 的 ng add 是會執行 ng-add 的指令，所以只要在自己的 schematics collection 內新增 ng-add 就可以了，但在哪之前，先建立一個全新空的 schematics 吧 如果沒有安裝 schematics CLI 的，可以透過這指令安裝 1npm install -g @angular-devkit/schematics 安裝完成後，可以執行 schematics --help 看看有沒有安裝成功 建立空的 schematics 1schematics blank &lt;yourSchematicsName&gt; 進入剛剛建立好的資料夾內，eg /postDemo 打開熟悉的編輯器，並修改以下內容 collection.json，將原本的指令興改成 ng-add 12345678910111213141516171819&#123; "$schema": "../node_modules/@angular-devkit/schematics/collection-schema.json", "schematics": &#123; "post-demo": &#123; "description": "A blank schematic.", "factory": "./post-demo/index#postDemo" &#125; &#125;&#125;// 修改成&#123; "$schema": "../node_modules/@angular-devkit/schematics/collection-schema.json", "schematics": &#123; "ng-add": &#123; "description": "A blank schematic.", "factory": "./ng-add/index#ngAdd" &#125; &#125;&#125; factory 後面內容的 #ngAdd 是指要執行的 function 將原本的 post-demo 資料夾名稱修改成 ng-add 將 ng-add/index.ts 檔案裡的 function 名稱修改成 ngAdd 到這裡已經完成 CLI 執行 ng-add 的基本型，再來就是可以把想要在 ng add 時要做的工作寫在這邊就可以了 加碼補充 Angular CLI 的另外一個指令 ng update ，做法類似，詳細的設計可以參考 Angular Material 2 的 schematics update，source code 參考資料 ngcli-wallaby Angular Material 2 schematics README]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] dotnet cli 命令到底是怎麼運行的?]]></title>
    <url>%2F2018%2F06%2F12%2Fdotnet-cli-under-secret%2F</url>
    <content type="text"><![CDATA[如果長期有在追 dotnet cli 的人，就知道在某一個時間點，微軟將 dotnet cli 的設定檔從 project.json 轉回 project.csproj 的格式，主要是要讓建置的動作轉回使用 MSBuild 引擎 根據 文件 有提到，雖然下的指令是 dotnet publish -o pub -c Release 但事實上是執行 dotnet msbuild /t:Publish /p:OutputPath=pub /p:Configuration=Release，這樣就引起我的好奇，其他的指令是否也是做同樣的事情。 幸好現在 dotnet core 相關的程式都有放到 GitHub 上，我們可以很容易地了解整體的運作方式 執行 此篇就用 dotnet build 為例 dotnet build 指令的程式碼，可以在這裡看到 BuildCommandParser.cs 將 build 指另註冊在 dotnet 命令清單的起始點 BuildCommand.cs 是將在命令視窗裡所下的指令做參數的解析並轉換成 msbuild 的建置參數 1234567891011121314151617181920...var appliedBuildOptions = result["dotnet"]["build"];msbuildArgs.Add($"-consoleloggerparameters:Summary");if (appliedBuildOptions.HasOption("--no-incremental"))&#123; msbuildArgs.Add("-target:Rebuild");&#125;else&#123; msbuildArgs.Add("-target:Build");&#125;msbuildArgs.AddRange(appliedBuildOptions.OptionValuesToBeForwarded());msbuildArgs.AddRange(appliedBuildOptions.Arguments);bool noRestore = appliedBuildOptions.HasOption("--no-restore");... 由於 build 命令所使用的 BuildCommand 是繼承 RestoringCommand source code 來的，所以預設有 restore 的動作，這也是為什麼在文件上說，在建置前不需要執行 dotnet restore 的原因了。 最後當執行 cmd.Execute() 時，會執行 MSBuildForwardingApp.cs 裡的 Execute 方法，在之後的細節就是根據當下的執行環境找到對的執行檔執行命令，有興趣的可以在從這邊繼續追 以上就是簡單描述當 dotnet cli 命令執行時，到底做哪些事情的筆記 參考資料 .NET Core 工具中變更的高階概觀 dotnet cli repo 適用於 .NET Core 之 csproj 格式的新增項目]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET Core] Identity - Part 2 整合 firebase 的登入驗證服務]]></title>
    <url>%2F2018%2F06%2F03%2Faspnet-core-authentication-with-firebaesToken%2F</url>
    <content type="text"><![CDATA[上一篇文章介紹了 Google 登入的行為，但是如果遇到前後端分離的狀況，似乎就有點不適合了，聽說 firebase 這登入的功能與前端整合的不錯，是否能透過 firebase 來完成呢? 答案是可以的，透過 JWT Token 的驗證模式就可以達到我們所需的功能，相關的運作流程可參考此圖 (圖片來自 https://blog.markvincze.com/secure-an-asp-net-core-api-with-firebase/) 前端設定 當透過 firebase 登入成功後，我們可以取得 idToken，(注意，不是 accessToken)。如果是透過 AngularFireAuth 套件登入時，可以透過以下的方式取得 123this.afAuth.idToken.subscribe(token =&gt; &#123; this.idToken = token; &#125;); 當然也需要將這一個 token 隨著每一次的 http request 送出到 api 端供驗證使用，可以建立一個 HttpInterceptor 來處理這一件事情 1234567891011121314@Injectable()export class TokenInterceptor implements HttpInterceptor &#123; constructor(private authService: AuthService) &#123;&#125; intercept( request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; request = request.clone(&#123; setHeaders: &#123; Authorization: `Bearer $&#123;this.authService.idToken&#125;` &#125; &#125;); return next.handle(request); &#125;&#125; 也需要將 HttpInterceptor 註冊到 AppModule 下，這裡需要注意的是，HttpClientModule 只能在 Root Module 註冊一次，不然 Httpinterceptor 會失效 123456789101112131415@NgModule(&#123; declarations: [AppComponent], imports: [ ... ], providers: [ &#123; provide: HTTP_INTERCEPTORS, useClass: TokenInterceptor, multi: true &#125; ], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 後端設定 後端的設定其實還蠻容易的，因為有人已經將要設定的部分包裝成一個 Extension 套件，只要安裝並在 Startup.cs 內設定就可以完成了，操作步驟如下 安裝 套件 123Install-Package AspNetCore.Firebase.Authentication// 或是dotnet add package AspNetCore.Firebase.Authentication 在 Startup.cs 內新增 1234567891011121314public void ConfigureServices(IServiceCollection services)&#123; ... var FirebaseAuthentication_Issuer = "https://securetoken.google.com/&lt;firebase project id&gt;"; var FirebaseAuthentication_Audience = "&lt;firebase project id&gt;"; services.AddFirebaseAuthentication(FirebaseAuthentication_Issuer, FirebaseAuthentication_Audience);&#125;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&#123; ... app.UseAuthentication();&#125; 注意: app.UseAuthentication() 必須在 app.UseMvc() 之前 到這邊就已經完成了整個的驗證設定了，在 Web API 的部分，與一般的設定是相同的，在需要控管的 API 前面加上 [Authorize] 就可以了 取得Token資料 如何從 Token 內取得資訊呢，以下提供幾個取得資料的範例 12345var tokenInfo = HttpContext.User;var uid = tokenInfo.FindFirst("user_id");var name = tokenInfo.FindFirst("name");var email = tokenInfo.FindFirst(ClaimTypes.Email); 可以透過 debug 的模式去看 HttpContext.User.Claims 內所包含的資訊，這些資訊應該會與前端傳來的 token 資訊差不多，那這時就可以透過 findFirst 的方法取得資料，取出來的只是一個資料物件，真正的值需要在用 .Value 來取得，例如 email.Value Recap 透過第三方與各大平台進行第三方的登入驗證，真的很簡單又快速。如果想要再跟 Identity 做整合的話，也是可以快速結合。提供此方法給大家參考看看 下列的參考資料的第一篇文章的做法，不知道哪裡設定上有問題，一直會取得 401 的錯誤，而單純的使用套件就過了。但文章內的其他概念說明是可以閱讀的 參考資料 Secure an ASP.NET Core api with Firebase AspNetCore.Firebase.Authentication]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET Core] Identity - Part 1 使用 Google 登入]]></title>
    <url>%2F2018%2F05%2F31%2Faspnet-core-identity%2F</url>
    <content type="text"><![CDATA[ASP.NET Core 有提供身分認證 管理的功能，叫做 Identity，此外也有提供多種的驗證方式，但許多時候因為建立專案時就已經有包含進去了，通常很容易忽略如何從無到有的新增步驟，此篇文章特意整理相關的資訊 這篇會分兩部分，一是建立 Identity 的環境，二是如何使用 Google OAuth 的方式登入 前置環境設定 要新增 Identity 的功能到 asp.net core 的程式裡，需要在 Startup.cs 先做以下的設定 預設前置條件，設定 Entity Framework，因為 Identity 預設需要 EF 的支援 a. EF Core 預設已經包含在 Microsoft.AspNetCore.All 的套件包內，所以不需要另外安裝 b. 設定連線字串，儲存參數的方式有很多種，這裡先用最簡單(但不推薦)的方式處理，細節請參閱。建立一個 appsettings.json 檔案，並將資料庫連線字串存放在此 12345&#123; "ConnectionStrings": &#123; "DefaultConnection": "Data Source=&lt;DB_IPAddress&gt;;DataBase=&lt;DBName&gt;;Persist Security Info=True;User ID=&lt;UserName&gt;;Password=&lt;UserPassword&gt;" &#125;,&#125; c. service 加入 EF 服務 1234567public void ConfigureServices(IServiceCollection services)&#123; // Add framework services. services.AddDbContext&lt;StreamDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); ...&#125; d. 建立 StreamDbContext ，並繼承 IdentityDbContext&lt;TUser&gt; 12345678910111213using Microsoft.AspNetCore.Identity.EntityFrameworkCore;using Microsoft.EntityFrameworkCore;using stream_tools.Models;namespace stream_tools&#123; public class StreamDbContext : IdentityDbContext&lt;ApplicationUser&gt; &#123; public StreamDbContext(DbContextOptions&lt;StreamDbContext&gt; options) : base(options) &#123; &#125; &#125;&#125; e. 使用 EF migration 更新資料表結構 1234// 建立 Identity Store 所需要的資料表dotnet ef migrations add &lt;migration-name&gt;// 更新至資料庫dotnet ef database update f. 更新完成後，會多出以下的資料表 在 ConfigureServices 的地方加入 Identity 的服務 123456789101112131415161718using Microsoft.AspNetCore.Identity;...public class Startup&#123; // 可取得設定檔內容 public IConfiguration Configuration &#123; get; set; &#125; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public void ConfigureServices(IServiceCollection services) &#123; ... services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;() .AddEntityFrameworkStores&lt;StreamDbContext&gt;() .AddDefaultTokenProviders(); &#125;&#125; 建立 ApplicationUser Class 123456789using Microsoft.AspNetCore.Identity;namespace stream_tools.Models&#123; public class ApplicationUser : IdentityUser &#123; // 資訊擴充使用 &#125;&#125; 在 Configure 的地方啟動服務 123456public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; ... app.UseAuthentication(); ... &#125; 因為需要 MVC 來提供頁面，所以也順便加入 MVC 的功能 1234567891011public void ConfigureServices(IServiceCollection services) &#123; ... services.AddMvc();&#125; public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; ... app.UseMvc(); ... &#125; 設定 Google API 首先前往 https://console.developers.google.com/projectselector/apis/library ，開立新專案或選取舊專案 開啟 Google+ API 供登入使用 點選憑證，並新增 OAuth 選擇 網路應用程式，並填入以下資訊 這裡須留意的是 已授權的重新導向 URI，Identity 預設的路由是 signin-google ，所以只需要替換前面的 port 號碼即可 確定後會取得一份 client_id 和 secret 的資訊，我們需要將這資訊儲存到上面所建立的 appsetting.json 檔案內 設定 Google 登入 在官網的文件中，文件將 用戶端 ID 與 用戶端密碼，分別使用 Authentication:Google:ClientId 與 Authentication:Google:ClientSecret 12345&#123; ... "Authentication:Google:ClientId": "用戶端 ID", "Authentication:Google:ClientSecret": "用戶端密碼"&#125; 加入新的 Authentication 方式 12345678public void ConfigureServices(IServiceCollection services)&#123; services.AddAuthentication().AddGoogle(googleOptions =&gt; &#123; googleOptions.ClientId = Configuration["Authentication:Google:ClientId"]; googleOptions.ClientSecret = Configuration["Authentication:Google:ClientSecret"]; &#125;);&#125; 當然除了 google 之外，還有其他的服務可以使用，其他資訊補充在下面的參考資料內 到這邊為止，基礎設定已經完成了。現在是在頁面上要怎麼使用，Controller 的動作又是如何呢? Controller - View View 如果是使用 Razor 的方式要產生第三方登入選項的方式，其實很簡單，只要透過 SignInManager.GetExternalAuthenticationSchemesAsync() 的方式就可以取得有開啟的選項 12345678910111213141516@using stream_tools.Models@inject SignInManager&lt;ApplicationUser&gt; SignInManager&lt;form asp-action="ExternalLogin" asp-route-returnurl="@ViewData["ReturnUrl"]" method="post" class="form-horizontal"&gt; &lt;div&gt; &lt;p&gt; @&#123; var loginProviders = (await SignInManager.GetExternalAuthenticationSchemesAsync()).ToList(); &#125; @foreach (var provider in loginProviders) &#123; &lt;button type="submit" class="btn btn-default" name="provider" value="@provider.Name" title="Log in using your @provider.DisplayName account"&gt;@provider.Name&lt;/button&gt; &#125; &lt;/p&gt; &lt;/div&gt;&lt;/form&gt; loginProviders 清單內的 provider ，內容如下 所以當按下按鈕時，就會做 Form Post 的動作到 Account/ExternalLogin 的 Action Controller (重點) 12345678[HttpPost]public IActionResult ExternalLogin(string provider, string returnUrl = null)&#123; // Request a redirect to the external login provider. var redirectUrl = Url.Action(nameof(ExternalLoginCallback), "Account", new &#123; returnUrl &#125;); var properties = _signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl); return Challenge(properties, provider);&#125; 當此 Action 接受到前面頁面 Post 動作時，就會先將登入成功後要轉址的位址轉成 Url 的方式，這裡就會回到 Account/ExternalLoginCallback 的地方 signInManager.ConfigureExternalAuthenticationProperties 再將額外的資訊包成一個 property 後再送給 Challenge method 最後續的行為 signInManager 是一個用來控制使用者登入的 API，文件連結已列在下面的參考文件中 Challenge 是 ControllerBase 裡的方法之一，會建立出一個 ChallengeResult ，ChellengerResult is an ActionResult that on execution invokes AuthenticationManager.ChallengeAsync. provider 的值，就如上圖所顯示的，只是將 name 的值傳進來，而這裡是帶入 Google 當執行後就會跑到Google 登入帳號的畫面，當完成 Google 帳號登入後，就會回到 Account/ExternalLoginCallback 的地方 1234567891011121314151617181920212223242526272829303132333435public async Task&lt;IActionResult&gt; ExternalLoginCallback(string returnUrl = null, string remoteError = null) &#123; if (remoteError != null) &#123; ErrorMessage = $"Error from external provider: &#123;remoteError&#125;"; return RedirectToAction(nameof(Login)); &#125; var info = await _signInManager.GetExternalLoginInfoAsync(); if (info == null) &#123; return RedirectToAction(nameof(Login)); &#125; // Sign in the user with this external login provider if the user already has a login. var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false, bypassTwoFactor: true); if (result.Succeeded) &#123; // 使用者帳號已存在，可以直接前往目的地 return RedirectToLocal(returnUrl); &#125; if (result.IsLockedOut) &#123; // 使用者帳號被鎖定 return RedirectToAction(nameof(Lockout)); &#125; else &#123; // If the user does not have an account, then ask the user to create an account. ViewData["ReturnUrl"] = returnUrl; ViewData["LoginProvider"] = info.LoginProvider; var email = info.Principal.FindFirstValue(ClaimTypes.Email); return View("ExternalLogin", new ExternalLoginViewModel &#123; Email = email &#125;); &#125; &#125; 當登入動作完成後回到 ExternalLoginCallback Action 時會收到兩個資訊，一個是遠端授權的錯誤訊息，一個是登入成功後要轉址的位置 取得第三方授權請求的附加資訊，可透過 var info = await _signInManager.GetExternalLoginInfoAsync(); 的方式取得更多的資訊 舉例，如果要取得 email，取得方法是 info.Principal.FindFirstValue(ClaimTypes.Email); ClaimTypes 的 Enum 還有更多其他的項目可以使用 var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false, bypassTwoFactor: true); ExternalLoginSignInAsync 的方法是當透過外部驗證方式成功後，回到系統內時，執行內部的登入動作，而回傳的結果，可用來判斷該使用者的狀況是否能繼續往下走 參數設定 CallbackPath: 這個參數的值是設定 Google API 在 重新導向 URI 的內容，預設是 /signin-google，如果想要改變時，可以修改這個設定 12345services.AddAuthentication().AddGoogle(googleOptions =&gt; &#123; googleOptions.CallbackPath = new PathString("/someurl-you-want"); ... &#125;); Scope: 在登入 Google 帳號時，我們可以透過 Scope 設定要向登入者取得額外的資訊，設定方式是 12345services.AddAuthentication().AddGoogle(googleOptions =&gt; &#123; googleOptions.Scope.Add(&apos;..&apos;); ... &#125;); 結論 到這邊可以算是一個完整的第三方驗證的流程，我認為這裡的流程即使改成使用 web api 的方式，應該也是可以做到一樣的效果，這部分等我實作出來後，在分享出來 參考資料 [.NET Core] Web MVC 001 - program.cs 安全存放裝置的開發工作中 ASP.NET Core 應用程式密碼 EF Core .NET Command-line Tools Introduction to Identity on ASP.NET Core identity-without-entity-framework ASP.NET Core 中的 Facebook、Google 及外部提供者驗證 API DOC Source Code SignInManager API Doc ChallengeResult]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何測試含有 delay 的 observable?]]></title>
    <url>%2F2018%2F05%2F18%2Fangualr-testing-delay%2F</url>
    <content type="text"><![CDATA[Angular 內要測試 Observable 的方式有很多種，但有一種東西很難測，就是當遇到控制時間相關的 operators 出現時，測試就變得很有趣了。這篇文章整理一下如何測試這一類的 observable 前題 這裡有一個需要被測試的動作，這裡我需要測試在 n 秒後，我一開始 push 到陣列裡面的資料，是否會被移出陣列，當 this.message$.next(...) 的時候，就會同時間觸發一個 remover$ (定時器，用來移除資料用)。所以問題是，我要如何測試這段程式碼邏輯呢? 1234567891011121314message$ = this.service.message$;messages: CommandModel[] = [];tasks$ = new Subject&lt;Observable&lt;any&gt;&gt;();remover$ = of('').pipe( delay(environment.delayTime), tap(() =&gt; this.messages.shift()));...this.tasks$.pipe(mergeMap(task =&gt; task)).subscribe();this.message$ .pipe(tap(value =&gt; this.messages.push(&#123; ...value &#125;))) .subscribe(value =&gt; &#123; this.tasks$.next(this.remover$);&#125;); RxJS 6 版以後，提供了一個 TestScheduler 可以讓我們來做 Observable 的測試，這裡整理出如何測試 delay 這一個東西，(花了我一個下午，看了 n 篇文章後，整理出來的結果) TestScheduler 在講實際測試程式碼前，有幾個東西需要介紹一下 1234const testScheduler = new TestScheduler((actual, expected) =&gt; &#123; // 這裡寫 jasmine 的 expect 的比較程式碼 // expect(component.messages.length).toBe(0);&#125;); 當建立完 TestScheduler 後會回傳一個物件，再來就可以透過這一個物件來跑我們要測試的 observable 1234testScheduler.run((&#123; cold, expectObservable &#125;) =&gt; &#123; // marble testing 的程式碼寫在這邊 &#125;); 當執行 .run((...)=&gt;{}) 的 callback functions 會有一個系列的參數可以使用 1234testScheduler.run(helpers =&gt; &#123; const &#123; cold, hot, expectObservable, expectSubscriptions, flush &#125; = helpers; // use them&#125;); API hot(marbleDiagram: string, values?: object, error?: any) - 建立一個 Hot observable (像 Subject)，當測試開始時，預設行為是一個已經啟動的 observable， 與 cold 的差異是 hot 可以使用 ^ 這個符號^ 是用來標示 Zero frame 的位置，這一個位置是 observable 真正開始的位置. cold(marbleDiagram: string, values?: object, error?: any) - 建立一個 Cold Observable ，測試開始時，observable 才會被啟動. expectObservable(actual: Observable&lt;T&gt;).toBe(marbleDiagram: string, values?: object, error?: any) - 排程一個 assertion 給 TestScheduler.flushes 執行. expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string) - 類似 expectObservable ，cold() 和 hot() 都會回傳一個含有型別為 SubscriptionLog[] 的subscriptions 的 observable，將該 subscriptions 傳給 expectSubscriptions 去比較是否有符合 subscriptionsMarbles marble diagram 所給予的期待值. flush() - 立即執行虛擬時間，但因為 run() 當 callback 回傳時就會自動更新，所以比較少使用，但在某些特殊情況下，還是會手動觸發 flush 的動作 驗證測試程式碼 以下是我用來測試 delay 的程式碼 123456789101112131415import &#123; TestScheduler &#125; from 'rxjs/testing';...it('should clear out meesages array after 3 sec', () =&gt; &#123; const testScheduler = new TestScheduler((actual, expected) =&gt; &#123; expect(component.messages.length).toBe(0); &#125;); testScheduler.run((&#123; cold, expectObservable &#125;) =&gt; &#123; const input = cold('-a--|'); const output = input.pipe(tap(v =&gt; component.message$.next(&#123;&#125; as any))); const expected = '-- 2999ms a ---|'; expectObservable(component.remover$).toBe(expected); &#125;);&#125;); 彈珠圖符號說明 有看到在 cold 裡面的文字，那個既是所謂的彈珠圖表示法，以下是符號的說明 ' ' 空白: 水平空白會被忽略，可用來與其他的彈珠圖對齊使用 '-' frame: 1 個frame 代表一個單位的虛擬時間的流逝，可設定每一個 frame 的時間長度. [0-9]+[ms|s|m] 時間進行: 可利用數字搭配時間單位來表示一個長時間的虛擬時間的進行，時間單位有 ms (milliseconds), s (seconds), or m (minutes) ，數字與單位中間沒有任何空白 e.g. a 10ms b '|' 完成(complete): 表示一個成功完成的事件，會觸發 complete() 事件. '#' 錯誤(error): 表示發生錯誤發生，會觸發 error() 事件. [a-z0-9] e.g. 'a' 任何英文數字符號，代表 next() 時會送出的值. '()' 同步群組(sync groupings): 在同一個時間點需要呈現多個事件時，可利用 () 的方式包起來，在小括弧內的事件，都是發生在同一個時間點的，這裡要留意的是使用 () 的 frame 計算方式，即便 () 內的資料是發生在同一個 frame，但問題下一次的資料 frame 卻不是如現實世界的計算方式，而是需要將 (...) 的文字總長度計算進去，例如: (abc).lenght == 5 ，而下一個 emit framer 就是 n+5 開始 123456789testScheduler.run((&#123; hot, cold, expectObservable &#125;) =&gt; &#123; const expectedMarble = "(abc)(d)e"; const before$ = concat(of("a"), of("b")); const fetch$ = cold("-----d--e"); const exp = hot("a").pipe( switchMap(() =&gt; concat(before$, of("c"), fetch$)) ); expectObservable(exp).toBe(expectedMarble); &#125;); '^' subscription point: (hot 限定) 其他更細節的說明，可以參考下面的參考文件了 參考文件 marble-testing angular.io - testing demo - index.test.js]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] TestBed 之 override 系列]]></title>
    <url>%2F2018%2F05%2F03%2Fangular-testbed%2F</url>
    <content type="text"><![CDATA[Angular TestBed 是 Angular 團隊提供用來設定測試環境的方法，TestBed 可以讓我們用最簡單的方式設定好一個測試用的 NgModule，除了常見的幾個方法外，還提供一系列的 override 的方法，但是卻沒有相關的文件說明，所以這篇文章就是來解釋如何使用 override 方法 介紹 TestBed Override 系列 根據官方文件, TestBed 提供的 override 方法有 overrideModule overrideComponent overrideDirective overridePipe overrideTemplate overrideTemplateUsingTestingModule overrideProvider 以下就先以 overrideModule 與 overrideProvider 作範例，其他會在後面在說明 OverrideModule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@NgModule(&#123; declarations: [DemoComponent], providers: [ &#123; provide: ActivatedRoute, useValue: &#123; data: of(&#123; actionType: 'abc' &#125;) &#125; &#125; ]&#125;)class SomeModule &#123;&#125;describe('DemoComponent', () =&gt; &#123; let component: DemoComponent; let fixture: ComponentFixture&lt;DemoComponent&gt;; beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [SomeModule] &#125;); &#125;)); describe('原始 module 測試', () =&gt; &#123; beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(DemoComponent); component = fixture.componentInstance; fixture.detectChanges(); &#125;); it('actionType should equal abc', async(() =&gt; &#123; expect(component.actionType).toBe('abc'); &#125;)); &#125;); describe('override 後 module 測試', () =&gt; &#123; beforeEach(() =&gt; &#123; TestBed.overrideModule(SomeModule, &#123; set: &#123; providers: [ &#123; provide: ActivatedRoute, useValue: &#123; data: of(&#123; actionType: '123' &#125;) &#125; &#125; ] &#125; &#125;); &#125;); beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(DemoComponent); component = fixture.componentInstance; fixture.detectChanges(); &#125;); it('actionType should equal 123', async(() =&gt; &#123; expect(component.actionType).toBe('123'); &#125;)); &#125;); 以 overrideModule的字面上來解釋，就是可以複寫第一次所設定的 TestingModule 的內容，由於 overrideModule 需要指定要複寫的 module 名稱，所以先建立一個初始 NgModule 後，在 TestingModule 時將其 import 進來。執行的結果會是一樣的 這裡需要留意的是 TestBed.createComponent 的時間點，一旦 component 被建立後，就無法被複寫了，這裡要注意 overrideProvider 但我們只想更換 provider 的部分，真的有需要寫的那麼複雜嗎? TestBed 有提供 overrideProvider 的方法可以使用，寫法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950describe('DemoComponent', () =&gt; &#123; let component: DemoComponent; let fixture: ComponentFixture&lt;DemoComponent&gt;; beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [DemoComponent], providers: [ &#123; provide: ActivatedRoute, useValue: &#123; data: of(&#123; actionType: 'abc' &#125;) &#125; &#125; ] &#125;); &#125;)); describe('原使 module 測試', () =&gt; &#123; beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(DemoComponent); component = fixture.componentInstance; fixture.detectChanges(); &#125;); it('actionType should equal abc', async(() =&gt; &#123; expect(component.actionType).toBe('abc'); &#125;)); &#125;); describe('修正後的 provider 測試', () =&gt; &#123; beforeEach(() =&gt; &#123; TestBed.overrideProvider(ActivatedRoute, &#123; useValue: &#123; data: of(&#123; actionType: 'def' &#125;) &#125; &#125;); &#125;); beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(DemoComponent); component = fixture.componentInstance; fixture.detectChanges(); &#125;); it('actionType should equal def', async(() =&gt; &#123; expect(component.actionType).toBe('def'); &#125;)); &#125;);&#125;); overrideComponent overrideComponent 也是另外一個很常見的測試技巧，尤其是在測試 directive的時候，這技巧就非常實用 12345678910111213141516171819202122232425262728293031323334353637383940@Component(&#123; selector: 'app-host-comp', template: ''&#125;)class HostComponent &#123;&#125;describe('HighlightDirective', () =&gt; &#123; let fixture: ComponentFixture&lt;HostComponent&gt;; beforeEach( async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [HostComponent, HighlightDirective] &#125;); &#125;) ); function createComponent() &#123; fixture = TestBed.createComponent(HostComponent); fixture.detectChanges(); &#125; it('should highlight with cyan', () =&gt; &#123; TestBed.overrideComponent(HostComponent, &#123; set: &#123; template: `&lt;p highlight="cyan"&gt;empty&lt;/p&gt;` &#125; &#125;); createComponent(); const de = fixture.debugElement.query(By.css('p')); expect(de.nativeElement.style.backgroundColor).toBe('cyan'); &#125;); it('should highlight with yellow', () =&gt; &#123; TestBed.overrideComponent(HostComponent, &#123; set: &#123; template: `&lt;p highlight&gt;empty&lt;/p&gt;` &#125; &#125;); createComponent(); const de = fixture.debugElement.query(By.css('p')); expect(de.nativeElement.style.backgroundColor).toBe('yellow'); &#125;);&#125;); overrideTemplate 如果只是想要替換 template 的部分，有更簡便的寫法，可使用 TestBed.OverrideTemplate(&lt;Component&gt;, &lt;template string&gt;) 來達成一樣的效果 12345678910111213141516171819202122232425262728293031import &#123; TestBed, async, ComponentFixture &#125; from '@angular/core/testing';import &#123; Component &#125; from '@angular/core';import &#123; DemoComponent &#125; from './demo.component';@Component(&#123; selector: 'app-host-comp', template: ''&#125;)class HostComponent &#123;&#125;describe('DemoComponent', () =&gt; &#123; let fixture: ComponentFixture&lt;HostComponent&gt;; let app: HostComponent; function createComponent() &#123; fixture = TestBed.createComponent(HostComponent); app = fixture.debugElement.componentInstance; fixture.detectChanges(); &#125; beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [HostComponent, DemoComponent] &#125;); &#125;)); it(`testing overrideTemplate`, async(() =&gt; &#123; TestBed.overrideTemplate(HostComponent, `&lt;app-demo title="app2"&gt;&lt;/app-demo&gt;`); createComponent(); expect(fixture.nativeElement.querySelector('p').innerText).toEqual('app2'); &#125;));&#125;); 結論 TestBed 是一個很方便的工具，除了使用 spyObject 的方式，這一種方式也不錯，分享給大家 延伸閱讀 TestBed Directive Testing]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何將 OBS 的畫面送到 ZOOM.US 軟體中?]]></title>
    <url>%2F2018%2F05%2F01%2Fobs-streaming-zoom%2F</url>
    <content type="text"><![CDATA[ZOOM 是一套很好用的線上開會工具，透過月租的服務，可享用一場 100 人可以同時間線上開會，這也是我每周三主持 Angular 線上讀書會的主要工具 有人問我說，能不能將 OBS 的直播畫面輸出給 ZOOM 使用，因為他想要利用 OBS 的畫面編排功能及背景去背，讓自己的視訊畫面能和桌面融為一體，所以才有這篇文章的產生 作法更新 (2020/03/09 更新) 跟下面的概念是一樣的，OBS 本身有提供 Fullscreen Projector(preview) 的功能，當然這做法需要多顆螢幕，但延遲會相對的少很多，僅供參考。怎麼使用 Fullscreen Projector 呢，在預覽視窗上按滑鼠右鍵叫出選單，即可看到此選項，這時候就選擇要投影的螢幕是哪一個。而 Zoom 的部分就分享桌面即可 前言 在這之前，要先介紹 NewTek 這間公司所提出的新技術 NDI，這一門黑科技讓直播能做的事情到達另外一個不可思議的境界，以往在攝影機與主控台間需要透過拉 SDI 的線來傳遞訊號，而 SDI 的線材又很貴。這還不含器材的部分，總之做一場直播是很貴的 不使用 HDMI 的原因是 HDMI 的線材在一定長度後，訊後會衰減，並不適合大場地使用 NDI 這技術可以讓我們使用網路線來做到 SDI 的效果，且延遲是非常低的。NewTek 也好心地將這個技術免費釋出，讓其他硬體/軟體廠商可以將這個協定實作在自家的產品上，這裡有幾個比較有名的 vMix xSplit OBS (需安裝套件 obs-ndi) PTZOptics NewTek Connect Spark 這裡我們就用免費的 OBS 來做示範 環境設定 安裝 OBS 安裝 OBS-NDI 會要求安裝 NDI 3.0 Runtime 安裝 NewTek Tools ，只需要安裝 portable 版本即可，我們只需要 NDI Studio Monitor 當安裝完以上的東西後，應該會被要求重啟電腦。電腦重新啟動後，就可以打開 OBS 的程式 在 Tools 的地方，點選 NDI Output settings 勾選 【Enable NDI Output】 這樣 OBS 就會將你的訊號，用 NDI 的模式發送出去，只要在你的區域網域內，支援 NDI Input 的軟體或導播機，都可以搜尋的到 開啟【NewTek NDI Studio Montiro】 選擇訊號來源 檢視 OBS NDI 訊號輸出結果 由於我們要將這一個視窗透過 ZOOM 分享的方式，顯示給其他與會者看。所以還有兩個地方要做調整 視窗的 border 要隱藏 聲音音量的顯示，要將 VU Meter 關掉 完成設定，剩下的就是用 Zoom 分享這一個視窗應用程式 這裡要注意一點，當你點選 Hide Window 時，該視窗就無法再移動了，所以如果有第二顆螢幕或是第二台電腦時，這一個分享的動作，可以在另外一個地方進行。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 與 Firebase 共舞]]></title>
    <url>%2F2018%2F04%2F30%2Fangular-firebase%2F</url>
    <content type="text"><![CDATA[Firebase 存在於這世上已經有幾年的時間了，後來有併入到 Google 的旗下。而這一年來 Firebase 的功能與服務，不論是威力或是廣度都遠比剛出道時，來的強大許多。 這一次透過寫一個 side project 來重新探索 Firebase 的威力 環境準備 ※ 這裡預先假設你已經有一個 Angular 的專案，如果沒有的話，可以透過 Angular CLI 產生 ※ 於 Firebase 的後臺管理建立一個新的專案 Angular 有一個套件 Angularfire2 ，將 Firebase 會用到的功能包起來，能讓我們簡單的使用. 安裝使用方式如下 安裝 Angularfire2 1npm install firebase angularfire2 --save 取得 Firebase 專案的設定檔 複製紅色框起來的設定檔的部分 將 AngularFireModule 加到 app.module.ts 裡 123456789101112131415161718export const config = &#123; apiKey: "...", authDomain: "...", databaseURL: "...", projectId: "...", storageBucket: "...", messagingSenderId: "..." &#125;;@NgModule(&#123; ... imports: [ BrowserModule, AngularFireModule.initializeApp(config), ], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 也可以將 config 的部分放到 environement 檔案內做管理 完成基本設定 Firebase 常用功能 Firebase 除了提供 Realtime 資料庫外，也多了 Authentication 、Cloud Firestore、Hosting、Stroage 與 Functions 的服務，這裡就先介紹 Authentication 、Cloud Firestore、Hosting 與 Functions 在開始之前，要先安裝 firebase-tools，這工具可以協助我們開發及部屬 Firebase 的功能 安裝 Firebase Tools 安裝 Firebase-tools (如果之前有裝過，這個步驟可以跳過) 1npm install -g firebase-tools 到 Angular 專案下，執行 firebase init 進行第一次環境初始化設定，跟著畫面上的步驟依序執行，完成後就會產生一個 .firebase.json 與 .firebaserc 的檔案，分別記載相關的環境參數供後續的部屬使用 Authentication 使用者登入授權是一件很麻煩的事情，尤其是要使用各種方式登入，例如使用 Google、GitHub、Facebook 等帳號登入，光是串聯這一些就會有想放棄的念頭，好加在 Firebase 的 authentication 幫我們處理這一塊的事情，我們只需要將環境參數設定完，就可以直接使用 於 Authentication 的區塊有四個選項 使用者：目前有登入註冊到 Firebase 專案下的使用者有哪些 登入方式：設定要連接的授權服務 設定要使用的登入授權方式 紀錄允許使用 Authentication 的網域名稱 範本：寄信通知的內容範本 用量：統計電話驗證實例 的使用量 所以後台的畫面就這些，而要如何開啟個服務的登入授權呢，基本上裡面的設定步驟都寫得很詳細，跟著做就不會錯 回到 Angular 程式內，我們要怎麼寫才能使用這些服務呢? 基本寫法如下 注入 AngularFireAuthModule 到 AppModule 內 建立一個 service 或是直接在 component 寫都可以 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Injectable &#125; from '@angular/core';import &#123; AngularFireAuth, AngularFireAuthProvider &#125; from 'angularfire2/auth';import * as firebase from 'firebase/app';import &#123; User &#125; from '@firebase/auth-types';import &#123; Router &#125; from '@angular/router';@Injectable()export class AuthService &#123; authState = this.afAuth.authState; constructor(public afAuth: AngularFireAuth, private router: Router) &#123;&#125; // 使用匿名登入 signInAnonymously() &#123; return this.afAuth.auth.signInAnonymously() .then(this.redirectToPopup()); &#125; // 使用 Google 登入 signInWithGoogle() &#123; return this.afAuth.auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()) .then(this.redirectToPopup()); &#125; // 使用 GitHub 登入 signInWithGithub() &#123; return this.afAuth.auth.signInWithPopup(new firebase.auth.GithubAuthProvider()) .then(this.redirectToPopup()); &#125; // 登出 signOut() &#123; this.afAuth.auth.signOut(); &#125; private redirectToPopup() &#123; return () =&gt; this.router.navigate(['/popup']); &#125;&#125; 基本上各服務商的登入寫法都差不多，詳細的設定可以參考這裡 那要怎麼判斷使用者有沒有登入呢? 123this.authService.authState.subscribe(user =&gt; &#123; // user 登入資訊物件 &#125;); 如果使用者有登入的話，user 就會包含相關的登入資訊，如果沒有就會收到 null 值 以上就是基本的 Authentication 的用法 Database Firebase 有兩種資料庫類型，但皆屬於 NoSQL 類型的資料庫，可是兩者的應用情境是不相同的 Realtime Database：為所有連結的用戶端即時存儲及同步處理資料 Cloud Firestore：新一代即時資料庫擁有更強大的查詢撼動調整資源配置功能 兩者的比較表可參考說明文件 這裡只會介紹 Firestore 資料庫 Firestore Firestore 主要分為兩種類型的資料，document 與 collection，顧名思義 document 就是單一筆紀錄，而 collection 是包含許多 documents collection 對於每一個 document 都會有一個 id 的鍵值，用來讀取之用，這一個 ID 可以是自己建立，或是由 firebase 產生給你，須為唯一值 document 除了 field 外，裡面還可以建立 collection ，每一個 document 的檔案大小是有限制的，請參閱說明文件 欄位型別有這些 資料預設的排序順序為 Null values Boolean values Integer and floating-point values, sorted in numerical order Date values Text string values Byte values Cloud Firestore references Geographical point values Array values Map values 關於資料庫的設計規劃方式，可能要留在以後的文章做討論了 Angular 程式 Angular 內要如何操作 collection 和 document 呢? 首先要先 import AngularFirestoreModule 到 AppModule 裡 基本操作 Collection 基本撈資料的方式 123456789101112131415161718192021222324252627import &#123; Component &#125; from '@angular/core';import &#123; AngularFirestore, AngularFirestoreCollection &#125; from 'angularfire2/firestore';import &#123; Observable &#125; from 'rxjs/Observable';export interface Item &#123; name: string; &#125;@Component(&#123; selector: 'app-root', template: ` &lt;ul&gt; &lt;li *ngFor="let item of items | async"&gt; &#123;&#123; item.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class AppComponent &#123; private itemsCollection: AngularFirestoreCollection&lt;Item&gt;; items: Observable&lt;Item[]&gt;; constructor(private afs: AngularFirestore) &#123; this.itemsCollection = afs.collection&lt;Item&gt;('items'); this.items = this.itemsCollection.valueChanges(); &#125; addItem(item: Item) &#123; this.itemsCollection.add(item); &#125;&#125; 新增 document 至 collection 中 123addItem(item: Item) &#123; this.itemsCollection.add(item);&#125; 如果要更新 document 裡面的某一筆紀錄時，則需要針對 document 做操作，這部分會在下面做說明 Document 的操作 讀取特定的 document 12345678910111213141516@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &#123;&#123; (item | async)?.name &#125;&#125; &lt;/div&gt; `&#125;)export class AppComponent &#123; private itemDoc: AngularFirestoreDocument&lt;Item&gt;; item: Observable&lt;Item&gt;; constructor(private afs: AngularFirestore) &#123; this.itemDoc = afs.doc&lt;Item&gt;('items/1'); this.item = this.itemDoc.valueChanges(); &#125;&#125; 新增 123create(item: Item)&#123; this.itemDoc = afs.doc&lt;Item&gt;('items/1').set(item)&#125; 修改 123update(item: Item) &#123; this.itemDoc.update(item); &#125; 刪除 123delete(item: Item) &#123; this.itemDoc.delete();&#125; 新增或修改 123createOrUpdate(item: Item)&#123; this.itemDoc = afs.doc&lt;Item&gt;('items/1').set(item,&#123; merge: true&#125;)&#125; valueChanges V.S. snapshotChanges 一般正常使用時，使用 valueChanges 已經足夠了，但如果我們需要獲取到更多資訊，例如 document 的 ID 時，這時候就得透過 snapshotChanges 才可以取得，以下示範如何取得 document ID 1234567891011121314151617181920212223242526272829303132333435import &#123; Component &#125; from '@angular/core';import &#123; AngularFirestore, AngularFirestoreCollection &#125; from 'angularfire2/firestore';import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map';export interface Shirt &#123; name: string; price: number; &#125;export interface ShirtId extends Shirt &#123; id: string; &#125;@Component(&#123; selector: 'app-root', template: ` &lt;ul&gt; &lt;li *ngFor="let shirt of shirts | async"&gt; &#123;&#123; shirt.name &#125;&#125; is &#123;&#123; shirt.price &#125;&#125; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class AppComponent &#123; private shirtCollection: AngularFirestoreCollection&lt;Shirt&gt;; shirts: Observable&lt;ShirtId[]&gt;; constructor(private readonly afs: AngularFirestore) &#123; this.shirtCollection = afs.collection&lt;Shirt&gt;('shirts'); this.shirts = this.shirtCollection.snapshotChanges() .pipe(map((actions:DocumentSnapshot[]) =&gt; &#123; return actions.map(a =&gt; &#123; const data = a.payload.doc.data() as Shirt; const id = a.payload.doc.id; return &#123; id, ...data &#125;; &#125;); &#125;) ); &#125;&#125; 回傳型別介面 valueChanges：回傳所定義的 document 型別 snapshotChanges 12345678interface DocumentSnapshot &#123; exists: boolean; ref: DocumentReference; id: string; metadata: SnapshotMetadata; data(): DocumentData; get(fieldPath: string): any;&#125; stateChanges、auditTrail 123456789101112interface DocumentChangeAction &#123; //'added' | 'modified' | 'removed'; type: DocumentChangeType; payload: DocumentChange;&#125;interface DocumentChange &#123; type: DocumentChangeType; doc: DocumentSnapshot; oldIndex: number; newIndex: number;&#125; 更多的資訊可參閱此文件 進階查詢 在查詢資料時，當然可以使用 Firebase 所提供的查詢方式，配合使用。當然操作並不能像 SQL 一樣的有彈性，所以在規劃如何存放資料時，同時也要思考要如才能查詢到自己想要的資料 1afs.collection('items', ref =&gt; ref.where('size', '==', 'large')) 查詢的條件就放在 collection 的第二個參數的地方。 如果要組合多種的查詢條件時，可以這樣子寫 12afs.collection('items', ref =&gt; ref.where('size', '==', 'large') .where('color', '==', 'red')) 但還是有很多限制，詳細的說明，可參閱官網文件，務必要詳讀，官網文件內提出很多不能使用得查詢組合 以下是可使用的查詢方法 method purpose where Create a new query. Can be chained to form complex queries. orderBy Sort by the specified field, in descending or ascending order. limit Sets the maximum number of items to return. startAt Results start at the provided document (inclusive). startAfter Results start after the provided document (exclusive). endAt Results end at the provided document (inclusive). endBefore Results end before the provided document (exclusive). Hosting 透過 firebase tools 建立專案環境時，就會填入一些相關的資訊，例如，要上傳的網站檔案的資料夾位置，是否為 SPA 網站等資訊，當這些都設定完成後，可以透過一行指令即可完成網站部屬動作 1firebase deploy --only hosting 管理後台也會有相關的部屬/用量紀錄，當然也可以綁定自己的網域名稱 Functions 什麼是 Functions ? Firebase 的 Functions 可以針對 Firebase 服務行為而被觸發的小程序，例如我希望當 Cloud Firestore 有新增資料時，幫我將某些資料整理到另外一個 collection 裡面，這時候，就可以透過 functions 來幫忙處理，這裡就簡單地提供個範例做參考 123456789101112131415161718192021222324import * as functions from 'firebase-functions';import * as admin from 'firebase-admin';admin.initializeApp();exports.autoLikes = functions.firestore .document('videoDetails/&#123;videoId&#125;/shareBy/&#123;shareId&#125;') .onCreate((snapshot, context) =&gt; &#123; const videoId = context.params.videoId; const videoRef = admin .firestore() .collection('videos') .doc(videoId); return videoRef .get() .then(doc =&gt; &#123; const likes = doc.get('likes') || 0; const data = &#123; likes: likes + 1 &#125;; return videoRef.update(data); &#125;) .catch(err =&gt; console.log(err)); &#125;); 程式碼說明 exports.&lt;&gt; 這個會顯示在後台的 functions 列表中 functions.firestore.document('videoDetails/{videoId}/shareBy/{shareId}').onCreate：當某一個 document 或是 collection 發生 create, update, delete, and write 事件時 (這裡可以指定觸發事件) 取得網址變數 12可透過 &#123; params &#125; 的方式設定變數名稱const videoId = context.params.videoId; ​ 在之後的程式碼就寫要執行的動作 admin，可以不受權限控制存取 firebase 服務 1234567import * as admin from 'firebase-admin';admin.initializeApp();... admin.firestore() .collection('videos') .doc(videoId); ​ Recap Firebase 的功能很多也很強大，這裡沒有辦法全部都介紹到，例如權限的控制、檔案上傳的部分 如果想要快速建立出產品的試水溫，又不想要搞一堆後端的基礎建設，Firebase 是一個不錯的選擇 延伸閱讀 AngularFire2 Firebase Tools Angular Firebase Youtube頻道 Firebase 官方文件 Collections, documents, and fields Limitation Perform Simple and Compound Queries in Cloud Firestore Cloud Firestore Trigger Functions Firebase Functions]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 如何從 RxJS 5.x 升級至 RxJS 6?]]></title>
    <url>%2F2018%2F04%2F21%2Fangular-update-rxjs-to-6%2F</url>
    <content type="text"><![CDATA[RxJS 6 提供了更便利的 import 方式，而且套件檔案變小，也可以被 tree-shaking. 但是要如何快速地將 RxJS 5.x 版升級到 RxJS 6 版 ? 以下是升級步驟 方法一 升級 RxJS 至 5.5.1 (最新版) 更新至 RxJS 6 RxJS 6 npm install rxjs npm install rxjs-compat 使用 Angular CLI 6 1 ng update rxjs npm install rxjs-tslint 建立 migrate.tslint.json 12345678&#123; "rulesDirectory": ["node_modules/rxjs-tslint"], "rules": &#123; "update-rxjs-imports": true, "migrate-to-pipeable-operators": true, "collapse-rxjs-imports": true &#125;&#125; 執行 tslint-fix (可能需要多跑幾次) 1./node_modules/.bin/tslint -c migrate.tslint.json --project src/tsconfig.app.json --fix` 修正 tslint.json，將 rxjs 從 &quot;import-blacklist&quot; 中移除 建置整個專案確定升級成功 完成整個升級 RxJS 方法二 (快速版) 全域安裝 rxjs-tslint 1npm install -g rxjs-tslint 升級 RxJS 至 5.5.1 (最新版) 更新至 RxJS 6 RxJS 6 npm install rxjs npm install rxjs-compat 使用 Angular CLI 6 1 ng update rxjs 執行下列指令 1rxjs-5-to-6-migrate -p tsconfig.json 建置整個專案確定升級成功 完成整個升級 RxJS]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Tree-shakable providers]]></title>
    <url>%2F2018%2F04%2F10%2Fangular-new-injectable-feature%2F</url>
    <content type="text"><![CDATA[Angular 6 將 tree-shaking 觸手擴大到 provider 了，提供了新的設定方法讓 service 也可以被 tree-shaking 掉了，這對於最後產生出來的 bundle 檔案大小，會有很大的幫助。 緣由 根據官方文件的說法，註冊在 NgModule 下的 service 都無法被 tree-shaking 掉，主要是 Angular 無法判斷該 service 是否有在任何地方被使用著，任何地方都可能透過 injector.get 的方式取得 service，也是因為這個原因 Angular 必須把 service 包到 NgModule 裡。 目前的寫法 ( Angular 5.x ~ 2 版 )，就是 non-tree-shakable service 12345678910111213import &#123; Injectable, NgModule &#125; from '@angular/core';@Injectable()export class Service &#123; doSomething(): void &#123; &#125;&#125;@NgModule(&#123; providers: [Service],&#125;)export class ServiceModule &#123;&#125; 為了解決這個問題， service 本身必須包含如何建構實體的相關資訊，這樣才可以從 moduleFactory 脫離，也才讓 ngc 或是相關工具決定是否要包含 service 的程式碼 建立 tree-shakable providers Angular 團隊為了這件事情，他們修改了 @Injectable 的介面，多了兩個項目可以設定 1234@Injectable(&#123; providedIn?: Type&lt;any&gt; | 'root' | null factory: () =&gt; any&#125;) Singleton Service 設定方式 1234567@Injectable(&#123; providedIn: 'root' &#125;)export class Service &#123; constructor(private dep: string) &#123; &#125;&#125; 當 providedIn 設定為 root 時，這表示該 service 會被註冊為 singleton service 註冊在 root 以外的地方 另外一種情境是 service 是註冊在某一個 NgModules 下且不一定要是 singleton ，這時候的設定方式是 1234567@Injectable(&#123; providedIn: HeroModule&#125;)export class Service &#123; constructor(private dep: string) &#123; &#125;&#125; 這樣子設定後，在每一次有引用到 HeroModule 時，都會建立一個 Service 實體 Factory 模式 @Injectable 另外一個 useFactory (這裡我還不確定最後的寫法是怎樣，原始碼內有點混亂，但基本概念是一樣的) 12345678910111213@Injectable(&#123; providedIn: 'root', useFactory: (logger: Logger, userService: UserService) =&gt; new HeroService(logger, userService.user.isAuthorized), deps: [Logger, UserService],&#125;)export class HeroService &#123; // #docregion internals constructor( private logger: Logger, private isAuthorized: boolean) &#123; &#125; ...&#125; 結論 根據目前 Angular CLI 走的方向，這種設定方式將會是預設的模式，除非有其他 DI 的特需需求，不然 NgModules 的 providers 應該會是空空的。某種程度上是好事，只是要花點時間習慣]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Capacitor]]></title>
    <url>%2F2018%2F04%2F02%2Fangular-ionic-capacitor%2F</url>
    <content type="text"><![CDATA[什麼是 Capacitor ? Capacitor 是 Ionic 團隊所開發出來的新開發框架，再次證明他們的野心 Capacitor is a cross-platform app runtime that makes it easy to build web apps that run natively on iOS, Android, Electron, and the web. We call these apps 「Native Progressive Web Apps」 and they represent the next evolution beyond Hybrid apps. 但是否如他們所說的那麼強大呢? 一定要動手玩看看才知道 測試步驟 透過 Angular CLI 建立一個標準的 Angular 專案 ng new appCapacitor 在 Angular 專案資料夾下，安裝 @capacitor/core 和 @capacitor/cli npm install --save @capacitor/core @capacitor/cli 執行 Capacitor 初始化，這動作會建立一個 json 的設定檔 npx cap init 如果不知道 npx 是什麼的，請參閱這篇文章 輸入一些基本資料後，即完成設定動作，完成後的畫面如下 配合 Angular CLI 的建置輸出路徑修改 capacitor.config.json 檔案 123456&#123; "appId": "cky.demo.app", "appName": "App", "bundledWebRuntime": false, "webDir": "dist"&#125; 開始第一次 build —prod 因為第一次想用 PWA 的方式呈現，可透過 npx cap serve 來啟動 web server 如果想要跑成 iOS 的格式，指令為 npx cap open ios (需要有 xcode 才可以跑) 如果想要跑成 Android 的格式，指令為 npx cap open android 跑起來的畫面就跟預設的畫面是一樣的，只是網址變成 http://localhost:3333 使用套件(Plugin) 來試試看現成的 Geolocation API (內建的) 能不能正常使用，在程式碼上會不會很難處理 因為已經有裝 @capacitor/core，所以可以透過 import { Plugin } from '@capacitor/core' 來取得現有內建的 API 1234567891011121314151617181920212223242526272829303132333435363738394041// app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; Plugins &#125; from '@capacitor/core';import &#123; Observable &#125; from 'rxjs/Observable';import &#123; bindCallback &#125; from 'rxjs/observable/bindCallback';import &#123; map &#125; from 'rxjs/operators';const &#123; Geolocation, Modals, App &#125; = Plugins;@Component(&#123; selector: 'app-root', template: ` &lt;button (click)="currentLocation()"&gt;顯示目前位置&lt;/button&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit &#123; coords: Coordinates; ngOnInit() &#123; App.addListener('backButton', () =&gt; &#123; Plugins.App.exitApp(); &#125;); this.watchPosition().subscribe(coords =&gt; &#123; this.coords = coords; &#125;); &#125; watchPosition(): Observable&lt;any&gt; &#123; const watch = bindCallback(Geolocation.watchPosition)(&#123;&#125;); return watch.pipe(map(pos =&gt; pos.coords)); &#125; async currentLocation() &#123; const position = await Geolocation.getCurrentPosition(); Modals.alert(&#123; title: '目前位置', message: `lat: $&#123;position.coords.latitude&#125;, long: $&#123;position.coords.longitude&#125;` &#125;); &#125;&#125; 利用 bindCallback 的方法將 api 轉換成 Observable 型別 Chrome 在版本 50 以後就不允許 http 跑 Geolocation 了，所以如果要測試這段，這部分可能就要自己摸索了 部屬到 Android 設備上 假設 Android 開發環境已經準備好了 ( 使用 Android Studio )，Capacitor 只需要透過幾個指令，就可以將 Android 部屬目標加上去，以下是相關的指令及對應的功能 npx cap add android 將 Android platform 加入到目前的專案下 npx cap sync 同步 dependency 和 web 內容 npx cap copy 複製 web 內容 npx cap open android 開啟 Android Studio 並執行建置動作 如果 Android Studio 不是安裝在預設路徑下時，可以在 capacitor.config.json 內設定實際的安裝位置 1234&#123; ... "windowsAndroidStudioPath": "D:\\Program Files\\Android\\Android Studio\\bin\\studio64.exe"&#125; 實際測試/部屬到 Android 因為我們需要將網頁建置後的結果複製到 Android 的專案下，所以在執行 npx cap sync 之前，記得要做 ng build --prod 的動作 基本流程如下 ng build --prod 建置 web 專案 npca cap sync 同步 web 專案及 dependency 元建至 Android 專案下 npx cap open android 開啟 Android Studio 進行後續的測試部屬，如果 Android Studio 已經開啟時，就不需要執行這行指令 執行結果 總結 目前看起來 Ionic 的新架構 Capacitor 的確可以擺脫以前的 ionic 的開發方式，讓使用者用自己熟悉的 JavaScript framework 做開發，而不用侷限使用 Angular，個人還蠻期待後續的發展的 延伸閱讀 Capacitor Documentation]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 第一次體驗 NGXS]]></title>
    <url>%2F2018%2F03%2F30%2Fangular-ngxs%2F</url>
    <content type="text"><![CDATA[沒錯，又是另外一套 State management 工具，這套叫做 NGXS ，為什麼會想嘗試這一套呢? 主要是他的語法與 Angular 現有的寫法及運作方式幾乎是一樣的，學習門檻變得很低，而且，重點是要產生的檔案變得非常的少!! 安裝 NGXS 安裝 NGXS 的方式很簡單，透過 npm 安裝 @ngxs/store 即可 1npm install @ngxs/store 在 app.module.ts 將 NgxsModule imports 進來 123456789101112131415import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; NgxsModule &#125; from '@ngxs/store';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, NgxsModule.forRoot([]) // 用來註冊 state 用 ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 當遇到 lazy loading modules 時，在該 module 下會使用 NgxsModule.forFeature([])來註冊 state；即使所有的 module 都是 lazy load 時，還是得在 root module 裡註冊 NgxsModule.forRoot([]) 到這個步驟時，NGXS 已經加入到 Angular 專案裡了 建立 State NGXS 的 State 是一個單純的 class 檔案，可以透過 ng g class &lt;&lt;state file name&gt;&gt; 來產生，作者建議的檔案名稱是 [stateName].state.ts ，就此篇練習的目的，建立一個 todos.state.ts 檔案，Class 名稱為 TodosState 123456789101112131415export class TodoItem &#123; constructor(public content: string) &#123;&#125;&#125;export interface TodosStateModel &#123; dataset: TodoItem[];&#125;@State&lt;TodosStateModel&gt;(&#123; name: 'todos', defaults: &#123; dataset: [] &#125;&#125;)export class TodosState &#123;&#125; @State decorator 用來描述 state 的狀態 @State&lt;T&gt; ：定義此 state 的資料型別 name：該 state 在 store 裡的名稱 defaults: 資料存放位置，(預設值) 用來描述 @State 的型別，建議在最後加上 Model，例如 TodoStateModel 完成建立 state 時，這時候在到 app.module.ts 內註冊到 NgxsModule.forRoot([]) 內 123456789101112...import &#123; TodosState &#125; from './todos.state';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, NgxsModule.forRoot([TodosState]) // 註冊 state ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 建立 Action 在 NGXS 的架構下，要設定可以被執行的 action 方法時，是不需要額外新增檔案的，直接寫在 state class 下即可 123456789101112131415161718192021222324252627export class ADDTODO &#123; payload: TodoItem; constructor(name: string) &#123; this.payload = new TodoItem(name); &#125;&#125;@State&lt;TodosStateModel&gt;(&#123; name: 'todos', defaults: &#123; dataset: [] &#125;&#125;)export class TodosState &#123; constructor()&#123; // 可以透過 constrcutor 將 service 注入進來 &#125; @Action(ADDTODO) addTodo(&#123; getState, setState &#125;: StateContext&lt;TodosStateModel&gt;, &#123; payload &#125;: ADDTODO) &#123; const state = getState(); setState(&#123; ...state, dataset: [...state.dataset, payload] &#125;); &#125;&#125; @Action 內傳的 Class ，是用來定義此 Action 的名稱，在 store dispatch 時，就是根據 class 來決定所要執行的動作 addTodo(StateContenxt&lt;T&gt;, ActionClass? ) 第一個參數是取得可操作目前 state 的 context 物件，內有的方法有 getState():T 取得目前 state 的值 setState(val:T):any 重設目前 state 的值(重新建立一個新的state) patchState(valu: Partial&lt;T&gt;) 更新目前 state 的值 (不會產生一個全新 state) dispatch(actions) 觸發 action，一個或是多個(用陣列包) 第二個參數是取得 Action 對應的 Class 實體，NGXS 是透過這樣子的模式傳遞資料 由於 State 本身是活在 Angular 的 DI 機制下，所以也可以在 constructor 的注入其他 service，所以當要呼叫 API 時，也可以直接寫在 action function 就可以了，不需要額外在建立檔案 1234567891011121314constructor(private service: ApiService) &#123;&#125; @Action(ADDTODO) addTodo(&#123; getState, setState &#125;: StateContext&lt;TodosStateModel&gt;, &#123; payload &#125;: ADDTODO) &#123; return this.service.someApiCall().pipe( tap(() =&gt; &#123; const state = getState(); setState(&#123; ...state, dataset: [...state.dataset, payload] &#125;); &#125;) ); &#125; 使用 Store 當 State class 寫完後，接下來就可以在各個地方透過 store 的方式做執行 action 及取得資料的行為了 12345678910111213141516import &#123; Component &#125; from '@angular/core';import &#123; Store, Select &#125; from '@ngxs/store';import &#123; Observable &#125; from 'rxjs/Observable';import &#123; TodoItem &#125; from './todos.state';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; title = 'app'; @Select('todos.dataset') todos: Observable&lt;TodoItem[]&gt;; constructor(private store: Store) &#123;&#125;&#125; @Select 該 decorator 允許我們透過 path 的設定取到特定的 state 資料，而取得的資料型態為 Observable 如果不想要這樣子寫，可以透過 store.select 的方式做設定，結果是一樣的 1234567export class AppComponent &#123; todos: Observable&lt;TodoItem[]&gt;; constructor(private store: Store) &#123; this.todos = store.select(state =&gt; state.todos.dataset); &#125;&#125; 執行 action 的動作，一樣是透過 store.dispatch 來執行，可以傳入一個或是多個(用陣列傳) actions，而 dispatch 是一個 observable，並會回傳 action 後的 state 狀況，這表示我們可以用 RxJS 的方式最很多變化 1234567&lt;ul&gt; &lt;li *ngFor="let item of todos | async"&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;input type="text" #f /&gt;&lt;button (click)="addTodo(f)"&gt;Add Todo&lt;/button&gt; app.component.ts 123456addTodo(input) &#123; this.store.dispatch(new ADDTODO(input.value)).subscribe(state =&gt; &#123; console.log(state); input.value = ''; &#125;);&#125; Recap NGXS 是以 Angular 的角度重新思考 Redux 風格的 state management，個人是覺得這樣的模式大幅降低學習及編寫的門檻，而 NGXS 內還有更多的功能都有在電子書上說到，有興趣的人真的可以動手玩看看，寫起來跟寫 Angular service 真的沒什麼差異。 延伸閱讀 NGXS GitBook 範例程式]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Blazor 基本介紹]]></title>
    <url>%2F2018%2F03%2F25%2Fblazor-basic%2F</url>
    <content type="text"><![CDATA[上一篇介紹了如何安裝 Blazor 範本，這一篇就來分享基本的 Blazor 的檔案及語法結構 新增 Blazor 專案 新增 ASP.NET Core Web 應用程式 選擇 Blazor 類型專案，確定新增 第一次執行 專案的檔案結構 專案檔案說明 program.cs 123456789101112class Program &#123; static void Main(string[] args) &#123; var serviceProvider = new BrowserServiceProvider(configure =&gt; &#123; // Add any custom services here &#125;); new BrowserRenderer(serviceProvider).AddComponent&lt;App&gt;("root-app"); &#125; &#125; new BrowserRenderer(serviceProvider).AddComponent&lt;App&gt;(&quot;root-app&quot;); 這裡是啟動點，用來設定要將 BlazorComponent 產生在 index.html 上的哪一個節點，預設的 element 是 app，這是可以依 index.html 的設定做改變 AddComponent&lt;App&gt; 裡的 App 是對應到起始 BlazorComponent，檔名即 component 物件名稱 App2.cshtml 內的檔案內容，只是一個類似 &lt;router-outlet&gt; 的東西，用來顯示對應路由要顯示的 BlazorComponent，根據該檔案的內容，之後還會做調整 12345&lt;!-- Configuring this here is temporary. Later we'll move the app config into Program.cs, and it won't be necessary to specify AppAssembly.--&gt;&lt;Router AppAssembly=typeof(Program).Assembly /&gt; Counter.cshtml 123456789101112131415@page "/counter"&lt;h1&gt;Counter&lt;/h1&gt;&lt;p&gt;Current count: @currentCount&lt;/p&gt;&lt;button @onclick(IncrementCount)&gt;Click me&lt;/button&gt;@functions &#123; int currentCount = 0; void IncrementCount() &#123; currentCount++; &#125;&#125; @page &quot;/counter&quot; ，@page 是用來設定此頁面的路由位置 @functions{ ... } 是頁面功能程式碼撰寫的位置 @currentCount 會對應寫在 @functions 內的 property 變數 @onclick 是 blazor 對應原生 JavaScript onClick 的寫法，內設定要觸發的 method Pages/_ViewImports.cshtml 頁面的 Layout 會依 _ViewImports.cshtml 的設定 1@layout MainLayout @layout 設定要使用的 Layout 頁面 Shared/MainLayout.cshtml 12345678910111213141516@implements ILayoutComponent&lt;div class='container-fluid'&gt; &lt;div class='row'&gt; &lt;div class='col-sm-3'&gt; &lt;NavMenu /&gt; &lt;/div&gt; &lt;div class='col-sm-9'&gt; @Body &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;@functions &#123; public RenderFragment Body &#123; get; set; &#125;&#125; @implements ILayoutComponent 標示此檔案為實作 ILayoutComponent，可被用來設定 @layout &lt;Navmenu&gt; 載入 NavMenu.cshtml Component @Body 是用來顯示 BlazorComponent 的地方 FetchData.cshtml 1234567@page "/fetchdata"@inject HttpClient Http&lt;h1&gt;Weather forecast&lt;/h1&gt;&lt;p&gt;This component demonstrates fetching data from the server.&lt;/p&gt;... @inject 注入要使用的 service ，Dependency Injection 的用法 Pages/Index.cshtml 1234567@page "/"&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app.&lt;SurveyPrompt Title="How is Blazor working for you?" /&gt; &lt;SurveyPromt Title=&quot;....&quot;&gt; 裡的 Title 是該 Component 允許從外部設定屬性欄位 123456// Shared/SurveyPrompt.cshtml@functions&#123; // This is to demonstrate how a parent component can supply parameters public string Title &#123; get; set; &#125;&#125; wwwroot/Index.html 123456&lt;body&gt; &lt;root-app&gt;Loading...&lt;/root-app&gt; &lt;script src="css/bootstrap/bootstrap-native.min.js"&gt;&lt;/script&gt; &lt;script type="blazor-boot"&gt;&lt;/script&gt;&lt;/body&gt; &lt;script type=&quot;blazor-boot&quot;&gt;&lt;/script&gt; 會在建置時間置換成 &lt;script src=&quot;_framework/blazor.js&quot; main=&quot;BlazorApp1.dll&quot; entrypoint=&quot;BlazorApp1.Program::Main&quot; references=&quot;Microsoft.AspNetCore.Blazor.dll,netstandard.dll,...&quot;&gt;&lt;/script&gt; 總結 Blazor 的語法與結構就目前看起來並不複雜，很期待之後的發展]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[鑑識會計]學習筆記-舞弊罪犯與其犯罪理由]]></title>
    <url>%2F2018%2F03%2F24%2Fforensic-accounting-note-2%2F</url>
    <content type="text"><![CDATA[鑑識會計學習筆記- 舞弊罪犯與其犯罪理由 純學習筆記之用 守法的因素 害怕遭到懲罰 渴望獲得回饋(獎賞) 以符合社會標準的方式，表現出公允且合乎倫理的舉止 職務舞弊與濫權：運用個人職權，蓄意誤用或挪用受雇組織之資源或資產，以求滿足個人私慾 侵權：違約以外的私人或民事過失或傷害，法律對此損失提供補救之道 疏失 - 法律要素 5 點 義務 違反 因果關係 近因 造成損害 贏得損失賠償須舉證以下兩點 責任 - 對方須承擔主張損害之全部或部分之責 損害 - 受害者基於加害者之行動或無行動而蒙受損失 道德定義的相關關鍵要件 道德涉及的問題需要經過深思熟慮的選擇，及對自己及他人造成的後果(決策問題) 道德考量到引導行為的規則和規範，以及違反這些規則與規範的後果 道德常依賴道德原則來引導是非的選擇 道德重視後果，後果係指決策相關的衝擊，此衝擊反映出個人與組織的根本價值 舞弊防範、遏止與偵測的五步驟 了解舞弊曝顯狀況 將曝顯情況轉為可能徵兆 隨時尋找徵兆 制定查核與資料採礦計畫以尋找徵兆 尋求這些問題的邏輯結論，根據證據來做出決定]]></content>
      <categories>
        <category>會計</category>
      </categories>
      <tags>
        <tag>會計</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[鑑識會計]學習筆記-舞弊查核與財務件事的核心架構-01]]></title>
    <url>%2F2018%2F03%2F23%2Fforensic-accounting-note-1%2F</url>
    <content type="text"><![CDATA[鑑識會計學習筆記- 舞弊查核與財務件事的核心架構-01 純學習筆記之用 何謂舞弊 構成舞弊的法律要件 重大的虛假陳述 故意提出虛假陳述 受害者對虛假陳述的信賴 受害者因信任虛假陳述而導致受害 偷竊四項基本要件 確實拿取或取走之行為 係屬他人金錢或財產 未經所有權人同意 蓄意剝奪所有權人的使用權或保管權 主要舞弊類別 挪用資產 現金 盜竊 截留(未入帳以挪用現金) 支出舞弊 報銷 - 空殼公司、虛假供應商、私人費用支出 薪資 - 幽靈員工、佣金式薪資舞弊、偽造工時與薪資率 費用報銷 - 浮報支出、虛構費用、重複報銷 支票 收銀機支出 - 虛構作廢/退款 存貨與其他資產 不當使用 盜竊 貪汙 利益衝突(未報導或未揭露) 賄賂 非法報酬 敲詐勒索 財務報表舞弊 虛構收入(與相關資產) 收入與費用認列時點錯誤 隱匿負債 不實及誤導的揭露 不實資產評價 不當將費用資本化 特殊舞弊(詐欺)背景 破產詐欺 契約與採購舞弊 洗錢 稅務舞弊 投資詐欺 贊助恐怖份子 消費者詐欺 竊用身分 支票與信用卡詐欺 電腦與網路詐欺 離婚詐欺(包括隱匿資產) 智慧財產 企業評價舞弊 顯著業界特有的舞弊(詐欺) 金融 保險 醫療 證券 公共部門 舞弊與濫用的差異 舞弊三角 意識到機會：意識到會被察覺有抑止的效果 意識到壓力 合理化解釋：自我催眠找理由將行為合理化 M.I.C.E. Money(金錢) Ideology(意識形態) Coercion(強迫) Ego(自我) 舞弊查核方法論 分析現有資料 建立假設 檢驗假設 修訂假設 提出結論]]></content>
      <categories>
        <category>會計</category>
      </categories>
      <tags>
        <tag>會計</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] RxJS 6 的 Breaking Changes 整理]]></title>
    <url>%2F2018%2F03%2F22%2Frxjs-6-breakchanges%2F</url>
    <content type="text"><![CDATA[Angular 6 將會把 RxJS 一起升級到 6 版，在 RxJS 6 版有許多的 breaking changes，這些 breaking changes 有許多是為了簡化開發時的寫法所做的改變，所以不要太緊張，就慢慢的了解就可以了。 RxJS 6 Breaking Changes 列表 webSocket: webSocket creator function now exported from rxjs/websocket as websocket. IteratorObservable: IteratorObservable no longer share iterator between subscription utils: Many internal use utilities like isArray are now hidden under rxjs/internal, they are implementation details and should not be used. testing observables: HotObservable and ColdObservable, and other testing support types are no longer exported directly. creation functions: All create functions such as of, from, combineLatest and fromEvent should now be imported from rxjs/create. types and interfaces: Can no longer explicitly import types from rxjs/interfaces, import them from rxjs instead symbols: Symbols are no longer exported directly from modules such as rxjs/symbol/observableplease use Symbol.observable and Symbol.iterator (polyfills may be required) deep imports: Can no longer deep import top-level types such as rxjs/Observable, rxjs/Subject, rxjs/ReplaySubject, et al. All imports should be done directly from rxjs, for example: import \{ Observable, Subject \} from 'rxjs'; schedulers: Scheduler instances have changed names to be suffixed with Scheduler, (e.g. asap -&gt; asapScheduler) operators: Pipeable operators must now be imported from rxjs like so: import { map, filter, switchMap } from 'rxjs/operators';. No deep imports. ajax: Ajax observable should be imported from rxjs/ajax. ajax: will no longer execute a CORS request by default, you must opt-in with the crossDomain flag in the config. Observable: You should no longer deep import custom Observable implementations such as ArrayObservable or ForkJoinObservable. _throw: _throw is now exported as throwError operators: Deep imports to rxjs/operator/* will no longer work. Again, pipe operators are still where they were. error handling: Unhandled errors are no longer caught and rethrown, rather they are caught and scheduled to be thrown, which causes them to be reported to window.onerror or process.on(『error』), depending on the environment. Consequently, teardown after a synchronous, unhandled, error will no longer occur, as the teardown would not exist, and producer interference cannot occur distinct: Using distinct requires a Set implementation and must be polyfilled in older runtimes asap: Old runtimes must polyfill Promise in order to use ASAP scheduling. groupBy: Older runtimes will require Map to be polyfilled to use groupBy TypeScript: IE10 and lower will need to polyfill Object.setPrototypeOf operators removed: Operator versions of static observable creators such as merge, concat, zip, onErrorResumeNext, and race have been removed. Please use the static versions of those operations. e.g. a.pipe(concat(b, c)) becomes concat(a, b, c). rxjs: rxjs/create items are now exported from rxjs throwError: Observable.throw no longer available in TypeScript without a cast empty: empty() without a scheduler will return the same instance every time. empty: In TypeScript, empty() no longer accepts a generic argument, as it returns Observable&lt;never&gt; never: never()always returns the same instance never: TypeScript typing for never() is now Observable&lt;never&gt; and the function no longer requires a generic type. never: no longer exported. Use the NEVER constant instead. Symbol.observable: RxJS will no longer be polyfilling Symbol.observable. That should be done by an actual polyfill library. This is to prevent duplication of code, and also to prevent having modules with side-effects in rxjs. bindCallback: removes result selector, use map instead: bindCallback(fn1, fn2)() becomes bindCallback(fn1)().pipe(map(fn2)) Symbol.iterator: We are no longer polyfilling Symbol.iterator. That would be done by a proper polyfilling library Observable.if: TypeScript users using Observable.if will have to cast Observable as any to get to if. It is a better idae to just use iif directly via import { iif } from 'rxjs'; bindNodeCallback: resultSelector removed, use map instead: bindNodeCallback(fn1, fn2)() becomes bindNodeCallback(fn1)().pipe(map(fn2)) Rx.ts: importing from rxjs/Rx is no longer available. Upcoming backwards compat solution will allow that fromEvent: result selector removed, use map instead: fromEvent(target, 'click', fn) becomes fromEvent(target, 'click').pipe(map(fn)) last: no longer accepts resultSelector argument. To get this same functionality, use map. first: no longer supports resultSelector argument. The same functionality can be achieved by simply mapping either before or after first depending on your use case. exhaustMap: resultSelector no longer supported, to get this functionality use: source.pipe(exhaustMap(x =&gt; of(x + x).pipe(map(y =&gt; x + y)))) switchMap|switchMapTo: switchMap and switchMapTo no longer take resultSelector arguments, to get the same functionality use switchMap and map in combination: source.pipe(switchMap(x =&gt; of(x + x).pipe(y =&gt; x + y))). mergeMapTo: mergeMapTo no longer accepts a resultSelector, to get this functionality, you’ll want to use mergeMap and map together: source.pipe(mergeMap(() =&gt; inner).pipe(map(y =&gt; x + y))) fromEventPattern: no longer supports a result selector, use map instead: fromEventPattern(fn1, fn2, fn3) becomes fromEventPattern(fn1, fn2).pipe(map(fn3)) 重點整理 Import 位置簡化 creation functions 現在改由 rxjs import 1import &#123; of, from &#125; from 'rxjs'; types and interfaces 現在改由 rxjs import 語法調整 _if 修改成 iif _throw 修改成 throwError asap 修改成 asapScheduler 等 擁有 resultSelector 的 operators 都被拔掉了，建議改搭配使用 map，例如 1source.pipe(mergeMap((x)=&gt; of(x+x).pipe(y=&gt; x=y))) Pipeable operators 必須從 rxjs/operators 引用 importing from rxjs/Rx 無法繼續使用. 但會提供 rxjs-compat 套件做向下相容]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Blazor - 前置環境設定]]></title>
    <url>%2F2018%2F03%2F11%2Fblazor%2F</url>
    <content type="text"><![CDATA[※此篇所介紹的技術都還在實驗階段，請勿用在 production 專案上 在去年年底(2017/11)月份左右，有一個非常有趣的 Repo 出現，叫做 Blazor 。什麼是 Blazor ? Blazor 是將 C#/Razor 與 HTML 封裝成 WebAssembly ，然後可以跑在前端的 SPA 架構。目前這框架還處於實驗架構，但我們還是可以建立一個專案來玩玩看，這篇先介紹環境的安裝 前置條件 .NET Core SDK (&gt; 2.1.4) Node.js (&gt; 8.3) 如果使用 Visual studio 2017 者，需要更新至 15.6 版本，或者使用 preview 版本也可以 安裝專案範本 Visual Studio 2017 將 https://dotnet.myget.org/f/blazor-dev/vsix 新增到 Extension Galleries 內 Nuget 套件來源也需要新增 https://dotnet.myget.org/f/blazor-dev/vsix 更新安裝下列兩個套件，都需要關掉 Visual Studio 2017 才可以完成安裝動作 Razor Language Services (NOTE: When you later uninstall the Razor Language Services VSIX you will need to do a VS repair to bring back the old one) ASP.NET Core Blazor Language Services 一旦完成上續的動作後，即可獲得 Blazor 的專案範本 使用 Command-line 透過以下指令可以安裝專案範本 1dotnet new -i Microsoft.AspNetCore.Blazor.Templates::0.1.0-* --nuget-source https://dotnet.myget.org/F/blazor-dev/api/v3/index.json 之後的建立 Blazor 專案的方式就可以使用 dotnet new blazor 或是 dotnet new blazorhosted 的方式完成 第一次啟動 在 restore 和 建置後，第一次啟動網站，你會看到很熟悉畫面 開啟開發者介面，也可以看到一堆 dll 檔案被下載到瀏覽器了 XD 相關資源 Blazor repo: https://github.com/aspnet/blazor Blazor Gitter: https://gitter.im/aspnet/blazor TsToCsharp repo: https://github.com/mono/TsToCSharp]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Nx 命令篇 - 建立 Lib]]></title>
    <url>%2F2018%2F02%2F24%2Fnx-create-lib%2F</url>
    <content type="text"><![CDATA[建立 App 是小事，真正重頭戲是建立 Libs，在 Nx 所提供的架構下，所有的 NgModule、Serivces、Utility 都是放在 Libs 資料夾下，所以建立 libs 的參數相對的多，影響的範圍比較廣，在這篇文章會稍微整理一下 參數 Nx 建立 Lib 指令後面可使用的參數有 name ： Library 名稱 directory：如果有設定 directory，application的建立路徑為 &lt;&lt;directory name&gt;&gt;/&lt;&lt;library name&gt;&gt; 如果沒有設定，建立路徑則是 &lt;&lt;library name&gt;&gt; sourceDir：設定程式碼的存放路徑，這個會接在設定的 directory 之後，完整的設定規則如下 123const name = toFileName(options.name);const fullName = options.directory ? `$&#123;toFileName(options.directory)&#125;/$&#123;name&#125;` : name;const fullPath = `libs/$&#123;fullName&#125;/$&#123;options.sourceDir&#125;`; // 程式碼最終輸出位置 nomodule：建立一個沒有 NgModule 的 library routing：需產生路由設定檔 lazy：設定為 lazyloading 的 NgModule parent-module：將建立的 Library import 到某一個 NgModule 內，需指定所要注入的 NgModule 實際的檔案位置 建立 Library 預設建立 Library 都會以 NgModule 的方式呈現，這表示，任何所建立的 Library 都會是一個 NgModule，以方便 import 到其他 Module 內。當然也可以設定 --nomodule 即可建立沒有 NgModule 的 library 所建立的 library 都會放到 libs 資料夾下，這時會發現 Nx 有多產生一個 index.ts 檔案，而這一個 index.ts 檔案會 export NgModule 的內容，之所以會這樣子設定，是方便我們在其他地方進行 imports 時，只需要指到 library 的最上層位置，即可取得內部所開放出來的所有功能，例如 import { ... } from '@nxdemo/backend' 此外，Nx 並會在 .angular-cli.json 的 apps 區塊新增此 library 的相關資訊 這個動作的用意，這方便我們使用 Angular CLI 的 generator 功能，Angular CLI generator 可以指定所產生的範本是要輸出到哪一個 apps 下 1ng g service ticket -a=backend 上列的指令就可以在剛剛建立的 BackendModule 裡，新增一個 ticket service NgModule with routing 我們也可以透過 --routing 的參數，來產生一個含有路由設定檔的 NgModule 1ng g lib account --routing 所產生的 NgModule 會長這樣 會建立一個路由設定檔，並注入 RouterModule 而上一層的 index.ts 檔案內，也同時會輸出路由設定檔 這個動作允許其他 NgModule 可以很容易地取得目前 NgModule 內的路由設定檔 parentModule 設定 parentModule 參數的設定，可以將目前要建立的 library 注入到其他 NgModule 裡 1ng g lib profile-setting --routing --parent-module=apps/client/dashboard/src/app/app.module.ts --parent-module 需要指定所要注入的 NgModule 實際的檔案位置 同時也會將所建立的路由設定檔加入到設定的 parent-module 的路由設定檔內 lazy 如果多加上 --lazy 的參數時，在更新 parent-module 路由檔的方式就會有所差異，而且更新的檔案數量也比較多 parent-module 的路由設定檔會採 loadChildren 的方式將該 NgModule 載入 因為 lazy 的關係，新增的 NgModule 路由設定檔的呈現方式也會有所不同，會直接以 RouterModule.forChild([]) 的方式呈現 123456789@NgModule(&#123; imports: [ CommonModule, RouterModule.forChild([ /* &#123;path: '', pathMatch: 'full', component: InsertYourComponentHere&#125; */ ]) ]&#125;)export class ProfileSettingModule &#123;&#125; tslin.json 檔案也會被異動，會將 lazy load module 新增到 lazyload 陣列中以避免該 module 以非 lazy load 的方式被載入 123456789"nx-enforce-module-boundaries": [ true, &#123; "lazyLoad": [ "profile-setting" ], "allow": [] &#125; ] nomodule 要產生一個簡單的 TypeScript library 時，只要加上 --nomodule即可 1ng g lib helper --nomodule 總結 透過以上建立的方式，可以重新思考 Feature module 的規劃方式，也可以將一些與 Angular 無關的商業邏輯獨立成單一 Library，以便之後的重複利用性 延伸閱讀 Feature Modules Lazy Loading Feature Modules]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Nx 命令篇 - 建立 App]]></title>
    <url>%2F2018%2F02%2F19%2Fnx-create-app%2F</url>
    <content type="text"><![CDATA[Nx 工具提供兩個建立新範本的指令、ng g app &lt;&lt;name&gt;&gt; 和 ng g lib &lt;&lt;name&gt;&gt;，這一篇文章來看建立 application 的命令 Create App 在建立 Application 時，可以有以下的參數可以使用 (注意：透過 ng g app -h 取得說明，其中有些參數是無法使用的) name (必填)：要建立的 Application 名稱 npmScope directory：如果有設定 directory，application的建立路徑為 / 如果沒有設定，建立路徑則是 sourceDir：預設值為 src，程式碼產生位置，例如: apps//src inlineStyle：設定使用 inlineStyle inlineTemplate：設定使用 inlineTemplate viewEncapsulation：設定 viewEncapsulation，可設定 Emulated、Native 和 None changeDetection：設定 changeDetection，可設定 Default 及 onPush ，預設值為 Default routing：產生 Routing 區段程式碼，例如 &lt;router-outlet&gt;&lt;/router-outlet&gt; skipTests：取消產生測試檔案 prefix：設定 prefix 文字，預設值為 app style：設定 css 的檔案類型，預設值為 css 當建立 application 時，除了新增檔案外，還會異動 .angular-cli.json 檔案，異動區塊有 lint 及 apps ，本篇文章建立範例時所執行指令為 ng g app dashboard --directory=client lint section 12345678&#123; "project": "apps/client/dashboard/src/tsconfig.app.json", "exclude": "**/node_modules/**" &#125;, &#123; "project": "apps/client/dashboard/e2e/tsconfig.e2e.json", "exclude": "**/node_modules/**" &#125; apps section 12345678910111213141516171819202122232425&#123; "name": "client/dashboard", "root": "apps/client/dashboard/src", "outDir": "dist/apps/client/dashboard", "assets": [ "assets", "favicon.ico" ], "index": "index.html", "main": "main.ts", "polyfills": "polyfills.ts", "test": "../../../../test.js", "tsconfig": "tsconfig.app.json", "testTsconfig": "../../../../tsconfig.spec.json", "prefix": "app", "styles": [ "styles.css" ], "scripts": [], "environmentSource": "environments/environment.ts", "environments": &#123; "dev": "environments/environment.ts", "prod": "environments/environment.prod.ts" &#125; &#125; 新增檔案清單 app.module.ts：預設載入 NxModule.forRoot()，預設注入 DataPersistence provider 123456@NgModule(&#123;&#125;)export class NxModule &#123; static forRoot(): ModuleWithProviders &#123; return &#123; ngModule: NxModule, providers: [DataPersistence] &#125;; &#125;&#125; ​ 延伸閱讀 DataPersistence]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Nx 環境設定介紹]]></title>
    <url>%2F2018%2F02%2F13%2Fnx-config-file%2F</url>
    <content type="text"><![CDATA[上一篇 Nx 介紹了如何安裝工具及可執行的指令，這一篇來介紹一下 workspace 的架構 Workspace 架構 Nx 預設的專案架構有兩個空的資料夾，分別為 apps 與 libs 而我們熟悉的 CLI 專案，則會透過建立 app 的指令產生再 apps 的資料夾下，指令如下 1ng g app &lt;&lt;application name&gt;&gt; 執行完指令，Nx 會產生一系列預設的檔案，及更新 .angular-cli.json 檔案，產生出來的檔案就是我們很熟悉的 CLI 專案有的相關檔案 設定檔 angular-cli.json 當打開 .angular-cli.json 時，會發現內容與 Angular CLI 所產生的設定檔，有些許的不一樣，就一一來解釋 1234&#123; "$schema": "./node_modules/@nrwl/schematics/src/schema.json", ...&#125; 這一行是設定此 JSON 格式描述檔的位置，由於 Nx 是一個多 App 的開發環境，所以在設定上當然會與常見的設定檔內容會有所不同 123456789&#123; ... "project": &#123; "name": "nxdemo", "npmScope": "nxdemo", "latestMigration": "20180130-angular-devkit-schematics" &#125;, ...&#125; 描述專案的資訊 專案名稱 Libs 的 npm namespace 名稱 Nx 的版本，在之後做升級時比較使用 12345678910111213&#123; ... "defaults": &#123; "schematics": &#123; "collection": "@nrwl/schematics", "postGenerate": "npm run format", "newProject": [ "app", "lib" ] &#125;, ...&#125; defaults 區塊所描述的資訊有 指定要使用的 schematics 當產生檔案後要執行的檔案 當建立新專案時，要執行的 collection 名稱 另外是，當新增 app 時，會 apps 內新增 app 的相關資訊 12345678910111213141516171819202122232425262728293031&#123; ... "apps": [ &#123; "name": "app-one", "root": "apps/app-one/src", "outDir": "dist/apps/app-one", "assets": [ "assets", "favicon.ico" ], "index": "index.html", "main": "main.ts", "polyfills": "polyfills.ts", "test": "../../../test.js", "tsconfig": "tsconfig.app.json", "testTsconfig": "../../../tsconfig.spec.json", "prefix": "app", "styles": [ "styles.css" ], "scripts": [], "environmentSource": "environments/environment.ts", "environments": &#123; "dev": "environments/environment.ts", "prod": "environments/environment.prod.ts" &#125; &#125; ] ...&#125; tsconfig.json 在初始時，tsconfig.json 內會包含一個路徑別名的設定，這一行的設定會讓我們在使用模組時，簡化注入時要標示的來源路徑 12345"paths": &#123; "@nxdemo/*": [ "libs/*" ] &#125; tslint.json 在 tslint.json 的最後也多加上了這一個檢查條件，細部的功能會在後面介紹 1234567"nx-enforce-module-boundaries": [ true, &#123; "lazyLoad": [], "allow": [] &#125; ] package.json 多新增了幾個 Nx 專屬的指令 12345678910111213"apps:affected": "./node_modules/.bin/nx affected apps","build:affected": "./node_modules/.bin/nx affected build","e2e:affected": "./node_modules/.bin/nx affected e2e","affected:apps": "./node_modules/.bin/nx affected apps","affected:build": "./node_modules/.bin/nx affected build","affected:e2e": "./node_modules/.bin/nx affected e2e","format": "./node_modules/.bin/nx format write","format:write": "./node_modules/.bin/nx format write","format:check": "./node_modules/.bin/nx format check","nx-migrate": "./node_modules/.bin/nx migrate","nx-migrate:check": "./node_modules/.bin/nx migrate check","nx-migrate:skip": "./node_modules/.bin/nx migrate skip","postinstall": "./node_modules/.bin/nx migrate check" 延伸閱讀 [Nx Workspace]https://nrwl.io/nx/guide-nx-workspace)]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Nrwl Nx - 安裝篇]]></title>
    <url>%2F2018%2F02%2F11%2Fnx%2F</url>
    <content type="text"><![CDATA[繼上一篇 Mono repo 的討論後，今天要來介紹一下 Nrwl 這間顧問公司所推出的 Nx 工具，這 Nx 工具是建構在 Angular CLI 並使用自訂 schematics 的範本來創造符合企業開發需求的樣板工具，在這一篇會先簡單的介紹如何安裝並建立一個 nx workspace 安裝工具 Nrwl Nx 有將建置工具發佈在 npm 上，可透過 npm install 的方式來完成 1npm install -g @nrwl/schematics 基本上，這一個版本的 schematics 可以不需要再安裝 @angualr/cli，但是為了方便使用指令，還是建議將 @angular/cli 給裝起來 當安裝完成後，只需要一個指令就可以完成建立workspace 1create-nx-workspace &lt;&lt;projectname&gt;&gt; 當執行這一行指令後，就會在目前目錄下，新增一個 &lt;&lt;projectName&gt;&gt; 資料夾，並將所需的檔案架構給安裝完成 Nx 的 workspace 分成兩個資料夾，apps與 libs，提供一個可建置多個 applications 的 mono-repo 環境，細節的部分將會於之後再說明，目前，就先知道兩個指令 ng g app : 建立 applications，這會產生一般我們常見的 CLI 的專案類型，會包含 e2e 與 src 資料夾等 ng g lib：用來存放共用的 library，像是 feature module, service, helper function 等 以上兩個指令都可以加上 -h 取得更多的資訊 延伸閱讀 nrwl.io/nx]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] @Attribute]]></title>
    <url>%2F2018%2F01%2F31%2Fangular-attribute%2F</url>
    <content type="text"><![CDATA[Angular 的 Decorator 裡，有一個 @Attribute，但官方文件並沒有介紹這一個 decorator 的用法，所以在此介紹一下 基本寫法 @Attribute 可讓 component 擁有一個一次性的 attribute 屬性可供傳入常數值使用 而基本的使用方式及設定程式碼如下，這裡的 age 就是透過 @Attribute 建立出來的 1&lt;hello name="&#123;&#123; name &#125;&#125;" age="30"&gt;&lt;/hello&gt; 123456789101112import &#123; Component, Input, Attribute &#125; from '@angular/core';@Component(&#123; selector: 'hello', template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;! My age is &#123;&#123; age &#125;&#125;&lt;/h1&gt;`, styles: [`h1 &#123; font-family: Lato; &#125;`]&#125;)export class HelloComponent &#123; @Input() name: string; constructor(@Attribute('age') private age)&#123; &#125;&#125; 透過這種方式定義出來的 attribute 是不能使用任何 binding 的形式傳值，只能直接給予值，並只能在 constructor 設定。 使用情境 假設有一個共用的元件，希望可以從外部直接指定使用方式，而這一個設定是不會改變的，那這時候使用 @Attribute 來設定就很合適。 123456789101112131415import &#123; Component, Attribute &#125; from '@angular/core';export type ButtonType = 'primary' | 'secondary';@Component(&#123; selector: 'app-button', template: ` &lt;button [ngClass]="type"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/button&gt; `&#125;)export class ButtonComponent &#123; constructor(@Attribute('type') public type: ButtonType = 'primary') &#123; &#125;&#125; 1&lt;app-button type="secondary"&gt;Action Button&lt;/app-button&gt; 延伸閱讀 Getting to Know the @Attribute Decorator in Angular]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] viewProviders V.S. providers]]></title>
    <url>%2F2018%2F01%2F19%2Fangular-viewproviders-providers%2F</url>
    <content type="text"><![CDATA[Angular Component 的 metadata 資訊內有兩個可以設定 providers 的地方，分別是 viewProviders 和 providers ，這兩者都可以註冊 providers 但有些微的差異 我們知道 Angular 的 Injection System ，讓 component / service / directive 等可以在 constructor 的地方注入想要使用的服務，根據服務註冊的地方，Angular 會提供一樣或是不一樣的服務實體，到這個地方，是我們所熟知的運作方式 當然我們也可以在 component 註冊服務，已提供本身跟與本身有關的子物件使用，在閱讀 API 文件時，發現 component 有兩個註冊服務的方法，providers 與 viewProviders 這兩者在說明分別為 providers list of providers available to this component and its children viewProviders list of providers available to this component and its view children 看起來很像，但到底差異在哪裡呢? 主要差異是在於子 component 的呈現方式會因不同註冊服務的方式而有所不同 基本環境設定 來解釋一下，但先準備一下程式環境 123456789101112131415161718192021222324252627282930313233343536373839404142434445// AppComponent 的樣版&lt;div class="col-md-3"&gt; &lt;app-parent&gt;&lt;/app-parent&gt;&lt;/div&gt;&lt;div class="col-md-3"&gt; &lt;app-parent&gt;&lt;/app-parent&gt;&lt;/div&gt;// ParentComponetimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; SimpleService &#125; from '../simple.service';@Component(&#123; selector: 'app-parent', template: ` &lt;h4&gt;Parent Component&lt;/h4&gt; &lt;input type="text" [(ngModel)]="simpleService.name" /&gt; `, styleUrls: ['./parent.component.css']&#125;)export class ParentComponent &#123; constructor(public simpleService: SimpleService) &#123; &#125;&#125;// ChildComponentimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; SimpleService &#125; from '../simple.service';@Component(&#123; selector: 'app-child', template: ` Child Component &lt;br/&gt; value: &#123;&#123; simpleService.name &#125;&#125; `, styleUrls: ['./child.component.css']&#125;)export class ChildComponent &#123; constructor(public simpleService: SimpleService) &#123; &#125;&#125;// SimpleServiceimport &#123; Injectable &#125; from '@angular/core';@Injectable()export class SimpleService &#123; name: string;&#125; NgModule.providers 12345@NgModule(&#123; ... providers: [SimpleService]&#125;)export class AppModule &#123; &#125; 在初始狀態， SimpleService 是註冊在 app.module.ts 內，畫面是這樣 不論在左邊或是右邊的 Parent Component 輸入資料時，Child Component 都會顯示所輸入的資料 這時 service 取得的順序 很清楚的，不論是 ParentComponent 或是 ChildComponent 都是存取註冊在 NgModle 的 SimpleService (圖片擷取至codecraft.tv) Component.providers 這時當 ParentComponent 註冊 SimpleService 到 providers 內時，會有怎樣的效果呢 12345678910111213141516171819import &#123; Component, OnInit &#125; from '@angular/core';import &#123; SimpleService &#125; from '../simple.service';@Component(&#123; selector: 'app-parent', template: ` &lt;h4&gt;Parent Component&lt;/h4&gt; &lt;input type="text" [(ngModel)]="simpleService.name" /&gt; &lt;br/&gt; &lt;app-child&gt;&lt;/app-child&gt; &lt;!--或是這種方式--&gt; &lt;!--&lt;ng-content&gt;&lt;/ng-content&gt;--&gt; `, providers: [SimpleService], styleUrls: ['./parent.component.css']&#125;)export class ParentComponent &#123; constructor(public simpleService: SimpleService) &#123; &#125;&#125; 執行結果 service 取得的順序 (圖片擷取至codecraft.tv) 在這個情境，不論 ChildComponent 是已哪一種方式顯示在 ParentComponent 都會存取到註冊在 ParentComponent 的 providers，而因為 AppComponent 有兩個 ParentComponent ，所以各自有各自的 SimpleService 互不干擾 Component.viewProviders 如果將 SimpleService 註冊到 viewProviders 時，並子 component 是透過 &lt;ng-content&gt; 映射到 ParentComponent 時 1234567891011121314151617import &#123; Component, OnInit &#125; from '@angular/core';import &#123; SimpleService &#125; from '../simple.service';@Component(&#123; selector: 'app-parent', template: ` &lt;h4&gt;Parent Component&lt;/h4&gt; &lt;input type="text" [(ngModel)]="simpleService.name" /&gt; &lt;br/&gt; &lt;ng-content&gt;&lt;/ng-content&gt; `, viewProviders: [SimpleService], styleUrls: ['./parent.component.css']&#125;)export class ParentComponent &#123; constructor(public simpleService: SimpleService) &#123; &#125;&#125; 1234// app-component.html&lt;app-parent&gt; &lt;app-child&gt;&lt;/app-child&gt;&lt;/app-parent&gt; 執行結果 service 取得的順序 (圖片擷取至codecraft.tv) viewProviders 比較特殊一點，透過 &lt;ng-content&gt; 呈現與不透過 &lt;ng-content&gt; 的結果不一樣，假設使用 &lt;ng-content&gt; 的方式將 ChildComponent 映射到 ParentComponent 時，兩者所讀取的 SimpleService 會是不同一個 (可參閱上圖)；但如果是直接在 ParentComponent 上使用 ChildComponent 時，所存取的 SimpleService 就會跟 ParentComponent 一樣，這部分就要留意了 Recap component.providers 與 component.viewProviders 最大的差異如上述的實驗，是在 &lt;ng-content&gt;&lt;/ng-content&gt; 處理的部分，而這裡就是說明時提到的its view children 的意思了。表示如沒有在 template 上面看到，就不在 viewProviders 的管轄範圍內，可以透過準備好的範例程式，自己動手玩看看，比較有感覺。 Angular 的 DI 機制是很強大的，可以利用這樣的特行來滿足一些特需的效果 (暫時還想不到使用情境)，但至少不用因為註冊上的觀念誤解造成找不到資料的窘境出現 參考資料 stackblitz demo code NgModule.providers vs Component.providers vs Component.viewProviders]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 建立 Schematics Collection]]></title>
    <url>%2F2018%2F01%2F11%2Fangular-create-schematics%2F</url>
    <content type="text"><![CDATA[之前的文章介紹了 Schematics，現在就來自己建立一個 Schematics collection，我們希望建立出來的 collection 可以保留原有 Angular CLI 的功能，並擴充自己想要的樣板 基本設定 先建立一個資料夾 新增 package.json 檔案，請依基本的 npm 專案方式設定，新增下列設定 1"schematics": "./collection.json", 建立 collection.json 檔案，並新增以下內容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; "schematics": &#123; "class": &#123; "aliases": ["cl"], "extends": "@schematics/angular:class" &#125;, "component": &#123; "aliases": ["c"], "extends": "@schematics/angular:component" &#125;, "directive": &#123; "aliases": ["d"], "extends": "@schematics/angular:directive" &#125;, "enum": &#123; "aliases": ["e"], "extends": "@schematics/angular:enum" &#125;, "guard": &#123; "aliases": ["g"], "extends": "@schematics/angular:guard" &#125;, "interface": &#123; "aliases": ["i"], "extends": "@schematics/angular:interface" &#125;, "module": &#123; "aliases": ["m"], "extends": "@schematics/angular:module" &#125;, "pipe": &#123; "aliases": ["p"], "extends": "@schematics/angular:pipe" &#125;, "service": &#123; "aliases": ["s"], "extends": "@schematics/angular:service" &#125; &#125;&#125; 到這個步驟時，已經將 Angular CLI 既有的功能移植到我們的 collections 內了。接下來就將目前的檔案簽入到 GitHub 上，npm 可以設定 devDependencies 程式碼來源為 GitHub Repo，指定的方式是 1"&lt;&lt;package name&gt;&gt;": "&lt;&lt;GitHub account&gt;&gt;/&lt;&lt;repo name&gt;&gt;", 在新的或是既有的 Angular 專案，只要 Angular CLI 版本是在 1.4 版以上，都可以設定 collection，可修改 .angular-cli.json 檔案，設定方式如下 123456"defaults": &#123; "schematics": &#123; "collection": "&lt;&lt;package name&gt;&gt;" // 這裡指定你所安裝的 package 名稱 &#125; ... &#125; 當完成以上步驟時，我們還是可以正常的使用 Angular CLI 的指令，但是觸發的指令清單是根據我們版本的 collection，不在是預設的範本了，換句話說，我們可以更換指令，例如說 ng g component 的縮寫，希望從 c 改成 comp ，這是可行的，只要修改 collection.json 對應的 alias 即可 1234567891011// 修改前"component": &#123; "aliases": ["c"], "extends": "@schematics/angular:component" &#125;,// 修改後 "component": &#123; "aliases": ["comp"], "extends": "@schematics/angular:component" &#125;, 自訂範本 上一段我們完成沿用 Angular CLI 所提供的功能，現在要來製作自己的樣板了，基本的操作步驟是 在 collection.json 內新增一個指令區塊 12345"feature":&#123; "factory": "./src/feature", "schema": "./src/feature/schema.json", "description": "Create a feature module"&#125; 建立 feature 資料夾，並在資料夾內新增 index.ts 和 schema.json 兩個檔案 schema.json 內可設定建立 feature 時所需的參數，相對的也要建立 schema.d.ts 檔案 12345678910111213141516171819202122232425262728293031&#123; "$schema": "http://json-schema.org/schema", "id": "SchematicsSchematicSchema", "title": "Schematic Options Schema", "type": "object", "properties": &#123; "name": &#123; "type": "string", "description": "The name for the new feature module." &#125;, "sourceDir": &#123; "type": "string", "format": "path", "description": "The path of the source directory.", "default": "src", "visible": false &#125;, "prefix": &#123; "type": "string", "format": "html-selector", "description": "The prefix to apply to generated selectors.", "alias": "p" &#125;, "selector": &#123; "type": "string", "format": "html-selector", "description": "The selector to use for the component." &#125; &#125;, "required": ["name"]&#125; 123456789101112131415export interface Schema &#123; sourceDir?: string; /** * The name for the new feature module. */ name: string; /** * The prefix to apply to generated selectors. */ prefix?: string; /** * The selector to use for the component. */ selector?: string;&#125; index.ts 內容 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; Rule, SchematicsException, apply, Tree, SchematicContext, branchAndMerge, chain, mergeWith, move, template, url&#125; from '@angular-devkit/schematics';import * as stringUtils from '../strings';import &#123; Schema as FeatureOptions &#125; from './schema';function buildSelector(options: FeatureOptions) &#123; let selector = stringUtils.dasherize(options.name); if (options.prefix) &#123; selector = `$&#123;options.prefix&#125;-$&#123;selector&#125;`; &#125; return selector;&#125;export default function(options: FeatureOptions): Rule &#123; options.selector = options.selector || buildSelector(options); const sourceDir = options.sourceDir; if (!sourceDir) &#123; throw new SchematicsException(`sourceDir option is required.`); &#125; return (host: Tree, context: SchematicContext) =&gt; &#123; const templateSource = apply(url('./files'), [ template(&#123; ...stringUtils, ...options &#125;), move(sourceDir) ]); return chain([branchAndMerge(chain([mergeWith(templateSource)]))])(host, context); &#125;;&#125; 相關的程式碼請參閱 GitHub Repo 參考影片 ngHouston - CLI Schematics w/ Hans Larsen]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] monorepo 架構是否可行?]]></title>
    <url>%2F2018%2F01%2F08%2Fangular-monorepo-1%2F</url>
    <content type="text"><![CDATA[目前的管理程式碼，大致上可以分成兩種方式， mono 與 multiple repositories，通常是採 Multiple Repo，每一個系統都有自己的 repository 做版控，各自管理自己的套件版本，這聽起來很合理，但目前比較大型的軟體公司，像是 Google 、Facebook、Twitter 等。都是採取 mono repo 的開發模式(請留意上述公司都有自己一套的開發流程) ※沒有哪一種方法好，哪一種方法不好。都有各自的優缺點 ! 第一個問題是什麼是 Mono Repo? Mono Repo 是將各應用程式及相關的程式碼都放在同一個 Repo 下做管理，讓程式碼共用的複雜度降低，這裡有一部在 YouTube 上面的影片，說明 Google 內部是如何使用 Mono Repo 跟為什麼要這樣子做 這樣子有什麼樣的好處呢? 在提好處之前，先來看 Multiple Repositories 的好處有哪些 Clean ownership Better scale Narrow Clones 這些好處看起來沒有什麼問題，既然沒有問題，為什麼會有 Mono Repo 這種模式出來呢? 主要原因我想是當系統或是產品線變大時，有些底層重複性高的程式碼，變的很難管理。想想看，在後端寫 C# 專案時，從原本的單一專案，延伸出 n-tier 的架構，是為了怎樣的原因。 我想要表達的是，Mono Repo 的出現就是為了要解決 Multiple Repositories 的問題，而 Mono Repo 的好處有 Better developer testing - 開發者可以立即知道自己修改的程式碼會不會造成其他系統出錯 Reduced code complexity - 因為程式碼都在一起，所以初階工程是可以很容易取得並了解公司內標準的程式編寫原則 Effective code reviews Sharing of common components Easy refactoring 但沒有什麼東西是完美的，一定會有缺點的 Mono Repo 最大的問題是有沒有合適的工具做 CI/CD，當程式越大，建置測試的時間就會越久，所以要如何區分異動的程式碼所影響的範圍，而只針對影響範圍作測試的工作，以降低建置測試時間，這都是開發工具及環境設定要面對的問題。 另外一個問題是程式碼的健康程度，會影響 Mono Repo 所能帶出的效益。因為一個地方寫壞，有可能會造成整個系統的崩壞，Better developer testing 是一把雙刃劍，就看是從哪一個角度來看了 總結，兩種模式都有各自的優缺點，該如何結合兩者的優點，減少缺點，有什麼方式是 Angular 可以拿來用的，我覺得是值得思考的 延伸閱讀 Why Google Stores Billions of Lines of Code in a Single Repository CI/CD FOR MICROSERVICES USING MONOREPOS]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Rendertron]]></title>
    <url>%2F2017%2F12%2F25%2Fangular-rendertron%2F</url>
    <content type="text"><![CDATA[什麼是 rendertron ? rendertron 是 Google Chrome 團隊推出的另外一個新工具，這工具可以讓 PWA 網站遇到網路爬蟲或是分享到 twitter/Facebook 時，可以產出靜態頁面的效果。換句算說，這工具可以讓我們不用額外處理 Service Side Rendering 卻可以得到相同的效果 (僅局限於網路爬蟲或是 Rich Content Sharing時)。 簡介 rendertron 是如何運作的呢? 其實 rendertron 是透過 Headless Chrome 來讀取 PWA 網站並回傳所產生出來的結果，因為是使用瀏覽器來產生 DOM，所以通常在實作 Server Side Rendering 時會遇到的問題都不會發生，例如 document 物件不存在。 另外一個好處是，因為是使用瀏覽器來產生 DOM，所以任何前端技術都可以使用!! 因為是透過 proxy middleware 的方式來完成的，middleware 的設定方是根據文件，看起來並不複雜 Middleware 根據官方文件有 3 種設定使用的方式 Express.js middleware Firebase functions (Community maintained) ASP.net core middleware (Community maintained) 上述的三種方式都是使用同一個原理，那就判斷發出請求的對象是使用者還是網路爬蟲，如果是網路爬蟲，則使用 rendertron 所生的內容，如果是使用者，則直接輸出預設的內容 ASP.NET Core MVC 就以 ASP.NET Core MVC 來說，安裝使用方式如下 安裝 Galamai.AspNetCore.Rendertron 套件 新增 Startup.cs services 加入 AddRendertron 123456789public void ConfigureServices(IServiceCollection services)&#123; // Add rendertron services services.AddRendertron(options =&gt; &#123; // use http compression options.AcceptCompression = true; &#125;);&#125; 設定並使用 Rendertron 123// Use Rendertron middleware// 指定 rendertron 服務的位置app.UseRendertron(proxyUrl: "http://rendertron:8080/render/"); 成ㄕ 完成設定，這樣子就可以使用了 安裝 本地端 123git clone https://github.com/GoogleChrome/rendertron.gitcd rendertronnpm install 從 Github 將程式碼抓下來後，執行 npm install 後，即可透過 npm start 將 rendertron 執行起來 使用 docker image 12docker build -t rendertron . --no-cache=truedocker run -it -p 8080:8080 --name rendertron-container rendertron 開啟網頁 1http://localhost:8080/ 停止 container 1docker kill rendertron-container 清除 container 1docker rm -f $(docker ps -a -q) 參考資料 rendertron]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] CDK 系列 - Portal]]></title>
    <url>%2F2017%2F12%2F02%2Fangular-cdk-portal%2F</url>
    <content type="text"><![CDATA[Angular Material 團隊在前一陣子推出 Angular CDK 的套件，什麼是 Angular CDK ? 簡單的說就是 Angular material 2 底層在使用的功能而樣式的部分就留給我們自己設計。 The goal of the CDK is to give developers more tools to build awesome components for the web. This will be especially useful for projects that want to take advantage of the features of Angular Material without adopting the Material Design visual language. — Angular Team Introduction CDK 這一系列的文章就會記錄探索 CDK 功能的筆記，今天會先從 Portal 開始看起。 Portal 是什麼 ? Portal 是一個可以讓我們動態載入 Component 的一個功能。跟 ngComponentOutlet 要達到的效果是一樣的，但是 Portal 又額外提供一些功能能讓我們做延伸的應用 Angular CDK裡的 Portal 有兩個元素 Portal 是用來包 template 或是 component 的 PortalHost 是顯示 portal 的地方，可以附加在網頁上的任何地方，例如 document.body 基本用法 當要使用 Portal 相關的 directive 時，需要 import PortalModule 123456789import &#123; PortalModule &#125; from '@angular/cdk/portal';@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, PortalModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 12345678910111213141516171819&lt;div class="demo-portal-outlet"&gt; &lt;ng-template [cdkPortalOutlet]="selectedPortal"&gt;&lt;/ng-template&gt;&lt;/div&gt;&lt;button type="button" (click)="selectedPortal = programmingJoke"&gt; Programming joke&lt;/button&gt;&lt;button type="button" (click)="selectedPortal = mathJoke"&gt; Math joke&lt;/button&gt;&lt;ng-template cdk-portal&gt; &lt;p&gt; - Why don't jokes work in octal?&lt;/p&gt; &lt;p&gt; - Because 7 10 11.&lt;/p&gt;&lt;/ng-template&gt;&lt;div *cdk-portal&gt; &lt;p&gt; - Did you hear about this year's Fibonacci Conference? &lt;/p&gt; &lt;p&gt; - It's going to be as big as the last two put together. &lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920import &#123; Component, ViewChildren, QueryList &#125; from '@angular/core';import &#123; Portal, CdkPortal &#125; from '@angular/cdk/portal';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; @ViewChildren(CdkPortal) templatePortals: QueryList&lt;Portal&lt;any&gt;&gt;; selectedPortal: Portal&lt;any&gt;; get programmingJoke() &#123; return this.templatePortals.first; &#125; get mathJoke() &#123; return this.templatePortals.last; &#125;&#125; 當按鈕按下時，就會將 &lt;ng-template [cdkPortalOutlet]=&quot;selectedPortal&quot;&gt;&lt;/ng-template&gt; 換成我們想要顯示的內容，同樣的，如果要將 Component 顯示在同一個位置，可以這樣子寫 123get scienceJoke() &#123; return new ComponentPortal(ScienceJoke);&#125; 使用 ComponentPortal 來將 component 包起來後，就可以顯示在 cdkPortalOutlet 的所在位置了 進階用法 假使說，不想要透過 ckdPortalOutlet 的方式，是否有辦法透過程式的方式，動態插入到畫面上呢? cdk/portal有提供另外一個方法叫做 PortalHost，可以透過這一個物件來將 Portal 顯示在我們所指定的位置上 app.component.ts 1234567891011121314151617181920212223...private bodyPortalHost: DomPortalHost;constructor( private componentFactory: ComponentFactoryResolver, private appRef: ApplicationRef, private injector: Injector) &#123;&#125;ngAfterViewInit() &#123; this.bodyPortalHost = new DomPortalHost( document.querySelector('#display'), this.componentFactory, this.appRef, this.injector ); &#125;setDisplayPort(displayPortal) &#123; if (this.bodyPortalHost.hasAttached) &#123; this.bodyPortalHost.detach(); &#125; this.bodyPortalHost.attach(displayPortal);&#125; index.html 1234...&lt;div id="display"&gt;&lt;/div&gt;&lt;app-root&gt;&lt;/app-root&gt;... app.component.html 12345678910111213141516&lt;button type="button" (click)="setDisplayPort(programmingJoke)"&gt; Programming joke&lt;/button&gt;&lt;button type="button" (click)="setDisplayPort(mathJoke)"&gt; Math joke&lt;/button&gt;&lt;ng-template cdk-portal&gt; &lt;p&gt; - Why don't jokes work in octal?&lt;/p&gt; &lt;p&gt; - Because 7 10 11.&lt;/p&gt;&lt;/ng-template&gt;&lt;div *cdk-portal&gt; &lt;p&gt; - Did you hear about this year's Fibonacci Conference? &lt;/p&gt; &lt;p&gt; - It's going to be as big as the last two put together. &lt;/p&gt;&lt;/div&gt; 當按鈕按下時，就會將所要顯示的 ng-template 透過 DomPortalHost 的方式插入到所指定的位置，而這個位置不侷限於 Angular 的頁面上，可以指到任何地方，只要能取到該 HTMLElement 即可 這裡需要留意的是 一個DomPortalHost 一次只能顯示一個 Portal ，當要顯示不同 Portal 時，就必須先將之前的移除 (detach()) 相關API hasAttached 判斷 DomHostPortal 是否有附加任何的 Portal attach 附加 Portal 至 DomHostPortal 上 detach 從 DomHostPortal 上移除 Portal dispose清除 DomHostPortal 物件 參考資料 Angular CDK - Portal]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 利用 Angular CLI 1.6 建立 PWA 網站]]></title>
    <url>%2F2017%2F11%2F25%2Fangular-pwa%2F</url>
    <content type="text"><![CDATA[Angular CLI 1.6 預設內建 service-worker 功能，只要在建立時加個參數，就可以將 service-worker 設定起來，就是這麼方便，但細節設定呢? !! 請注意，以下的內容必須使用 Angular CLI 1.6 板材可以使用 基本 當安裝完 Angular CLI 1.6 後，ng new 的指令參數增加了 —service-worker ，建立包含 service-worker 的專案所需要打的指令，可依自己的需求調整參數 1ng new &lt;project name&gt; --service-worker 當新增這參數後，CLI會幫我們做以下的事情 安裝 npm install @angular/service-worker .angular-cli.json 內開啟 service-worker: true 的設定 在 app.module.ts 內註冊 ngsw-worker.js 檔案 12345678910111213141516...import &#123; ServiceWorkerModule &#125; from '@angular/service-worker';...@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, environment.production ? ServiceWorkerModule.register('/ngsw-worker.js') : [] ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 建立ngsw-config.json檔案，ng build —prod 後產生的 ngsw.json 會根據這個 json 檔案內容 123456789101112131415161718192021222324252627&#123; "index": "/index.html", "assetGroups": [&#123; "name": "app", "installMode": "prefetch", "resources": &#123; "files": [ "/favicon.ico", "/index.html" ], "versionedFiles": [ "/*.bundle.css", "/*.bundle.js", "/*.chunk.js" ] &#125; &#125;, &#123; "name": "assets", "installMode": "lazy", "updateMode": "prefetch", "resources": &#123; "files": [ "/assets/**" ] &#125; &#125;]&#125; ​ service worker 只會在 ng build —prod 的時候被產生出來，所以就讓我們做第一次的建置 1ng build --prod 到這個步驟，最基本的 PWA 網站就算完成了 注意: 請勿在 ng server 模式下測試 Angular Service Worker 設定檔 關於 service worker 相關的設定項目，都可以在 ngsw-config.json 內設定，包含 cacheing 的方式跟時間等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @license * Copyright Google Inc. All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license *//** * @experimental */export declare type Glob = string;/** * @experimental */export declare type Duration = string;/** * A top-level Angular Service Worker configuration object. * * @experimental */export interface Config &#123; appData?: &#123;&#125;; index: string; assetGroups?: AssetGroup[]; dataGroups?: DataGroup[];&#125;/** * Configuration for a particular group of assets. * * @experimental */export interface AssetGroup &#123; name: string; installMode?: 'prefetch' | 'lazy'; updateMode?: 'prefetch' | 'lazy'; resources: &#123; files?: Glob[]; versionedFiles?: Glob[]; urls?: Glob[]; &#125;;&#125;/** * Configuration for a particular group of dynamic URLs. * * @experimental */export interface DataGroup &#123; name: string; urls: Glob[]; version?: number; cacheConfig: &#123; maxSize: number; maxAge: Duration; timeout?: Duration; strategy?: 'freshness' | 'performance'; &#125;;&#125; 上列的介面定義檔說明了很詳細，對於 DataGroup 內的 cacheConfig strategy 有兩個可以選擇 freshness: network first mode performance: cache first mode 其他備註 [2018-01-19 更新] 在後來使用時，發現一個很神奇的現象，假如我有使用到 RxJS 的狀態時，單純使用 ServiceWorkerModule.register('/ngsw-worker.js') 是無法將 service-worker 成功註冊起來，必須在 main.ts 修正成這樣，才能成功註冊 service-worker 12345678platformBrowserDynamic() .bootstrapModule(AppModule) .then(() =&gt; &#123; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/ngsw-worker.js'); &#125; &#125;) .catch(err =&gt; console.log(err)); Recap Angular CLI 1.6 版讓我們可以很容易地將 service-worker 的功能加到專案內，而 service worker 的功能不只有離線瀏覽的功能，還有 push notification 的功能，或是如何利用程式碼的方式更新 service worker cache 的內容，將在下一篇文章中說明]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 手動創造出 Lazy Loading 的效果]]></title>
    <url>%2F2017%2F11%2F08%2Fmanual-lazy-loading%2F</url>
    <content type="text"><![CDATA[一般提起 Angular 的 Lazy Loading 時，第一個反應都是透過網址的方式來實作，但是否有方法可以借用 RouterModule 的幫助來產生 chunk 檔案，然後手動作載入的動作呢? 答案是可以的 環境設定 其實在 RouterModule 底層在執行 Lazy Loading 效果的方法，是藉由 NgModuleFactoryLoader 來完成的， 而底下有一個 subclass 叫做 SystemJsNgModuleLoader，這一個是我們所需要的 NgModuleLoader，將其註冊在 module providers 區區塊內，所以 Module Loader 有了，那要怎麼註冊 module 成為可以延遲載入的 module 呢? 方法有兩個 使用 RouterModule.forChild(routes) 的方式註冊 modules 123456789101112const routes: Route[] = [ &#123; loadChildren: 'app/lazy1/lazy1.module#Lazy1Module' &#125;, &#123; loadChildren: 'app/lazy2/lazy2.module#Lazy2Module' &#125;];@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, FormsModule, RouterModule.forChild(routes)], providers: [SystemJsNgModuleLoader], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 使用 provideRoutes 的方式註冊 modules 123456789101112const routes: Route[] = [ &#123; loadChildren: 'app/lazy1/lazy1.module#Lazy1Module' &#125;, &#123; loadChildren: 'app/lazy2/lazy2.module#Lazy2Module' &#125;];@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, FormsModule], providers: [provideRoutes(routes), SystemJsNgModuleLoader], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 上述的兩種方式都可以達到一樣的效果 使用方式 constructor 環境設定好後，該如何使用呢? 這裡以 app.component.ts 為例，首先先在 constructor 載入 SystemJsNgModuleLoader 1constructor(private moduleLoader: SystemJsNgModuleLoader) &#123;&#125; template 範例我使用的 html 如下 12345&lt;button (click)="go('lazy1')"&gt;GO TO Lazy1&lt;/button&gt;&lt;button (click)="go('lazy2')"&gt;GO TO Lazy2&lt;/button&gt;&lt;!-- &lt;div #container&gt;&lt;/div&gt; --&gt;&lt;ng-container *ngComponentOutlet="OtherModuleComponent;ngModuleFactory: myModule;"&gt;&lt;/ng-container&gt; HTML說明 ngComponentOutlet 支援使用 ngModuleFactory 的方法產生 Component， 兩個按鈕都按下後，會將各 Module 所指定的 EntryComponent 顯示在 ng-conainer 的地方 lazy module 其中一個 LazyModule 的程式碼如下 12345678@NgModule(&#123; imports: [CommonModule], declarations: [Lazy1Component], entryComponents: [Lazy1Component]&#125;)export class Lazy1Module &#123; static entry = Lazy1Component;&#125; 需要留意的是，由於我們會動態載入 component ，所以該 component 需要被註冊在 entryComponents 的區塊內。 另外於 Lazy1Module 的 區塊內設定一個 static property ，等一下在載入 module’s component 時會用到 go method 12345678910111213141516const modules = &#123; lazy1: 'app/lazy1/lazy1.module#Lazy1Module', lazy2: 'app/lazy2/lazy2.module#Lazy2Module'&#125;;...OtherModuleComponent = undefined;myModule: NgModuleFactory&lt;any&gt;;go(moduleName) &#123; const path: string = modules[moduleName]; this.moduleLoader.load(path).then((moduleFactory: NgModuleFactory&lt;any&gt;) =&gt; &#123; const entryComponent = (&lt;any&gt;moduleFactory.moduleType).entry; this.myModule = moduleFactory; this.OtherModuleComponent = entryComponent; &#125;);&#125; 還記得在 constructor 所注入的 SystemJsNgModuleLoader，該 class 只有一個 load 函式，這一個 load 函式接受一個引數，是用來指定要載入的 module 位置，這個位置會跟 AppModule 所設定的一樣。 1load(path: string): Promise&lt;NgModuleFactory&lt;any&gt;&gt; 當成功載入時，會回傳一個 NgModuleFactory ，這個 NgModuleFactory 就可以直接指定給 ngComponentOutlet 使用，而 component 的部分，可以由剛剛所設定的靜態變數 entry 取得，一樣指定給 ngComponentOutlet 使用。 這樣子就完成手動載入 NgModule 的功能了，是不是很簡單!!! 延伸應用 Angular 在 Multi Page Application 的應用情境下，可以利用這樣的模式，動態的載入所需要的 NgModule 並啟用 Component 12345678910111213141516171819ngDoBootstrap(appRef: ApplicationRef) &#123; const widgets = document.querySelectorAll('[data-module-path]'); for (const i in widgets) &#123; if (widgets.hasOwnProperty(i)) &#123; const modulePath = widgets[i].getAttribute('data-module-path'); if (modulePath) &#123; this.moduleLoader.load(modulePath).then((moduleFactory: NgModuleFactory&lt;any&gt;) =&gt; &#123; const entryComponent = (&lt;any&gt;moduleFactory.moduleType).entry; const ngModuleRef = moduleFactory.create(this.injector); const compFactory = ngModuleRef.componentFactoryResolver.resolveComponentFactory(entryComponent); // 這裡的selector 就會跟 app-root 一樣 if (document.querySelector(compFactory.selector)) &#123; appRef.bootstrap(compFactory); &#125; &#125;); &#125; &#125; &#125; &#125; 1234&lt;app-root data-module-path="./lazy1/lazy1.module#Lazy1Module"&gt;&lt;/app-root&gt;&lt;app-root data-module-path="./lazy2/lazy2.module#Lazy2Module"&gt;&lt;/app-root&gt; 參考資料 stackblitz live demo GitHub Repo ngComponentOutlet NgModuleFactoryLoader SystemJsNgModuleLoader Angular 2 in a multi-page application]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Schematics]]></title>
    <url>%2F2017%2F10%2F26%2Fangular-schematics%2F</url>
    <content type="text"><![CDATA[Angular CLI 1.4 版以後，樣板的產生器就改使用 @angular-devkit/schematics ，而在 10 月初，Nrwl.io 也推出 nx 版的 schematics 樣版集合，所以什麼是 schematics ，我們可以利用他來做什麼樣的事情呢? 簡介 @angular/schematics 是包含在 @angular/devkit 內，他是一個定義樣板的架構，類似 ember cli 內的 blueprint，利用 json 設定檔及預設的檔案範本，可以利用指令產生出我們所設定的檔案內容 schematics 有分兩個部分，@angular-devkit/schematics 屬於 runner，而 @schematics/angular 屬於範本集合 (Angular CLI 所使用的範本集合)。 架構 collection.json 如之前所說，schematics 是一個集合，所有的定義項目都可以在 collection.json 內看到，也可以說是集合的進入點 12345678910111213141516171819202122&#123; "schematics": &#123; "application": &#123; "factory": "./application", "schema": "./application/schema.json", "description": "Create an Angular application." &#125;, "class": &#123; "aliases": [ "cl" ], "factory": "./class", "description": "Create a class.", "schema": "./class/schema.json" &#125;, "component": &#123; "aliases": [ "c" ], "factory": "./component", "description": "Create an Angular component.", "schema": "./component/schema.json" &#125;, ... &#125;&#125; collection.json 檔案的第一層是 schemtaics，在這一個節點下，就是各指令的定義檔，例如 application、class 或 component 等，都會對應一個資料夾 以 class 為例 123456"class": &#123; "aliases": [ "cl" ], "factory": "./class", "description": "Create a class.", "schema": "./class/schema.json" &#125;, aliases: 指令的縮寫，例如 ng generate class 也可以使用縮寫代替 ng generate cl factory: 所有的邏輯存放的所在地 description: 資訊描述 schema: 參數設定檔 schema.json 進入 class 資料夾，並開啟 schema.json 檔案，內容如下 1234567891011121314151617181920212223242526272829303132333435&#123; "$schema": "http://json-schema.org/schema", "id": "SchematicsAngularClass", "title": "Angular Class Options Schema", "type": "object", "properties": &#123; "name": &#123; "type": "string" &#125;, "appRoot": &#123; "type": "string" &#125;, "path": &#123; "type": "string", "default": "app" &#125;, "sourceDir": &#123; "type": "string", "default": "src" &#125;, "spec": &#123; "type": "boolean", "description": "Specifies if a spec file is generated.", "default": false &#125;, "type": &#123; "type": "string", "description": "Specifies the type of class.", "default": "" &#125; &#125;, "required": [ "name" ]&#125; 在 properties 下可以定義所有的變數的型別、描述及預設值，requried 設定必須輸入的欄位 index.ts index.ts 檔案會是 factory 所指定的資料夾下首先會被執行的檔案 1import &#123; Schema as ClassOptions &#125; from './schema'; Schema 是針對 schema.json 的 properties 區塊定義項目的介面檔，主要功能是提供 index.ts 內使用 1234567891011121314export interface Schema &#123; name: string; appRoot?: string; path?: string; sourceDir?: string; /** * Specifies if a spec file is generated. */ spec?: boolean; /** * Specifies the type of class. */ type?: string;&#125; 基本架構 123456789101112131415161718192021222324252627export default function (options: ClassOptions): Rule &#123; options.type = !!options.type ? `.$&#123;options.type&#125;` : ''; options.path = options.path ? normalize(options.path) : options.path; const sourceDir = options.sourceDir; if (!sourceDir) &#123; throw new SchematicsException(`sourceDir option is required.`); &#125; // 範本存放的位置 const templateSource = apply(url('./files'), [ options.spec ? noop() : filter(path =&gt; !path.endsWith('.spec.ts')), // 建立範本 template(&#123; ...stringUtils, ...options as object, &#125;), // 移動建立後的檔案到指定的位置 move(sourceDir), ]); // 合併新建立的檔案與既有檔案 return chain([ branchAndMerge(chain([ mergeWith(templateSource), ])), ]);&#125; files 資料夾 會看到 __name@dasherize____type__.ts 的檔案，這裡看到的 __name (兩個底線) 會對應到 schema.json properties 所定義的變數名稱 name ，同樣的 __type 也相對應於 type 的參數，同樣的規則，是用於資料夾名稱 @dasherize 是一個函式，接受後面的引數並處理後回結果，這段的效果等同於 dasherize(type) 但實際的傳入的值是透過 index.ts 內的 template 傳入的參數集合 (如下註解) 1234template(&#123; ...stringUtils, ...options as object, // 傳入的參數集合 &#125;), 在該檔案內的內容，可以看到 name ，同樣的代表的 name 變數 12export class &lt;%= classify(name) %&gt; &#123;&#125; classify 函式的效果是將 someFunction 主換成 SomeFunction 自訂 schematics 集合 目前最快的方式，是直接複製 @schematics/angular 來改，但其實 @angular/dev-kit 有提供命令的方式來建立~~(還在研究中，等研究出來後在寫另外一篇文章分享)~~ 請參考下一段 123$ cd ~/n/lib/node_modules/@angular/cli/node_modules/ (angular cli 全域的安裝位置)$ mkdir -p @custom/myangular$ cp -R @schematics/angular/* @custom/myangular/ 上述的指令，等同於直接在全域的 Angular CLI 下建立一個新的 schematics 範本集合 當在執行 ng new 時，可以加上 --collection 來設定要使用的 schematics 1ng new --collection=@custom/myangular myapp 創建 schematic @angular/dev-kit 有提供建立的指令，在這之前需先安裝三個工具 123npm i -g @angular-devkit/schematicsnpm i -g @schematics/schematicsnpm i -g rxjs 安裝完成後，即可透過 schematics 的指令建立範本集，預設有兩種範本 blank 和 schematic 。建立指令 1234// schematic templateschematics @schematics/schematics:schematic --name &lt;&lt;collection name&gt;&gt;// blank templateschematics @schematics/schematics:blank --name &lt;&lt;collection name&gt;&gt; 建立後的專案結構 之後就可按上面所介紹的方式建立自己的範本，當然也可參考其他人的 schematics ，例如 nx 或是 ngrx，我相信之後會有更多各式各樣的範本出來 參考資料 ngAir 134 - Angular Schematics with Mike Brocchi angular/devkit ngrx schematic]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular 建立 Injector 的流程]]></title>
    <url>%2F2017%2F09%2F24%2Fangular-injector%2F</url>
    <content type="text"><![CDATA[Angular 有內建一套 Dependency Injection 框架，可以讓我們簡單的完成 DI 的相關行為，Angular 內部是如何運作建置 Injector 的呢? 讓我們來研究一下 Angular 建立 Injector 的方式 從 platformBrowserDynamic() 執行時，就會開始一系列的初始建置 platform 的動作，這其中包含 Injector 的設定，從原始碼整理出的順序是執行 platformBrowerDynamic() 事實上就是執行 createPlatformFactory的動作。 123456789101112// 進入點export const platformBrowserDynamic = createPlatformFactory( platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);// 第二層的 platformCoreDynamicexport const platformCoreDynamic = createPlatformFactory(platformCore, 'coreDynamic', [ &#123;provide: COMPILER_OPTIONS, useValue: &#123;&#125;, multi: true&#125;, &#123;provide: CompilerFactory, useClass: JitCompilerFactory, deps: [COMPILER_OPTIONS]&#125;,]);// 最底層的 platformCoreexport const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS); createPlatformFactory 接受三個參數， parent platform: 這裡就是 platformCore platform 的名稱 要註冊至 Injector 的 provider ，型別為 StaticProvider 在 createPlatFormFactory 裡，如果沒有 parent platform 時，才會建立 Injector，而這裡就是指 platformCore 的部分，也是我們要關注的地方， Injector.Create 1234567891011121314151617181920export function createPlatformFactory( parentPlatformFactory: ((extraProviders?: StaticProvider[]) =&gt; PlatformRef) | null, name: string, providers: StaticProvider[] = []): (extraProviders?: StaticProvider[]) =&gt; PlatformRef &#123; const marker = new InjectionToken(`Platform: $&#123;name&#125;`); return (extraProviders: StaticProvider[] = []) =&gt; &#123; let platform = getPlatform(); if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) &#123; if (parentPlatformFactory) &#123; parentPlatformFactory( providers.concat(extraProviders).concat(&#123;provide: marker, useValue: true&#125;)); &#125; else &#123; // 建立 Injector createPlatform(Injector.create( providers.concat(extraProviders).concat(&#123;provide: marker, useValue: true&#125;))); &#125; &#125; return assertPlatform(marker); &#125;;&#125; Injector 裡的 create 方法是一個 static method，真正使用到 Injector.create 的地方有三處，其餘的皆測試檔案裡使用。 createPlatformFactory compiler_factory TestBed 12345678export abstract class Injector &#123; static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND; static NULL: Injector = new _NullInjector(); ... static create(providers: StaticProvider[], parent?: Injector): Injector &#123; return new StaticInjector(providers, parent); &#125;&#125; StaticInjector 的程式碼如下 123456789101112131415161718192021222324export class StaticInjector implements Injector &#123; readonly parent: Injector; private _records: Map&lt;any, Record&gt;; constructor(providers: StaticProvider[], parent: Injector = NULL_INJECTOR) &#123; this.parent = parent; // 重點在這裡 const records = this._records = new Map&lt;any, Record&gt;(); records.set( Injector, &lt;Record&gt;&#123;token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false&#125;); recursivelyProcessProviders(records, providers); &#125; get&lt;T&gt;(token: Type&lt;T&gt;|InjectionToken&lt;T&gt;, notFoundValue?: T): T; get(token: any, notFoundValue?: any): any; get(token: any, notFoundValue?: any): any &#123; ... &#125; toString() &#123; ... &#125;&#125; 由此可以看出 Injector 其實內部是透過 Map 的方式來管理 Providers 的，而 recursivelyProcessProviders 是用來將傳入的 providers 陣列註冊到 records 中，以供後續使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function recursivelyProcessProviders(records: Map&lt;any, Record&gt;, provider: StaticProvider) &#123; if (provider) &#123; provider = resolveForwardRef(provider); if (provider instanceof Array) &#123; // if we have an array recurse into the array for (let i = 0; i &lt; provider.length; i++) &#123; recursivelyProcessProviders(records, provider[i]); &#125; &#125; else if (typeof provider === 'function') &#123; throw staticError('Function/Class not supported', provider); &#125; else if (provider &amp;&amp; typeof provider === 'object' &amp;&amp; provider.provide) &#123; // 對應 forwardRef decorator let token = resolveForwardRef(provider.provide); // resolveProvider 是另外一個重點 function，解析各式的 provider 設定 const resolvedProvider = resolveProvider(provider); if (provider.multi === true) &#123; // This is a multi provider. let multiProvider: Record|undefined = records.get(token); if (multiProvider) &#123; if (multiProvider.fn !== MULTI_PROVIDER_FN) &#123; throw multiProviderMixError(token); &#125; &#125; else &#123; // Create a placeholder factory which will look up the constituents of the multi provider. records.set(token, multiProvider = &lt;Record&gt;&#123; token: provider.provide, deps: [], useNew: false, fn: MULTI_PROVIDER_FN, value: EMPTY &#125;); &#125; // Treat the provider as the token. token = provider; multiProvider.deps.push(&#123;token, options: OptionFlags.Default&#125;); &#125; const record = records.get(token); if (record &amp;&amp; record.fn == MULTI_PROVIDER_FN) &#123; throw multiProviderMixError(token); &#125; records.set(token, resolvedProvider); &#125; else &#123; throw staticError('Unexpected provider', provider); &#125; &#125;&#125; 在上列的程式碼中，有幾個重點 forwardRef：Allows to refer to references which are not yet defined. 12345678export function resolveForwardRef(type: any): any &#123; if (typeof type === 'function' &amp;&amp; type.hasOwnProperty('__forward_ref__') &amp;&amp; type.__forward_ref__ === forwardRef) &#123; return (&lt;ForwardRefFn&gt;type)(); &#125; else &#123; return type; &#125;&#125; resolveProvider：分析 provider 的註冊是否合法 1234567891011121314151617181920212223242526function resolveProvider(provider: SupportedProvider): Record &#123; const deps = computeDeps(provider); let fn: Function = IDENT; let value: any = EMPTY; let useNew: boolean = false; let provide = resolveForwardRef(provider.provide); if (USE_VALUE in provider) &#123; // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined. value = (provider as ValueProvider).useValue; &#125; else if ((provider as FactoryProvider).useFactory) &#123; fn = (provider as FactoryProvider).useFactory; &#125; else if ((provider as ExistingProvider).useExisting) &#123; // Just use IDENT &#125; else if ((provider as StaticClassProvider).useClass) &#123; useNew = true; fn = resolveForwardRef((provider as StaticClassProvider).useClass); &#125; else if (typeof provide == 'function') &#123; useNew = true; fn = provide; &#125; else &#123; throw staticError( 'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider); &#125; return &#123;deps, fn, useNew, value&#125;;&#125; 到這裡，已經可以看出 Inector 的運作模式，但到這個階段也同時建立 Application-Wild 層級的 Injector，預設在 platform 層級所註冊的 provider 有下列幾項 {provide: ResourceLoader, useClass: CachedResourceLoader, deps: []} {provide: COMPILER_OPTIONS, useValue: {}, multi: true} {provide: CompilerFactory, useClass: JitCompilerFactory, deps: [COMPILER_OPTIONS]} {provide: PLATFORM_ID, useValue: 『unknown』} {provide: PlatformRef, deps: [Injector]} {provide: TestabilityRegistry, deps: []} {provide: Console, deps: []} 之前有提過 Injector.create 除了測試檔案外，只有三個地方會出現，而 CompilerFactory 是其中一個，這裡我們可以知道 CompilerFactory 是使用 JitCompilerFactory 來編譯 Component，這裡另外建立一個 Injector，所以這裡所註冊的 Provider 會限制於在此層級使用 1234567891011121314151617181920212223242526272829303132333435363738export class JitCompilerFactory implements CompilerFactory &#123; private _defaultOptions: CompilerOptions[]; constructor(defaultOptions: CompilerOptions[]) &#123; const compilerOptions: CompilerOptions = &#123; useJit: true, defaultEncapsulation: ViewEncapsulation.Emulated, missingTranslation: MissingTranslationStrategy.Warning, enableLegacyTemplate: false, &#125;; this._defaultOptions = [compilerOptions, ...defaultOptions]; &#125; createCompiler(options: CompilerOptions[] = []): Compiler &#123; const opts = _mergeOptions(this._defaultOptions.concat(options)); const injector = Injector.create([ COMPILER_PROVIDERS, &#123; provide: CompilerConfig, useFactory: () =&gt; &#123; return new CompilerConfig(&#123; // let explicit values from the compiler options overwrite options // from the app providers useJit: opts.useJit, jitDevMode: isDevMode(), // let explicit values from the compiler options overwrite options // from the app providers defaultEncapsulation: opts.defaultEncapsulation, missingTranslation: opts.missingTranslation, enableLegacyTemplate: opts.enableLegacyTemplate, preserveWhitespaces: opts.preserveWhitespaces, &#125;); &#125;, deps: [] &#125;, opts.providers ! ]); return injector.get(Compiler); &#125;&#125; 在 JitCompilerFactory 內的 createCompiler 函式會在 bootstrapModule 時被執行，bootstrapModule 是 platformBrowserDynamic() 建立後的下一個動作，bootstrapModule 定義在 PlatformRef 中 1platformBrowserDynamic().bootstrapModule(AppModule); 1234567891011bootstrapModule&lt;M&gt;( moduleType: Type&lt;M&gt;, compilerOptions: (CompilerOptions&amp;BootstrapOptions)| Array&lt;CompilerOptions&amp;BootstrapOptions&gt; = []): Promise&lt;NgModuleRef&lt;M&gt;&gt; &#123; const compilerFactory: CompilerFactory = this.injector.get(CompilerFactory); const options = optionsReducer(&#123;&#125;, compilerOptions); // 建立另外一個新的 Injector const compiler = compilerFactory.createCompiler([options]); return compiler.compileModuleAsync(moduleType) .then((moduleFactory) =&gt; this.bootstrapModuleFactory(moduleFactory, options));&#125; 結論 了解 Angular 底層 DI 的運作原理後，雖然對實際開發沒有什麼實質上的效益 XD，純粹滿足好奇心而已]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]與DOTNET MVC CORE 整合]]></title>
    <url>%2F2017%2F09%2F17%2Fmvc-core-with-angular%2F</url>
    <content type="text"><![CDATA[.NET Core 所提供的 Angular SPA 範本，用起來都覺得卡卡的，所以只好自己來整一個給 Angular 所使用的架構，跟著以下的步驟，就可以整理出我覺得還滿意的 .NET MVC Core 的程式架構 操作步驟 建立 ASP.NET Core Web 應用程式 首先，先用 Visual Studio 2017 建立一個 ASP.NET Core Web 應用程式 按下【確定】建立新專案，當建立完成後，即可獲得一個已經可執行的 ASP.NET Core 的 Web 應用程式了 建立 Angular 專案 打開命令視窗，並切換至專案目錄下 執行 ng new clientApp 命令，透過 Angulra CLI 的方式將 Angular 專案建立起來 建立完成後即可在 Visual Studio 的專案下看到剛剛所建立的 clientApp 資料夾 修改 .angular-cli.json 由於 Angular 的專案希望是由 MVC 這邊顯示，所以在建置的過程中，需要將 .angular-cli.json 內的設定做些微的調整 修改輸出路徑 增加 deployUrl 產生一個 script.html，用來接受 CLI 建置後的檔案路徑 123456789101112131415161718192021222324252627"apps": [ &#123; "root": "src", "outDir": "../wwwroot/dist", "deployUrl": "/dist/", "assets": [ "assets", "favicon.ico" ], "index": "script.html", "main": "main.ts", "polyfills": "polyfills.ts", "test": "test.ts", "tsconfig": "tsconfig.app.json", "testTsconfig": "tsconfig.spec.json", "prefix": "app", "styles": [ "styles.css" ], "scripts": [], "environmentSource": "environments/environment.ts", "environments": &#123; "dev": "environments/environment.ts", "prod": "environments/environment.prod.ts" &#125; &#125; ], 修改 app.module.ts 由於啟動的 component 不一定會存在顯示頁面上，所以必須在 app.module.ts 的地方調整一下啟動方式 先將 AppComponent 從 bootstrap 區塊移動到 entryComponents 的地方 123456@NgModule(&#123; declarations: [AppComponent, HomeComponent, EmptyComponent], imports: [BrowserModule, RouterModule.forRoot(routes)], entryComponents: [AppComponent]&#125;)... ​ 在 AppModule Class 內新增 ngDobootstrap 函式 12345ngDoBootstrap(app: ApplicationRef) &#123; if (document.querySelector('app-root')) &#123; app.bootstrap(AppComponent); &#125; &#125; ​ 修改 _layout.cshtml 將在 .angular-cli.json 所設定輸出的 html 檔案內容加入到 _layout.cshtml 內，這裡要使用 ViewComponent 的方式來處理，不然當部屬到 Azure 時會壞掉 12345678910111213public class ScriptHTMLViewComponent : ViewComponent&#123; private IHostingEnvironment _env; public ScriptHTMLViewComponent(IHostingEnvironment env) &#123; _env = env; &#125; public async Task&lt;IViewComponentResult&gt; InvokeAsync() &#123; var model = System.IO.File.ReadAllText(Path.Combine(_env.WebRootPath, "dist", "script.html")); return View("Index", model); &#125;&#125; Shared/Components/ScriptHTML/Index.cshtml 12@model string@Html.Raw(Model) _layout.cshtml 1@await Component.InvokeAsync("ScriptHTML") 修改 Startup.cs 新增一條新的路由給 Angular 使用 12345678app.UseMvc(routes =&gt; &#123; routes.MapRoute( name: "default", template: "&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"); routes.MapSpaFallbackRoute("spa-fallback", new &#123; controller = "Home", action = "Angular" &#125;); &#125;); 新增 Home/Angular 在 HomeController 內新增 Angular Action 1234public IActionResult Angular()&#123; return View();&#125; 並將相對應的 View 檔案也建立起來，並新增 Angular 的 root component 1&lt;app-root&gt;&lt;/app-root&gt; 基本上經這個幾個步驟的設定，已經將 Angular 的專案整合到 ASP.NET Core Web 專案內了 路由 關於路由部分，由於 Angular 與 MVC 本身都有自己的路由系統，而這兩個系統都會作用，所以要稍微留意 通常一個頁面有可能是純的 Razor 頁面，或是 Angular 所 render 的頁面，當 MVC 的路由系統找不到時，就會導向 Home/Angular 的頁面，這時候 Angular 的路由機制就會接手處理，一個頁面只有一種產生方式還算是單純 但如果同一個網址，後端與前端都有符合條件的路由時，又該怎麼辦，在這情形下有分兩種處理方式 啟動 app-root 後再由此產生對應的 component 直接使用 component 啟動 app-root 後再由此產生對應的 component 例如 ~/home/about 頁面內，在前端的路由檔內也有對應的設定 123456const routes: Routes = [ &#123; path: 'dash', loadChildren: 'app/dash/dash.module#DashModule' &#125;, &#123; path: 'home/about', component: HomeComponent &#125;, &#123; path: '**', component: EmptyComponent &#125;]; 12&lt;h1&gt;About&lt;/h1&gt;&lt;app-root&gt;&lt;/app-root&gt; 這樣的設定方式，顯示結果如下 直接使用 component 直接使用 component 時，就必須將該 component 註冊到 entryComponents 內，並於 ngDoBootstrap 時判斷是否有該 element的存在，假設在 Home/Index 頁面有一個 &lt;app-menu&gt;&lt;/app-menu&gt; 的 element，那就需要將 MenuComponent 註冊到 entryComponents 的區塊內 12Index Page&lt;app-menu&gt;&lt;/app-menu&gt; App.Module.ts 檔案需要調整的內容如下 12345678910111213141516@NgModule(&#123; declarations: [AppComponent, HomeComponent, EmptyComponent], imports: [BrowserModule, RouterModule.forRoot(routes), MenuModule], entryComponents: [AppComponent, MenuComponent]&#125;)export class AppModule &#123; ngDoBootstrap(app: ApplicationRef) &#123; if (document.querySelector('app-root')) &#123; app.bootstrap(AppComponent); &#125; if (document.querySelector('app-menu')) &#123; app.bootstrap(MenuComponent); &#125; &#125;); &#125;&#125; 由於這樣子的設定方式，當需要動態顯示的 Components 一多時，就會變得很難管哩，所以稍微調整一下寫法，讓後續的新增動作簡化些 123456789101112131415161718192021222324const entryComponents = [AppComponent, MenuComponent];const routes: Routes = [ &#123; path: 'dash', loadChildren: 'app/dash/dash.module#DashModule' &#125;, &#123; path: 'home/about', component: HomeComponent &#125;, &#123; path: '**', component: EmptyComponent &#125;];@NgModule(&#123; declarations: [AppComponent, HomeComponent, EmptyComponent], imports: [BrowserModule, RouterModule.forRoot(routes), MenuModule], entryComponents: [...entryComponents]&#125;)export class AppModule &#123; constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125; ngDoBootstrap(app: ApplicationRef) &#123; entryComponents.forEach((component: any) =&gt; &#123; const factory = this.componentFactoryResolver.resolveComponentFactory(component); if (document.querySelector(factory.selector)) &#123; app.bootstrap(factory); &#125; &#125;); &#125;&#125; componentFactoryResolver : 會將 Component Type 建立成 componentFactory 以供後續使用 ApplicationRef.bootstrap 接受 componentFactory 或是 Type 的方式啟動 結語 基本上到這裡的設定算是很基本的設定方式，這樣的整合方式可以說是 MPA (Multi-Page Application) 與 SPA (Single Page Application ) 的整合，對於開發專案時的彈性是很大的，而且也可以避免一些前後端分離要留意的點，例如 API CORS 的問題 如果要顯示的頁面很簡單，可以直接使用 Razor 的方式完成，如果要處理的頁面使用者操作比較複雜，這時候使用 Angular 的方式來處理頁面動作，可以很漂亮的完成工作。 但是要留意的地方，這個架構只是眾多解決方案的其中一個，所以要仔細評估各專案的性質，選擇最適合的架構，開發起來會省很多力氣 參考資料 GitHub Repo]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 整合測試]]></title>
    <url>%2F2017%2F09%2F07%2Fangular-integration-test%2F</url>
    <content type="text"><![CDATA[整合測試主要的目的，是要測試 Component 的 template 的動作是否能如我們所預期的方式運作，而這是單元測試無法涵的範圍 Angular 也貼心準備小幫手，TestBed，來協助我們完成整合測試 TestBed TestBed 是 Angular 提供的小幫手來建立測試用的 Module 環境，基本的用法如下 1234567891011121314151617181920212223242526import &#123; async, ComponentFixture, TestBed &#125; from '@angular/core/testing';import &#123; By &#125; from '@angular/platform-browser';import &#123; DebugElement &#125; from '@angular/core';...let component: VoteComponent;let fixture: ComponentFixture&lt;VoteComponent&gt;;let de: DebugElement;let el: HTMLElement;... beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [ VoteComponent ] // declare the test component &#125;) .compileComponents(); // compile template and css &#125;));beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(VoteComponent); component = fixture.componentInstance; // 取得 component instance fixture.detectChanges(); // 執行 CD，這行會觸發 ngOnInit()，僅限第一次執行 // query for the title &lt;h1&gt; by CSS element selector de = fixture.debugElement.query(By.css('p')); // 使用標轉的 CSS Selector 尋找並取得 debugElement el = de.nativeElement; &#125;); configuratTestingModule 內的物件結構，與設定 @NgModule 是一樣的，在 beforeEach 內設定，可以確保每個測試案例不會受到其他測試案例結果的影響，當 TestingModule 設定完成後，可以透過 createComponent 的方式建立相對於 component 的 fixtureComponent，這個 fixtureComponent 將提供完整的 component 本身與對應的 template 內容 這裡有一個要留意的事情是，第一個 beforeEach 有使用 async 這個關鍵字讓包在裡面的函式變成非同步的處理方式，當 component 的 template 是單獨一個檔案時，因為有 IO 的非同步行為，所以需要 async 的幫忙讓非同步變成同步行為的處理方式，但是如果是使用 webpack 作為建置工具時，其實是不需要使用 async 的，因為 webpack 會將獨立的 html 檔案變成 inline template 的模式 fixture.detectChanges() 是手動觸發 changeDetector 的方法，任何變數異動後要更新到 template 上時，都必須執行 detectChanges()，當然，也可以設定自動偵測異動並執行更新動作，透過以下的設定即可達成 12345678import &#123; ComponentFixtureAutoDetect &#125; from '@angular/core/testing';...TestBed.configureTestingModule(&#123; ... providers: [ &#123; provide: ComponentFixtureAutoDetect, useValue: true &#125; ]&#125;) 當這樣子設定完成後，之後的測試案例內，就不需要執行 fixture.detectChages() 了，但是請注意，預設的 detechChages() 只為在非同步的事件觸發時才會被執行，例如 promise resolution、timers 或是 DOM Events，上述行為不包含直接修改變數值，因為這是屬於同步的行為，在這情況下，還是得自行執行 fixture.detectChanges() 123456789101112it('should still see original title after comp.title change', () =&gt; &#123; const oldTitle = comp.title; comp.title = 'Test Title'; // 改變 title 內容並不會觸發 template 顯示的更新，因屬於同步行為 expect(el.textContent).toContain(oldTitle);&#125;);it('should display updated title after detectChanges', () =&gt; &#123; comp.title = 'Test Title'; fixture.detectChanges(); // 需手動觸發 detectChanges，更新 template 內容 expect(el.textContent).toContain(comp.title);&#125;); 所以，手動控制 detectChanges 會比開啟自動偵測機制來的好，我們就不需要去考慮什麼時候要自己執行 detectChanges，什麼時候不用，反正多執行也不會造成問題 測試範例 property and class bindings 測試屬性 ( property ) 是一個很常見的測試情境，當一個變數值改變時，畫面上是否有正常顯示 12345678910it('should render total votes', () =&gt; &#123; component.otherVotes = 20; component.myVote = 1;// totalValue = otherVotes + myVote; fixture.detectChanges(); de = fixture.debugElement.query(By.css('.vote-count')); el = de.nativeElement; expect(el.innerText).toContain('21'); &#125;); 1&lt;span class="vote-count"&gt;&#123;&#123; totalVotes &#125;&#125;&lt;/span&gt; 寫法上要注意的還是 fixture.detectChanges()，記得要執行阿，不然測試會失敗 debugElement 本身有提供方法可以取得 classes、style、attributes、properties 等資訊，在這個測試案例，我們要測試當 myVote == 1 時，是否有 hightlight 的 css class 產生，而 debugElement.classes 是一個 keyValue 形式的物件，測試 Class 是否有正常的運作，測試案例可以這樣子寫 1&lt;button class="upVote" [class.highlight]="myVote==1" (click)="upVote()"&gt;+&lt;/button&gt; 1234567it('should hightlight the upvote button is click', () =&gt; &#123; component.myVote = 1; fixture.detectChanges(); de = fixture.debugElement.query(By.css('.upVote')); expect(de.classes['highlight']).toBeTruthy();&#125;); Event bindings 觸發事件的方法有兩種，一個是使用 debugElement 的 triggerEventHandler ，另外一種是使用 navtiveElement 轉型成 HTMLElement 後，操作 HTMLElement 的事件，這兩種方式都可以達到效果 123456// 方法1it('should click upVote and totalValue is 1', () =&gt; &#123; const button = fixture.debugElement.query(By.css('.upVote')); button.triggerEventHandler('click', null); expect(component.totalVotes).toBe(1); &#125;); 1234567// 方法2it('should click upVote and totalValue is 1', () =&gt; &#123; de = fixture.debugElement.query(By.css('.upVote')); el = de.nativeElement; el.click(); expect(component.totalVotes).toBe(1); &#125;); 到這個階段，或許會有一個問題，這個跟直接觸發 component.upVote() 後在檢查 totalVotes 的結果有什麼差別呢? 整合測試是要確保 template 上的行為是可以正常執行的，有時候函式在單元測試內是測試成功的，但是 template 上會因為沒有正常實作而造成測試失敗，這也是單元測試與整合測試的差異了。 Dependencies Providing the dependencies 一個 Component 通常都會注入其他的 service，在測試時又該怎麼處理呢? 回想看看 TestBed 的功能是什麼，是設定一個測試用的 module，既然是 module，providers 和 imports 的動作就跟平常在設定 @NgModules 的方式是一模一樣的 假設 TodosComponent 有注入 TodoService，TodoService 有注入 HttpClient 服務。 12345export class TodosComponent implements OnInit &#123; todos = []; constructor(private service: TodoService) &#123;&#125; ...&#125; 測試檔案的內容於 beforeEach 的區塊，加上 imports 與 providers 兩個區塊，並將所需要的 service 與 modules 設定進去 1234567891011...beforeEach( async(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [HttpClientModule], declarations: [TodosComponent], providers: [TodoService] &#125;).compileComponents(); &#125;) );... 當這樣子設定完成後，providing service 的部分就已經完成了 Getting the dependencies Angular 設定 provider 的地方有兩個，@NgModule 與 @Component 內都可以設定 providers，因為設定位置的不一樣，所以取得的方式也會有所不同 如果 service 是設定在 @NgModule 內時，取得 service 的方式如下 1const service = TestBed.get(TodoService); 如果 service 是設定在 @Component 內時，取得 service 的方式如下 1const service = fixture.debugElement.injector.get(TodoService); 在整合測試時，我們還是不希望依賴外部引用的 service ，這裡的處理方式會跟單元測試的方式一樣，透過 spyOn 的方式控制 service 的行為 providing stubs 有時候 component 所使用的 service 會遇到測試困難，例如路由。有時為了簡化測試的複雜度，會使用 stubs 的手法簡化，與其使用真的 service，不如自己建立一個簡單又符合目前所需的 service class 即可，也感謝 Angular 的 DI 機制，讓這一切變簡單了 123456789101112131415export class TodosComponent implements OnInit &#123; constructor(private router: Router, private route: ActivatedRoute) &#123;&#125; ngOnInit() &#123; this.route.params.subscribe(params =&gt; &#123; if (params['id'] === 0) &#123; this.router.navigate(['not-found']); &#125; &#125;); &#125; save() &#123; this.router.navigate(['/dash']); &#125;&#125; Router 本身的功能很複雜，要測試的項目又很多，所以簡化的方式就是建立一個 RouterStub class 替換真的 Router 1234567891011121314151617181920class RouterStub &#123; navigate(params) &#123;&#125;&#125;class ActivatedRouteStub &#123; params: Observable&lt;any&gt; = Observable.empty();&#125;...beforeEach( async(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [HttpClientModule], declarations: [TodosComponent], providers: [ &#123; provide: Router, useClass: RouterStub &#125;, &#123; provide: ActivatedRoute, useClass: ActivatedRouteStub &#125; ] &#125;).compileComponents(); &#125;)); 這樣子的手法就可以大大的簡化測試的難度，這手法適用於其他第三方套件情境 Route Navigation 由於在上一小節將 Router 與 ActivatedRoute 都用假的 class 替換掉了，所以這裡的測試就變簡單了 測試當某動作完成後，是否有正確的呼叫 router.navigate 函式，可以使用 toHaveBeenCalledWith 的方法來檢查 123456789it('should redirect user to dash page', () =&gt; &#123; const router = TestBed.get(Router); const spy = spyOn(router, 'navigate'); component.save(); // this.router.navigate(['dash']); // 測試傳入引數是否正確 expect(spy).toHaveBeenCalledWith(['dash']); &#125;); Parameters 測試路由參數的方式跟測試路由轉換的方式很類似，但還是要稍微修改一下 ActiveatedRouteStub 的內容，我們必須建立一個方法可以讓外部使用者將要設定路由參數傳入，修改如下 12345678910class ActivatedRouteStub &#123; private subject = new Subject(); get params() &#123; return this.subject.asObservable(); &#125; push(value) &#123; this.subject.next(value); &#125;&#125; 透過 RxJS Subject 的特性，可以很簡單的完成這個 params.subscribe 的功能，接下來就是測試在 ngOnInit 內的功能是否正常 1234567ngOnInit() &#123; this.route.params.subscribe(params =&gt; &#123; if (params['id'] === 0) &#123; this.router.navigate(['not-found']); &#125; &#125;);&#125; 當路由參數 id 是 0 時，會轉址到 not-found 的頁面 123456789it('should redirect user to NotFound page', () =&gt; &#123; const router = TestBed.get(Router); const spy = spyOn(router, 'navigate'); const route: ActivatedRouteStub = TestBed.get(ActivatedRoute); route.push(&#123; id: 0 &#125;); expect(spy).toHaveBeenCalledWith(['not-found']);&#125;); RouterOutlet components &lt;router-outlet&gt;&lt;/router-outlet&gt; 是搭配路由設定顯示 Component 的標籤，一但沒有這個就無法正常地顯示 component 內容，那要怎麼確保這個標籤不會被誤刪呢? 就是寫個測試來保護他 123456import &#123; RouterOutlet &#125; from '@angular/router';... it('should have a route-outlet tag', () =&gt; &#123; const de = fixture.debugElement.query(By.directive(RouterOutlet)); expect(de).not.toBeNull(); &#125;); 除了 &lt;router-outlet&gt; 外，也會有 routerLink 做頁面連結的入口，測試 routerLink 的方法有幾種，這裡用最簡單的方式作為範例，稍微複雜一點的是寫一個 RouterLinkStubDirective 來替換內建的 RouterLinkDirective 12345678it('should have todos link', () =&gt; &#123; const de = fixture.debugElement.queryAll(By.directive(RouterLinkWithHref)); // &lt;a routerLink="/todos"&gt;todos&lt;/a&gt; const idx = de.findIndex( element =&gt; element.properties['href'] === '/todos' ); expect(idx).toBeGreaterThan(-1);&#125;); Shallow component 當一個 Component 內有使用到其他的 component 時，因為其他的 component 並不是我們所在乎的重點，所以在 TestingModule 內的 declarations 不應該註冊其他的 component，但是，這樣子會發生錯誤，Angular 會抱怨說有些 tag element 他看不懂，這時候就需要在 TestingModule 內加上 schemas: [NO_ERRORS_SCHEMA] 來避免錯誤訊息 123456789beforeEach( async(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [RouterTestingModule], declarations: [AppComponent], schemas: [NO_ERRORS_SCHEMA] // 重點 &#125;).compileComponents(); &#125;)); Attribute directives 測試 attribute directive 時，建立一個空的 host component 用來測試 directive 12345678910111213141516171819202122232425262728293031323334353637383940@Component(&#123; selector: 'app-host-comp', template: ''&#125;)class HostComponent &#123;&#125;describe('HighlightDirective', () =&gt; &#123; let fixture: ComponentFixture&lt;HostComponent&gt;; beforeEach( async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [HostComponent, HighlightDirective] &#125;); &#125;) ); function createComponent() &#123; fixture = TestBed.createComponent(HostComponent); fixture.detectChanges(); &#125; it('should highlight with cyan', () =&gt; &#123; TestBed.overrideComponent(HostComponent, &#123; set: &#123; template: `&lt;p highlight="cyan"&gt;empty&lt;/p&gt;` &#125; &#125;); createComponent(); const de = fixture.debugElement.query(By.css('p')); expect(de.nativeElement.style.backgroundColor).toBe('cyan'); &#125;); it('should highlight with yellow', () =&gt; &#123; TestBed.overrideComponent(HostComponent, &#123; set: &#123; template: `&lt;p highlight&gt;empty&lt;/p&gt;` &#125; &#125;); createComponent(); const de = fixture.debugElement.query(By.css('p')); expect(de.nativeElement.style.backgroundColor).toBe('yellow'); &#125;);&#125;); 利用 overrideComponent 的方法來改變 TestBed 內某 component template 的設定，利用這樣子的方式就可以測試 attribute directive 了 Asynchronous operations 遇到 promise 的非同步行為時，又該怎麼測試呢? Angular 有兩種方式測試非同步行為 這個是用來做測試範例的 component 12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; QuoteService &#125; from './quote.service';@Component(&#123; selector: 'my-quote', template: '&lt;h3&gt;Random Quote&lt;/h3&gt; &lt;div&gt;&#123;&#123;quote&#125;&#125;&lt;/div&gt;'&#125;)export class QuoteComponent &#123; quote: string; constructor(private quoteService: QuoteService)&#123;&#125;; getQuote() &#123; this.quoteService.getQuote().then((quote) =&gt; &#123; this.quote = quote; &#125;); &#125;;&#125; async + whenStable 123456789101112131415161718192021222324252627282930import &#123; QuoteService &#125; from './quote.service';import &#123; QuoteComponent &#125; from './quote.component';import &#123; provide &#125; from '@angular/core';import &#123; async, TestBed, fakeAsync, tick &#125; from '@angular/core/testing';class MockQuoteService &#123; public quote: string = 'Test quote'; getQuote() &#123; return Promise.resolve(this.quote); &#125;&#125;describe('Testing Quote Component', () =&gt; &#123; let fixture; beforeEach(() =&gt; &#123; ... &#125;); it('Should get quote', async(() =&gt; &#123; fixture.componentInstance.getQuote(); fixture.detectChanges(); fixture.whenStable().then(()=&gt;&#123; const compiled = fixture.debugElement.nativeElement; expect(compiled.querySelector('div').innerText).toEqual('Test quote'); &#125;) &#125;));&#125;); fakeAsync + tick 1234567891011121314151617181920212223242526272829import &#123; QuoteService &#125; from './quote.service';import &#123; QuoteComponent &#125; from './quote.component';import &#123; provide &#125; from '@angular/core';import &#123; async, TestBed, fakeAsync, tick &#125; from '@angular/core/testing';class MockQuoteService &#123; public quote: string = 'Test quote'; getQuote() &#123; return Promise.resolve(this.quote); &#125;&#125;describe('Testing Quote Component', () =&gt; &#123; let fixture; beforeEach(() =&gt; &#123; ... &#125;); it('Should get quote', fakeAsync(() =&gt; &#123; fixture.componentInstance.getQuote(); tick(); fixture.detectChanges(); const compiled = fixture.debugElement.nativeElement; expect(compiled.querySelector('div').innerText).toEqual('Test quote'); &#125;));&#125;); fakeAsync 搭配 tick() 方法使用，我們可以控制時間的變化，將非同步的行為轉換成同步行為進行測試。 延伸測試應用，當我們有一個函式的功能是每分鐘會觸發一次動作，在測試的過程中，當然不可能等 1 分鐘後才知道測試結果，使用 tick(ms) 就可以讓時間快轉了 1234567891011describe('this test', () =&gt; &#123; it('looks async but is synchronous', &lt;any&gt;fakeAsync((): void =&gt; &#123; let flag = false; setTimeout(() =&gt; &#123; flag = true; &#125;, 100); expect(flag).toBe(false); tick(50); expect(flag).toBe(false); tick(50); expect(flag).toBe(true); &#125;));&#125;); 總結 單元測試與整合測試是互相支援的，不能只單獨測試一種，因為某些情況下，還是得依靠整合測試才能覆蓋所有的可能性，但至於哪些要寫單元測試，哪些要補整合測試，因為每個人測試的手感不同，很難有一個統一的規則在，至少我是這樣子認為的，每人有自己一套對於測試的理解方式，這就留給各位去探索了。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>測試</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] 練習曲(1) - pull to refresh]]></title>
    <url>%2F2017%2F09%2F01%2Frxjs-practice-1%2F</url>
    <content type="text"><![CDATA[跟著 Ben Lesh 在 Google 分享範例，從頭練習一次。這個範例是利用 RxJS 來實做 Pull To Refresh 的功能。 Pull To Refresh 這個效果在很多的手機 App 上面常看到，例如 FB、Twitter 等 這一個練習，就是要透過 RxJS 來實作這一個功能出來 實作步驟 1.先建立讀取使用者資料的 service 假的使用者資料 API 可以從我架設的 RandomAPI 位置取得 API 網址 : https://randomapi.azurewebsites.net/api/users 建立 UserFeedService 1234567891011121314151617181920212223import 'rxjs/add/operator/map';import 'rxjs/add/observable/empty';import 'rxjs/add/operator/catch';import &#123;HttpClient&#125; from '@angular/common/http';import &#123;Injectable&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';const api = 'https://randomapi.azurewebsites.net/api/users';@Injectable()export class UserFeedService &#123; constructor(private http: HttpClient) &#123;&#125; getUsers(): Observable&lt;any[]|&#123;&#125;&gt; &#123; return this.http.get&lt;any[]&gt;(api) .map(users =&gt; users.slice(0, 10)) .catch(err =&gt; &#123; console.log('an error occured', err); return Observable.empty(); &#125;); &#125;&#125; 這裡我們使用 HttpClient ，記得在 AppModule 載入 HttpClientModule 2.建立新的 Component 用來顯示使用者資料 建立 LatestUsersComponent，並將 component 加到 app.component.html 裡 12345678910111213141516171819202122import &#123;Component, OnInit&#125; from '@angular/core';import &#123;UserFeedService&#125; from '../user-feed.service';@Component(&#123; selector: 'app-latest-users', template: ` &lt;h3&gt;Latest Users&lt;/h3&gt; &lt;div&gt; &lt;article *ngFor="let user of (users$ | async)"&gt; &lt;h4&gt;&#123;&#123; user.first &#125;&#125; &#123;&#123; user.last &#125;&#125;&lt;/h4&gt; &lt;p&gt;Joined: &#123;&#123; user.created | date: 'yyyy/MM/dd' &#125;&#125;&lt;/p&gt; &lt;p&gt;Balance: &#123;&#123; user.balance | currency: 'USD': true &#125;&#125;&lt;/p&gt; &lt;p&gt;Contact: &#123;&#123; user.address &#125;&#125;, &#123;&#123; user.email &#125;&#125;&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; `, styles: []&#125;)export class LatestUsersComponent &#123; users$ = this.userFeedService.getUsers(); constructor(private userFeedService: UserFeedService) &#123;&#125;&#125; 3.定時重新讀取使用者資料 希望每 10 秒鐘，重新撈一次資料 在 LatestUsersComponent 裡面在多一個 Observable 用來觸發 getUsers() 1234567...export class LatestUsersComponent &#123; updateUsersTrigger$ = Observable.timer(0, 10000); users$ = this.updateUsersTrigger$ .switchMap(() =&gt; this.userFeedService.getUsers()); ...&#125; 這樣的改寫，當註冊當下 ( async piple ) 會先呼叫一次 getUsers()，在之後每 10 秒會觸發 getUsers() 4.建立 LoadNotifyService 接下來要準備實作 pull to refresh 的功能，我們需要兩個通知器，一個負責請求讀取資料，另一個是**回傳資料讀取完成 **，這個通知器可以使用 Subject 來實作即可 建立 LoadNotifyService 12345678import &#123;Injectable&#125; from '@angular/core';import &#123;Subject&#125; from 'rxjs/Subject';@Injectable()export class LoadNotifyService &#123; requestLoad$ = new Subject&lt;any&gt;(); loadComplete$ = new Subject&lt;any&gt;();&#125; 5. 將通知功能加入到 LatestUsersComponent updateUsersTrigger$ 現在除了每 10 秒會發出一次資料，當有人請求更新資料時，也會發出一筆資料。當 getUsers() 完成讀取資料時，會發出 loadComplete$ 的通知 1234567891011export class LatestUsersComponent &#123; updateUsersTrigger$ = Observable.timer(0, 10000).merge(this.loadNotifyService.requestLoad$); users$ = this.updateUsersTrigger$.switchMap(() =&gt; this.userFeedService.getUsers()) .do(this.loadNotifyService.loadComplete$); constructor( private userFeedService: UserFeedService, private loadNotifyService: LoadNotifyService) &#123;&#125;&#125; 6.建立新的 Component 來負責 pull to refresh 的功能 建立 PullToRefreshComponent 並加到 LatestUsersComponent 裡 12345678910111213141516171819import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-pull-to-refresh', template: ` &lt;div style="position: absolute; top: 0; left: 50%"&gt; &lt;div style="margin-left: -35px"&gt; &lt;svg width="70px" height="70"&gt; &lt;circle cy="35" cx="35" r="35" fill="lightgrey"&gt;&lt;/circle&gt; &lt;circle cy="15" cx="35" r="10" fill="black"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/div&gt; `, styles: []&#125;)export class PullToRefreshComponent &#123; constructor() &#123;&#125;&#125; 7.實作往 Pull To Refresh 動作 先來分析一下要實作功能會有哪些動作 touchstart tocuhmove 計算移動的距離，決定是否出發撈資料的請求 如果符合條件，則發出請求 touchend 如果有發出撈資料的請求時，等待完成讀取資料動作，並恢復初始狀態 如果沒有發出撈資料的請求，恢復初始狀態 步驟1，需要先將 touchstart、touchmove 和 touchend 事件轉換成 Observable 123touchstart$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchstart');touchend$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchend');touchmove$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchmove'); 步驟2，計算開始後手指滑動的距離 1234567drag$ = this.touchstart$.switchMap(start =&gt; &#123; let pos = 0; return this.touchmove$ .map(move =&gt; move.touches[0].pageY - start.touches[0].pageY) .do(p =&gt; pos = p) .takeUntil(this.touchend$); &#125;); 步驟3，判斷是否要發出通知，如果已經發出請求通知，停止 Observable 123456789101112131415drag$ = this.touchstart$ .switchMap(start =&gt; &#123; let pos = 0 return this.touchmove$ .map(move =&gt; move.touches[0].pageY - start.touches[0].pageY) .do(p =&gt; pos = p) .takeUntil(this.touchend$) .concat(Observable.defer(() =&gt; this.tweenObservable(pos, 0, 200))) &#125;) .do(p =&gt; &#123; if (p &gt;= window.innerHeight / 2) &#123; this.loadNotification.requestLoad$.next() &#125; &#125;) .takeWhile(p =&gt; p &lt; window.innerHeight / 2) 步驟4，當上述動作完成時，Observable 本身會停止，可透過 repeat() 重新啟動 123456789101112131415drag$ = this.touchstart$ .switchMap(start =&gt; &#123; let pos = 0; return this.touchmove$ .map(move =&gt; move.touches[0].pageY - start.touches[0].pageY) .do(p =&gt; pos = p) .takeUntil(this.touchend$); &#125;) .do(p =&gt; &#123; if (p &gt;= window.innerHeight / 2) &#123; this.loadNotification.requestLoad$.next(); &#125; &#125;) .takeWhile(p =&gt; p &lt; window.innerHeight / 2) .repeat(); 步驟5，記錄目前所在位置，加上動畫功能，將該 Observable 綁定到 template 上 1234567currentPos = 0;position$: Observable&lt;number&gt; = this.drag$ .merge(this.completeAnimation$) .startWith(0) .do(pos =&gt; this.currentPos = pos)positionTranslate3d$: Observable&lt;string&gt; = this.position$.map(p =&gt; `translate3d(0, $&#123;p - 70&#125;px, 0)`) 12345678&lt;div style="position: absolute; top: 0; left: 50%"&gt; &lt;div style="margin-left: -35px" [style.transform]="positionTranslate3d$ | async"&gt; &lt;svg width="70px" height="70"&gt; &lt;circle cy="35" cx="35" r="35" fill="lightgrey"&gt;&lt;/circle&gt; &lt;circle cy="15" cx="35" r="10" fill="black"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/div&gt; 到這個步驟時，畫面已經可以往下拉的效果，而且也可以送出重新讀取資料的請求了 步驟6: 當放掉或當資料讀取完成後，要恢復至初始狀態 先處理資料讀取完成後，恢復至初始狀態 12345678910111213141516171819completeAnimation$ = this.loadNotification.loadComplete$ .map(() =&gt; this.currentPos) .switchMap(currentPos =&gt; this.tweenObservable(currentPos, 0 , 200));...position$: Observable&lt;number&gt; = this.drag$ .merge(this.completeAnimation$) .startWith(0) .do(pos =&gt; this.currentPos = pos);private tweenObservable(start, end, time) &#123; const emissions = time / 10; const step = (start - end) / emissions; return Observable.timer(0, 10) .map(x =&gt; start - step * (x + 1)) .take(emissions);&#125; 在來處理未觸發資料讀取請求時，當手指頭離開畫面時，也需要恢復初始狀態 12345678910111213141516drag$ = this.touchstart$ .switchMap(start =&gt; &#123; let pos = 0 return this.touchmove$ .map(move =&gt; move.touches[0].pageY - start.touches[0].pageY) .do(p =&gt; pos = p) .takeUntil(this.touchend$) .concat(Observable.defer(() =&gt; this.tweenObservable(pos, 0, 200))) // 恢復初始狀態 &#125;) .do(p =&gt; &#123; if (p &gt;= window.innerHeight / 2) &#123; this.loadNotification.requestLoad$.next() &#125; &#125;) .takeWhile(p =&gt; p &lt; window.innerHeight / 2) .repeat() 8.實作轉圈圈的動作 其實到階段 7 時，Pull To Refresh 的功能已經完成了，在多一點讀取時的 loading 效果，讓圈圈旋轉吧 1234567891011121314// Start rotating when a request is made and spin until it completesrotate$: Observable&lt;number&gt; = this.loadNotification.requestLoad$.switchMap(() =&gt; &#123; let rot = 0; return this.tweenObservable(0, 360, 500) .repeat() .do(r =&gt; rot = r) .takeUntil(this.loadNotification.loadComplete$) .concat(Observable.defer( () =&gt; this.tweenObservable(rot, 360, 360 - rot))); &#125;);rotateTransform$: Observable&lt;string&gt; = this.rotate$.map(r =&gt; `rotate($&#123;r&#125;deg)`); 12345678&lt;div style="position: absolute; top: 0; left: 50%"&gt; &lt;div style="margin-left: -35px" [style.transform]="positionTranslate3d$ | async"&gt; &lt;svg width="70px" height="70" [style.transform]="rotateTransform$ | async"&gt; &lt;circle cy="35" cx="35" r="35" fill="lightgrey"&gt;&lt;/circle&gt; &lt;circle cy="15" cx="35" r="10" fill="black"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/div&gt; 完整程式碼 pull-to-refresh.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import 'rxjs/add/observable/fromEvent';import 'rxjs/add/observable/defer';import 'rxjs/add/operator/takeUntil';import 'rxjs/add/operator/takeWhile';import 'rxjs/add/operator/repeat';import 'rxjs/add/operator/startWith';import 'rxjs/add/operator/take';import 'rxjs/add/operator/concat';import &#123;Component&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';import &#123;LoadNotifyService&#125; from '../load-notify.service';@Component(&#123; selector: 'app-pull-to-refresh', template: ` &lt;div style="position: absolute; top: 0; left: 50%"&gt; &lt;div style="margin-left: -35px" [style.transform]="positionTranslate3d$ | async"&gt; &lt;svg width="70px" height="70" [style.transform]="rotateTransform$ | async"&gt; &lt;circle cy="35" cx="35" r="35" fill="lightgrey"&gt;&lt;/circle&gt; &lt;circle cy="15" cx="35" r="10" fill="black"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/div&gt; `, styles: []&#125;)export class PullToRefreshComponent &#123; currentPos = 0; touchstart$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchstart'); touchend$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchend'); touchmove$ = Observable.fromEvent&lt;TouchEvent&gt;(document, 'touchmove'); completeAnimation$ = this.loadNotification.loadComplete$.map(() =&gt; this.currentPos) .switchMap(currentPos =&gt; this.tweenObservable(currentPos, 0, 200)) drag$ = this.touchstart$ .switchMap(start =&gt; &#123; let pos = 0; return this.touchmove$ .map(move =&gt; move.touches[0].pageY - start.touches[0].pageY) .do(p =&gt; pos = p) .takeUntil(this.touchend$) .concat(Observable.defer( () =&gt; this.tweenObservable(pos, 0, 200))); &#125;) .do(p =&gt; &#123; if (p &gt;= window.innerHeight / 2) &#123; this.loadNotification.requestLoad$.next(); &#125; &#125;) .takeWhile(p =&gt; p &lt; window.innerHeight / 2) .repeat(); position$: Observable&lt;number&gt; = this.drag$.merge(this.completeAnimation$) .startWith(0) .do(pos =&gt; this.currentPos = pos); positionTranslate3d$: Observable&lt;string&gt; = this.position$.map(p =&gt; `translate3d(0, $&#123;p - 70&#125;px, 0)`); // 開始轉圈圈直到資料讀取完成 rotate$: Observable&lt;number&gt; = this.loadNotification.requestLoad$.switchMap(() =&gt; &#123; let rot = 0; return this.tweenObservable(0, 360, 500) .repeat() .do(r =&gt; rot = r) .takeUntil(this.loadNotification.loadComplete$) .concat(Observable.defer( () =&gt; this.tweenObservable(rot, 360, 360 - rot))); &#125;); rotateTransform$: Observable&lt;string&gt; = this.rotate$.map(r =&gt; `rotate($&#123;r&#125;deg)`); constructor(private loadNotification: LoadNotifyService) &#123;&#125; private tweenObservable(start, end, time) &#123; const emissions = time / 10; const step = (start - end) / emissions; return Observable.timer(0, 10) .map(x =&gt; start - step * (x + 1)) .take(emissions); &#125;&#125; latest-users.component.ts 1234567891011121314151617181920212223242526272829303132333435363738import 'rxjs/add/observable/timer';import 'rxjs/add/operator/switchMap';import 'rxjs/add/operator/merge';import 'rxjs/add/operator/do';import &#123;Component, OnInit&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';import &#123;LoadNotifyService&#125; from '../load-notify.service';import &#123;UserFeedService&#125; from '../user-feed.service';@Component(&#123; selector: 'app-latest-users', template: ` &lt;app-pull-to-refresh&gt;&lt;/app-pull-to-refresh&gt; &lt;h3&gt;Latest Users&lt;/h3&gt; &lt;div&gt; &lt;article *ngFor="let user of (users$ | async)"&gt; &lt;h4&gt;&#123;&#123; user.first &#125;&#125; &#123;&#123; user.last &#125;&#125;&lt;/h4&gt; &lt;p&gt;Joined: &#123;&#123; user.created | date: 'yyyy/MM/dd' &#125;&#125;&lt;/p&gt; &lt;p&gt;Balance: &#123;&#123; user.balance | currency: 'USD': true &#125;&#125;&lt;/p&gt; &lt;p&gt;Contact: &#123;&#123; user.address &#125;&#125;, &#123;&#123; user.email &#125;&#125;&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; `, styles: []&#125;)export class LatestUsersComponent &#123; updateUsersTrigger$ = Observable.timer(0, 10000).merge(this.loadNotifyService.requestLoad$); users$ = this.updateUsersTrigger$.switchMap(() =&gt; this.userFeedService.getUsers()) .do(this.loadNotifyService.loadComplete$); constructor( private userFeedService: UserFeedService, private loadNotifyService: LoadNotifyService) &#123;&#125;&#125; user-feed.service.ts 1234567891011121314151617181920212223import 'rxjs/add/operator/map';import 'rxjs/add/observable/empty';import 'rxjs/add/operator/catch';import &#123;HttpClient&#125; from '@angular/common/http';import &#123;Injectable&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';const api = 'https://randomapi.azurewebsites.net/api/users';@Injectable()export class UserFeedService &#123; constructor(private http: HttpClient) &#123;&#125; getUsers(): Observable&lt;any[]|&#123;&#125;&gt; &#123; return this.http.get&lt;any[]&gt;(api) .map(users =&gt; users.slice(0, 10)) .catch(err =&gt; &#123; console.log('an error occured', err); return Observable.empty(); &#125;); &#125;&#125; load-notify.service.ts 12345678import &#123;Injectable&#125; from '@angular/core';import &#123;Subject&#125; from 'rxjs/Subject';@Injectable()export class LoadNotifyService &#123; requestLoad$ = new Subject&lt;any&gt;(); loadComplete$ = new Subject&lt;any&gt;();&#125; app.component.html 12&lt;h1&gt;Super Cool App&lt;/h1&gt;&lt;app-latest-users&gt;&lt;/app-latest-users&gt; 參考資料 stackblitz demo GitHub Repo]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS]Observable 的 subscribe 與 forEach]]></title>
    <url>%2F2017%2F08%2F26%2Frxjs-observable-foreach%2F</url>
    <content type="text"><![CDATA[RxJS 的 Observable 除了我們所熟悉的 subscribe，其實還可以透過 forEach 的方式取得 Observable 的資料。 subscribe Observable.subscribe 所需要傳入的引數可以是一個 observer物件，或是至少有一個負責 next 階段的函式。 1Observable.from([1,2,3]).subscribe(value=&gt; console.log(value)); 而 subscribe 會回傳一個 subscription 的物件，可以讓我們取消 Observable。 forEach 仔細看 Observable 的原始碼，其實還有另外一個函式可以達到跟 subscribe 一樣的結果，forEach 只接受一個函式，這個函式只負責處理 next 階段的行為，且回傳的是一個 Promise，而不是 subscription。forEach 的原始碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041forEach(next: (value: T) =&gt; void, PromiseCtor?: typeof Promise): Promise&lt;void&gt; &#123; if (!PromiseCtor) &#123; if (root.Rx &amp;&amp; root.Rx.config &amp;&amp; root.Rx.config.Promise) &#123; PromiseCtor = root.Rx.config.Promise; &#125; else if (root.Promise) &#123; PromiseCtor = root.Promise; &#125; &#125; if (!PromiseCtor) &#123; throw new Error('no Promise impl found'); &#125; return new PromiseCtor&lt;void&gt;((resolve, reject) =&gt; &#123; // Must be declared in a separate statement to avoid a RefernceError when // accessing subscription below in the closure due to Temporal Dead Zone. let subscription: Subscription; subscription = this.subscribe((value) =&gt; &#123; if (subscription) &#123; // if there is a subscription, then we can surmise // the next handling is asynchronous. Any errors thrown // need to be rejected explicitly and unsubscribe must be // called manually try &#123; next(value); &#125; catch (err) &#123; reject(err); subscription.unsubscribe(); &#125; &#125; else &#123; // if there is NO subscription, then we're getting a nexted // value synchronously during subscription. We can just call it. // If it errors, Observable's `subscribe` will ensure the // unsubscription logic is called, then synchronously rethrow the error. // After that, Promise will trap the error and send it // down the rejection path. next(value); &#125; &#125;, reject, resolve); &#125;); &#125; 使用方法如下 123456Observable.from([1,2,3]).forEach(value=&gt; console.log(value)) .then(()=&gt; &#123; // complete;&#125;).catch((err) =&gt; &#123; // error&#125;) 為什麼 RxJS 要有一個函式會回傳 Promise？當這個函式搭配 await / async ，會有一些不可思議的火花。 範例 沒有使用 async / await 時 12345678910111213import 'rxjs/Rx';import &#123;Observable&#125; from 'rxjs/Observable';function getData() &#123; return Observable.from([1, 2, 3]).delay(1000);&#125;async function execute() &#123; getData().forEach(v =&gt; console.log(v)); console.log('finish');&#125;execute(); 執行結果 使用 async / await 時 12345678910111213import 'rxjs/Rx';import &#123;Observable&#125; from 'rxjs/Observable';function getData() &#123; return Observable.from([1, 2, 3]).delay(1000);&#125;async function execute() &#123; await getData().forEach(v =&gt; console.log(v)); console.log('finish');&#125;execute(); 執行結果 回顧 一起想想看，這樣子的特性，在開發 Angular 的時候，是否有使用的情境呢? 是否有使用 async / await 而讓程式碼的可閱讀性提高呢?]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 自訂雙向繫結 - 簡易版]]></title>
    <url>%2F2017%2F08%2F15%2Fangular-custom-two-way-binding%2F</url>
    <content type="text"><![CDATA[在上一篇介紹 Two-way Binding 的文章裡，有提到 [()] 的運作原理，我們也可以利用這原理，來寫自己的雙向繫結屬性，使用的場景會是 Component 自訂雙向繫結的功能 - 陽春版 重新複習一下，Angular 的編譯器，會將 [()] 轉換成 [name]=&quot;expression&quot; 跟 (nameChange)=&quot;expression = $event&quot; 的型態，所以在 Component 需要設定 @Input('name') 與 @Output('nameChange') 這兩個項目 1234567891011121314151617181920212223242526272829@Component(&#123; selector: 'custom-counter', template: ` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123;counter&#125;&#125;&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `&#125;)export class CustomCounterComponent &#123; counterValue = 0; @Input() get counter() &#123; return this.counterValue; &#125; set counter(value) &#123; this.counterValue = value; &#125; decrement() &#123; this.counter--; &#125; increment() &#123; this.counter++' &#125;&#125; 在外部使用這個 Component 時 1&lt;custom-counter [counter]="someValue"&gt;&lt;/custom-counter&gt; 這時如果讓這個 counter 也有雙向繫結的效果時，custom-counter Component 的程式碼要稍微改一下 12345678910111213141516171819202122232425262728293031@Component(&#123; selector: 'custom-counter', template: ` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123;counter&#125;&#125;&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `&#125;)export class CustomCounterComponent &#123; counterValue = 0; @Output() counterChange = new EventEmitter&lt;number&gt;(); @Input() get counter() &#123; return this.counterValue; &#125; set counter(value) &#123; this.counterValue = value; this.counterChange.emit(this.counterValue); &#125; decrement() &#123; this.counter--; &#125; increment() &#123; this.counter++' &#125;&#125; 這樣子修正完後，counter 這個對外的屬性，就可以使用 [()] 來做到雙向繫結的效果 12&lt;custom-counter [(counter)]="someValue"&gt;&lt;/custom-counter&gt;&lt;p&gt;counterValue = &#123;&#123; someValue &#125;&#125;&lt;/p&gt; 範例程式]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Two-way Binding 的運作方式]]></title>
    <url>%2F2017%2F08%2F14%2Fangular-two-way-binding%2F</url>
    <content type="text"><![CDATA[Angular 的雙向繫結與 AngularJS 的雙向繫結運作原理是完全不同的，目前看起來是沒有 AngularJS 會遇到效能問題。那 Angular 的雙向繫結到底是怎麼運作的呢? 如何使用 雙向繫結 (Two-way Binding) 以下的三種寫法都可以達到雙向繫結的效果 方法1 使用 [()] 的寫法 123&lt;input [(ngModel)]="username"&gt;&lt;p&gt;Hello &#123;&#123;username&#125;&#125;!&lt;/p&gt; 方法2 將 [] () 分開寫 123&lt;input [ngModel]="username" (ngModelChange)="username = $event"&gt;&lt;p&gt;Hello &#123;&#123;username&#125;&#125;!&lt;/p&gt; 方法3 不使用 ngModel 123&lt;input [value]="username" (input)="username = $event.target.value"&gt;&lt;p&gt;Hello &#123;&#123;username&#125;&#125;!&lt;/p&gt; [()] 的秘密 我們知道 [()] 是 Angular 所提供給雙向繫結的語法糖，但是底層到底是怎麼運作的，為什麼會可以轉換成 [&lt;name&gt;] +(&lt;name&gt;Change) 呢? 以下簡單說明 compiler/src/template_parser/template_parser.ts 裡面會去分析 Element 的 attribute 是否有符合各種格式的內容 123456789101112131415161718192021222324// 重點在此const BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;// Group 1 = "bind-"const KW_BIND_IDX = 1;// Group 2 = "let-"const KW_LET_IDX = 2;// Group 3 = "ref-/#"const KW_REF_IDX = 3;// Group 4 = "on-"const KW_ON_IDX = 4;// Group 5 = "bindon-"const KW_BINDON_IDX = 5;// Group 6 = "@"const KW_AT_IDX = 6;// Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"const IDENT_KW_IDX = 7;// Group 8 = identifier inside [()]const IDENT_BANANA_BOX_IDX = 8;// Group 9 = identifier inside []const IDENT_PROPERTY_IDX = 9;// Group 10 = identifier inside ()const IDENT_EVENT_IDX = 10; 12345678910111213141516171819202122232425private _parseAttr( isTemplateElement: boolean, attr: html.Attribute, targetMatchableAttrs: string[][], targetProps: BoundProperty[], targetEvents: BoundEventAst[], targetRefs: ElementOrDirectiveRef[], targetVars: VariableAst[]): boolean &#123; const name = this._normalizeAttributeName(attr.name); const value = attr.value; const srcSpan = attr.sourceSpan; const bindParts = name.match(BIND_NAME_REGEXP); let hasBinding = false; if (bindParts !== null) &#123; hasBinding = true; ... &#125; else if (bindParts[IDENT_BANANA_BOX_IDX]) &#123; this._bindingParser.parsePropertyBinding( bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps); this._parseAssignmentEvent( bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents); &#125; ... return hasBinding; &#125; 根據 _parseAssigmentEvent 就會將部分[(ngModel)]=&quot;username&quot; 轉換成 (ngModelChange)=&quot;username = $event&quot; 傳入 bindingParser.parseEvent 的方法內 123456private _parseAssignmentEvent( name: string, expression: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) &#123; this._bindingParser.parseEvent( `$&#123;name&#125;Change`, `$&#123;expression&#125;=$event`, sourceSpan, targetMatchableAttrs, targetEvents);&#125; this._bindingParse.parseEvent，會更新 Element 的屬性值 1234567891011private _parseEvent( name: string, expression: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) &#123; // long format: 'target: eventName' const [target, eventName] = splitAtColon(name, [null !, name]); const ast = this._parseAction(expression, sourceSpan); targetMatchableAttrs.push([name !, ast.source !]); targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan)); // Don't detect directives for event names for now, // so don't add the event name to the matchableAttrs&#125; 這就是 [()] 語法糖的運作方式 ​ ​ ngModel ngModel 是 Angular 所提供的 Directive，主要用途是用來簡化雙向繫結的寫法，程式碼可以參閱這裡 程式碼說明 ngOnChanges 第一次 Input Change 時，註冊 Control 等相關事件，註冊流程如下 檢查是否有註冊過，如果沒有，執行 _setUpControl 的方法，setUpControl是在 ./shared.ts 內實作的，主要功能是 Control 的事件註冊。 123456789101112131415161718192021222324252627ngOnChanges(changes: SimpleChanges) &#123; this._checkForErrors(); if (!this._registered) this._setUpControl(); if ('isDisabled' in changes) &#123; this._updateDisabled(changes); &#125; if (isPropertyUpdated(changes, this.viewModel)) &#123; this._updateValue(this.model); this.viewModel = this.model; &#125;&#125;...private _setUpControl(): void &#123; this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this); this._registered = true;&#125;private _isStandalone(): boolean &#123; return !this._parent || !!(this.options &amp;&amp; this.options.standalone);&#125;private _setUpStandalone(): void &#123; setUpControl(this._control, this); this._control.updateValueAndValidity(&#123;emitEvent: false&#125;);&#125; setUpControl 內有許多事件註冊行為，而跟 two-way binding 有關的事件是 dir.valueAccessor!.registerOnChange，這裡會傳入一個 callback function 123456789101112131415161718192021export function setUpControl(control: FormControl, dir: NgControl): void &#123; ... setUpViewChangePipeline(control, dir); ...&#125; function setUpViewChangePipeline(control: FormControl, dir: NgControl): void &#123; dir.valueAccessor !.registerOnChange((newValue: any) =&gt; &#123; control._pendingValue = newValue; control._pendingDirty = true; if (control.updateOn === 'change') updateControl(control, dir); // 觸發更新 &#125;);&#125; function updateControl(control: FormControl, dir: NgControl): void &#123; dir.viewToModelUpdate(control._pendingValue); if (control._pendingDirty) control.markAsDirty(); control.setValue(control._pendingValue, &#123;emitModelToViewChange: false&#125;);&#125; 而當 Input 欄位有資料輸入時，就會觸發事件並將回傳值發送到到頁面上 ng_model.ts 1234viewToModelUpdate(newValue: any): void &#123; this.viewModel = newValue; this.update.emit(newValue);&#125; NG_VALUE_ACCESSOR 這個 provider 是讓 ngModleChange 接受 $event 而不是 $event.target.value 的魔法使，內部細節如下 在各類型的 Control 都會有一份 NG_VALUE_ACCESSOR ，而針對 ngModel 我們需留意的是 DEFAULT_VALUE_ACCESSOR ，檔案是 default_value_accessor.ts (使用 multi 的 DI 設定方式並不是這篇文章的重點，只要知道這樣子設定，可以讓 Provider 使用同一個名稱但又可同時存在不互相影響) 12345export const DEFAULT_VALUE_ACCESSOR: any = &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; DefaultValueAccessor), multi: true&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Directive(&#123; selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]', host: &#123; '(input)': '_handleInput($event.target.value)', '(blur)': 'onTouched()', '(compositionstart)': '_compositionStart()', '(compositionend)': '_compositionEnd($event.target.value)' &#125;, providers: [DEFAULT_VALUE_ACCESSOR]&#125;)export class DefaultValueAccessor implements ControlValueAccessor &#123; onChange = (_: any) =&gt; &#123;&#125;; onTouched = () =&gt; &#123;&#125;; /** Whether the user is creating a composition string (IME events). */ private _composing = false; constructor( private _renderer: Renderer, private _elementRef: ElementRef, @Optional() @Inject(COMPOSITION_BUFFER_MODE) private _compositionMode: boolean) &#123; if (this._compositionMode == null) &#123; this._compositionMode = !_isAndroid(); &#125; &#125; writeValue(value: any): void &#123; const normalizedValue = value == null ? '' : value; this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue); &#125; registerOnChange(fn: (_: any) =&gt; void): void &#123; this.onChange = fn; &#125; registerOnTouched(fn: () =&gt; void): void &#123; this.onTouched = fn; &#125; ... _handleInput(value: any): void &#123; if (!this._compositionMode || (this._compositionMode &amp;&amp; !this._composing)) &#123; this.onChange(value); &#125; &#125; ...&#125; DefaultValueAccessor 裡 registerOnChange 與 onChange 的關係是，ngModel 會經 setUpControl 的方法將自訂方法透過 registerOnChange 註冊到 onChange 上， DefaultValueAccessor 的 @Directive 的宣告的地方，有註冊 (input) 事件發生時會觸發的方法， _handleInput($event.target.value) 12345_handleInput(value: any): void &#123; if (!this._compositionMode || (this._compositionMode &amp;&amp; !this._composing)) &#123; this.onChange(value); &#125;&#125; 經過這一串的折騰，魔法就出現了，ngModle 的 @Output('ngModelChange') 會收到並發送資料到頁面上，這也就是為什麼 (ngModelChange) 的 $event 不需要加上 target.value，又可以取得異動的資料 Recap 以下是雙向繫結相關的流程順序 [ngModel]時會觸發 ngOnChanges 事件 在 ngOnChanges 時，會執行 setUpControl() 方法 在 setupControl() 內會註冊 DefaultValueAccess 執行 registerOnChange，並將 callback function 傳入 透過 registerOnChanges 傳入的 callback function 會被綁定到 onChanges 上 當 (input) 事件被觸發時，會執行 _handleInput($event.target.value) 的方法 將傳入 _handleInput(value) 的值傳給註冊在 onChange 的 callback function callback function 會執行 ngModel 裡的 viewToModelUpdate(newValue) 方法 最後將 viewToModelUpdate 所接受到的值，透過 ngModelChange 的 EventEmiiter emit 值到頁面上 完成整個雙向繫結的動作]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ChangeDetector 之 markForCheck 篇]]></title>
    <url>%2F2017%2F08%2F09%2Fangular-changedetector-markforcheck%2F</url>
    <content type="text"><![CDATA[Angular 的 Change Detection 機制，問題： 在使用 onPush 策略時，一定都要重新傳新物件才能出發更新嗎? 答案：不用 ChangeDetecotrRef 提供了一些方法，允許我們手動觸發檢查更新機制，而 markForCheck 是其中一個 markForCheck markForCheck 的用途，當呼叫這個方法時，就是告訴 ChangeDetector ，請檢查我本身及我上頭的 Component。更新的方向性是往 Root 向上移動 markForCheck的程式碼 1234567let currView: ViewData|null = view;while (currView) &#123; if (currView.def.flags &amp; ViewFlags.OnPush) &#123; currView.state |= ViewState.ChecksEnabled; &#125; currView = currView.viewContainerParent || currView.parent;&#125; 以下提供幾個可能使用情境 使用情境 setTimeout、setInterval 可以從我之前寫的文章溫習一下什麼是 ChangeDetectionStrategy.OnPush 當 Component 的 changeDetection 設定為 ChangeDetectionStrategy.OnPush，如果有使用 setTimeout 時，就必須配合 markForCheck() 的方法來更新 View 的顯示。 12345678910111213141516171819import &#123;ChangeDetectionStrategy, ChangeDetectorRef, Component, OnInit&#125; from '@angular/core';@Component(&#123; selector: 'my-app', templateUrl: './app.component.html', styleUrls: [ './app.component.css' ], changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class AppComponent &#123; vcard = [&#123;name: 'Kevin'&#125;]; constructor(public cd: ChangeDetectorRef) &#123;&#125; ngOnInit() &#123; setTimeout(() =&gt; &#123; this.vcard.push(&#123;name: 'Jeff'&#125;); // this.cd.markForCheck(); // you can comment/uncomment this line to see the difference &#125;, 2000); &#125; &#125; 這裡有簡單的程式碼 可以實際執行看看，取消註解後看看執行的結果。 Input as DataStream 當 @Input 的資料型態為 Observable 再加上 onPush 時，也會有 setTimeout、setInterval 的情況出現，所以這時候也必須依賴 markForCheck 來執行顯示更新 123456789101112131415161718192021import &#123;ChangeDetectionStrategy, ChangeDetectorRef, Component, Input, OnInit&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';@Component(&#123; selector: 'app-v-card', templateUrl: './v-card.component.html', styleUrls: ['./v-card.component.css'], changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class VCardComponent implements OnInit &#123; @Input() data: Observable&lt;any&gt;; info: any; constructor(private cd: ChangeDetectorRef) &#123;&#125; ngOnInit() &#123; this.data.subscribe(data =&gt; &#123; this.info = data; // this.cd.markForCheck(); &#125;); &#125;&#125; 這裡有簡單的程式碼 可實際執行看看，取消註解後看看執行的結果。 參考資料 API - ChangeDetectorRef]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular Server-Side Rendering with Angular CLI 1.3.x 基本設定]]></title>
    <url>%2F2017%2F08%2F08%2Fangular-cli-universal%2F</url>
    <content type="text"><![CDATA[Angular CLI 1.3.0 和 Angular 4.3 版本之前，要使用 SSR (Server Side Rendering) 其實還蠻複雜的，並不是無法做到，只是很麻煩。可是，當版本升級到 Angular 4.3 及 CLI 1.3.0 以後，這一切都變得非常簡單。這裡先說明如何快速地將 SSR 的環境建置起來 前置作業 先將 CLI 的版本升級到 1.3.0。可以從這看到目前的釋出版本 CLI Release (2017/08/08 時，CLI版本是 1.3.0-rc.5) npm install @angular/cli@1.3.0-rc.5 安裝 @angular/platform-server npm install @angular/platform-server 設定步驟 .angular-cli.json 多新增一個 app 設定 12345678910111213&#123; "name": "universal", "platform": "server", "root": "src", "outDir": "dist-server", "main": "main-server.ts", "tsconfig": "tsconfig.server.json", "environmentSource": "environments/environment.ts", "environments": &#123; "dev": "environments/environment.ts", "prod": "environments/environment.prod.ts" &#125;&#125; 刪除 polyfiils，伺服器不需要這個 移除 assets、styles、scripts ，這部分已經在 browser 版本中處理過了。 main-server.ts 在 scr 資料夾下新增 main-server.ts 檔案 1234import &#123;enableProdMode&#125; from '@angular/core';export &#123;AppServerModule&#125; from './app/app-server.module';enableProdMode(); app-server.module 在 src/app 資料夾下，新增 `app-server.module.ts’ 檔案 123456789import &#123;NgModule&#125; from '@angular/core';import &#123;ServerModule&#125; from '@angular/platform-server';import &#123;AppComponent&#125; from './app.component';import &#123;AppModule&#125; from './app.module';@NgModule(&#123;imports: [AppModule, ServerModule], bootstrap: [AppComponent]&#125;)export class AppServerModule &#123;&#125; app.module 修改 app.module.ts 檔案，給予 withServerTransition 的設定值，appId 可以任取。 123456...imports: [ BrowserModule.withServerTransition(&#123;appId: 'universal'&#125;), ...],... tsconfig.server.json 在 src 資料夾下，新增 tsconfig.server.json 12345678910111213141516&#123; "extends": "./tsconfig.app.json", "compilerOptions": &#123; "outDir": "../out-tsc/server", /* For now, Node only understand CommonJS modules, so you can't stick to es2015 here */ "module": "commonjs" &#125;, "exclude": [ "test.ts", "**/*.spec.ts" ], /* Additional informations to bootstrap Angular */ "angularCompilerOptions": &#123; "entryModule": "app/app-server.module#AppServerModule" &#125;&#125; package.json 修改 scripts 指令 「build」: 「ng build --prod &amp;&amp; ng build --prod --app universal --output-hashing=none」 這樣子當執行 npm run build 時，就會分別建置瀏覽器端及伺服器端所需要的程式了 設定 node express server 在專案跟目錄下新增 server.js 檔案，這檔案的功能是執行一個 node express 網站伺服器 套件安裝 npm install express @nguniversal/express-engine server.js 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';/* Server specific version of Zone.js */require('zone.js/dist/zone-node');const express = require('express');const ngUniversal = require('@nguniversal/express-engine');/* The server bundle is loaded here, it's why you don't want a changing hash in * it */const appServer = require('./dist-server/main.bundle');/* Server-side rendering */function angularRouter(req, res) &#123; /* Server-side rendering */ res.render('index', &#123;req, res&#125;);&#125;const app = express();/* Root route before static files, or it will serve a static index.html, without * pre-rendering */app.get('/', angularRouter);/* Serve the static files generated by the CLI (index.html, CSS? JS, assets...) */app.use(express.static(`$&#123;__dirname&#125;/dist`));/* Configure Angular Express engine */app.engine('html', ngUniversal.ngExpressEngine(&#123; bootstrap: appServer.AppServerModuleNgFactory&#125;));app.set('view engine', 'html');app.set('views', 'dist');/* Direct all routes to index.html, where Angular will take care of routing */app.get('*', angularRouter);app.listen(3000, () =&gt; &#123; console.log(`Listening on http://localhost:3000`);&#125;); 執行方式 node server.js 執行上述指令後，就會將一個網站伺服器跑起來，而開啟 http://localhost:3000 的網站，即可看到由伺服器產生的 Angular 網站 參考資料 Angular server-side rendering in Node with Express Universal Engine]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Protractor]]></title>
    <url>%2F2017%2F08%2F02%2Fangular-protractor%2F</url>
    <content type="text"><![CDATA[Protractor 也是一個出自 Google 之手的 E2E 測試框架，當初是為了測試 AngularJS 所開發出來的 E2E，當然也可以用來測試其他的一般網站，跟 Angular 2 (廢言)。雖然 Protractor 出來很久了，但是一直都沒有仔細的去研究怎麼使用，這篇文章就來記錄一些。 (不談怎麼設定環境，因為 Angular CLI 已經幫我們處理好了) 目的 E2E 是利用程式來模擬使用者操作網頁的動作，測試網頁程式有符合預期的實際操作流程與結果 語法 browser 跟瀏覽器有關的行為，可透過這物件控制，列出幾個常用的方法 get：網址改變 getCurrentUrl：取得目前的網址 wait：等到條件符合後，在繼續執行 getTitle： 取得網頁的 &lt;title&gt; 內容 takeScreenshot：擷取網頁畫面，範例程式如下 1234567891011121314151617// at the top of the test spec:const fs = require('fs');// abstract writing screen shot to a filefunction writeScreenShot(data, filename) &#123; const stream = fs.createWriteStream(filename); stream.write(new Buffer(data, 'base64')); stream.end();&#125;...it('should have selected', () =&gt; &#123; page.navigateTo(); browser.takeScreenshot().then(function(png) &#123; writeScreenShot(png, 'exception.png'); &#125;); &#125;) by by 是定位器 (locator)，用來搜尋 element 使用的，常用的方法有 單一 element css：使用 CSS Selector 來定位 element id：利用 Id 來定位 element 一個或多個 elements linkText：利用連結文字來定位 elements partialLinkText：利用部分連結文字來定位 elements name：利用 name 來定位 elements className：利用 css class 來定位 elements tagName：利用 tag name 來定位 elements xpath：利用 xpath 來定位 elements (可透過瀏覽器取得該元件的 xpath) 尋找按鈕(button) - 建議使用 by.css 取代 buttonText: 用按鈕名稱找 button partialButtonText：根據部分按鈕名稱找 button element element 需要搭配 locator 使用，進而取得想要的 HTMLElement。常用方法(完整文件)如下 element(locator) isPresent：是否有符合條件的 element click：執行 click 動作 sendKeys：送出鍵盤動作。例如：打字到 Input 上 getAttribute： 取得 element 的 屬性值 getText： 取得 innerText isEnabled：判斷 element 是否有 disabled 屬性 isSelected：判斷 element 是否 selected 屬性 submit： 執行 Form submit 動作 clear：清除 value 欄位 isDisplayed：判斷 element 是否有顯示在畫面上 ，可能被設定 visibility 被設定為 false element.all(locator) get：使用 ElementArrayIndex 取得特定位置的 element count：符合條件的 element 數量 isPresent：是否有符合條件的 element 小技巧 加快 E2E 的測試速度 關掉 serve 預設的 E2E 是會先執行 serve 後在進行測試，可是這樣子的預設行為，都會因為 server 的建置時間而拖慢測試速度。所以可以將這兩個動作分別執行。 E2E 可以關掉 serve的動作，指令如下 ng e2e --serve=false 以上的設定方式，當執行 ng e2e時，就只會單純跑測試了。 使用 chrome headless 修改 protractor.conf.js，新增 chromeOptions 區塊內容，這樣的設定在執行 e2e 時，就不會跳出瀏覽器了 12345678... capabilities: &#123; 'browserName': 'chrome', chromeOptions: &#123; args: [ "--headless", "--disable-gpu", "--window-size=1920, 1080" ] &#125; &#125;, ... 詳細說明請參閱燈哥的文章 使用 PageObject 一個頁面上的 Element 很多，大多數的時間，這些 Element 都因為不同的操作流程而被重複操作著，這時候利用 PageObject 的方式將 Element 封裝。 1234567891011import &#123;browser, by, element&#125; from 'protractor';export class NgRPage &#123; navigateTo() &#123; return browser.get('/'); &#125; getParagraphText() &#123; return element(by.css('app-root h1')).getText(); &#125;&#125; 使用方式如下 1234567891011121314import &#123;NgRPage&#125; from './app.po';describe('ng-r App', () =&gt; &#123; let page: NgRPage; beforeEach(() =&gt; &#123; page = new NgRPage(); &#125;); it('should display welcome message', () =&gt; &#123; page.navigateTo(); expect(page.getParagraphText()).toEqual('todos'); &#125;);&#125;); element 與 element.all 的混搭 element(locator) 只能取回單一元素，但是可以串接下去的。例如說，我想要取得某個 select options 的值，寫法可以有兩種 1234// method 2element(by.css('ul&gt;li')); // method 2element(by.name('sel')).all(by.css('li')) 我個人是比較喜歡第二種的寫法，比較清爽一點 參考資料 Protractor API pageobject.io/ 如何使 Protractor 跑 Headless Chrome?]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular 網站與 CDN 共舞]]></title>
    <url>%2F2017%2F07%2F15%2Fangular-work-with-cdn%2F</url>
    <content type="text"><![CDATA[今天去參加社群的分享活動時，有人問到怎麼讓 Angular 的網站也可以使用 CDN 來加快網站的開啟方式。當下想到的方式是手動改 index.html，但事實上， Angular CLI 有提供更方便的方式。 設定方式 .angular-cli.json Angular CLI 提供 deployUrl 的參數，該參數所設定的網址會影響 index.html 內的 main.bundle.js、vendor.bundle.js、 css 裡面的圖片等網址，這些網址會被加上 deployUrl 所設定的網址 所以透過這個參數，就可以很簡單的將 CDN 的位置，加到現有的 script 的 src 裡。 建置指令掛參數 ng build --deploy-url=『CDN 網址』 或是 ng build -d 『CDN 網址』 其他注意事項 網址需要是 / 結尾，這樣子 lazyLoading 時才不會出錯 每一次部屬都需要讓 CDN 先清除(purge)原本就有的快取檔 (我是使用 Azure CDN 做為測試環境) 每一次的 CDN 更新都需要蠻長的一段時間]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記006]]></title>
    <url>%2F2017%2F07%2F11%2Fangular-aio-code-study-006%2F</url>
    <content type="text"><![CDATA[最近很多人在瘋 Angular 測試，那官網程式學習筆記006 就來看官方是怎麼寫測試，這次只會先看 Angular Team 是怎麼測試service 類的程式碼 研究對象 document.service.spec.ts 是這次研讀的對象，這是一個單純的 service，他的功能很簡單 (程式行數 100 行內)，就是將文件顯示到畫面上。 document.service.ts 的程式碼 12345678910111213141516171819202122232425262728293031323334import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Response &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs/Observable';import &#123; AsyncSubject &#125; from 'rxjs/AsyncSubject';import &#123; of &#125; from 'rxjs/observable/of';import 'rxjs/add/operator/catch';import 'rxjs/add/operator/map';import 'rxjs/add/operator/switchMap';import &#123; DocumentContents &#125; from './document-contents';export &#123; DocumentContents &#125; from './document-contents';import &#123; LocationService &#125; from 'app/shared/location.service';import &#123; Logger &#125; from 'app/shared/logger.service';...@Injectable()export class DocumentService &#123; private cache = new Map&lt;string, Observable&lt;DocumentContents&gt;&gt;(); currentDocument: Observable&lt;DocumentContents&gt;; constructor( private logger: Logger, private http: Http, location: LocationService) &#123; // Whenever the URL changes we try to get the appropriate doc this.currentDocument = location.currentPath.switchMap(path =&gt; this.getDocument(path)); &#125; ...&#125; 這一個 service 有注入 3 個東西，Logger、Http、LocationService ，這些在測試程式碼內也是需要被處理的 spec 初始化 Angular Team 為了這個 document.service 另外寫了兩個 function 來建立要測試的實體 1234567891011121314151617181920212223242526272829function createInjector(initialUrl: string) &#123; return ReflectiveInjector.resolveAndCreate([ DocumentService, &#123; provide: LocationService, useFactory: () =&gt; new MockLocationService(initialUrl) &#125;, &#123; provide: ConnectionBackend, useClass: MockBackend &#125;, &#123; provide: RequestOptions, useClass: BaseRequestOptions &#125;, &#123; provide: Logger, useClass: MockLogger &#125;, Http, ]);&#125;function getServices(initialUrl: string = '') &#123; const injector = createInjector(initialUrl); return &#123; backend: injector.get(ConnectionBackend) as MockBackend, locationService: injector.get(LocationService) as MockLocationService, docService: injector.get(DocumentService) as DocumentService, logger: injector.get(Logger) as MockLogger &#125;;&#125;describe('DocumentService', () =&gt; &#123; it('should be creatable', () =&gt; &#123; const &#123; docService &#125; = getServices(); expect(docService).toBeTruthy(); &#125;); ...&#125; 利用 ReflectiveInjector 建立 Injector，當建立 Injector 時，也同時會處理 DI 的部分 透過 Injector.get 的方式取得 provider 的實體 const { docService } = getServices() 是 Object 解構子的寫法 MockLogger 是共用的測試 Mock 模型 1234567891011121314151617181920212223import &#123; Injectable &#125; from '@angular/core';@Injectable()export class MockLogger &#123; output = &#123; log: [], error: [], warn: [] &#125;; log(value: any, ...rest) &#123; this.output.log.push([value, ...rest]); &#125; error(value: any, ...rest) &#123; this.output.error.push([value, ...rest]); &#125; warn(value: any, ...rest) &#123; this.output.warn.push([value, ...rest]); &#125;&#125; 利用巢狀 describe的方式將要測試的項目分組，提供更好的閱讀體驗 測試 Http 1docService.currentDocument.subscribe(); 這動作會觸發 fetchDocument 的私有方法，但這裡並不直接測試 fetchDocument，而是間接測試中間過程可能引發的變化 fetchDocument 會做 http.get 的行為，所以利用 MockBackend 可以取得呼叫 Http 時的相關資訊 123456789it('should fetch a document for the initial location', () =&gt; &#123; const &#123; docService, backend &#125; = getServices('initial/doc'); const connections = backend.connectionsArray; docService.currentDocument.subscribe(); expect(connections.length).toEqual(1); expect(connections[0].request.url).toEqual(CONTENT_URL_PREFIX + 'initial/doc.json'); expect(backend.connectionsArray[0].request.url).toEqual(CONTENT_URL_PREFIX + 'initial/doc.json');&#125;); docService.currentDocument 裡面有包含一個 switchMap ，所以當路徑變化時，也會重新取得文件內容 測試程式碼 1234567891011121314151617it('should emit a document each time the location changes', () =&gt; &#123; let latestDocument: DocumentContents; const doc0 = &#123; contents: 'doc 0', id: 'initial/doc' &#125;; const doc1 = &#123; contents: 'doc 1', id: 'new/doc' &#125;; const &#123; docService, backend, locationService &#125; = getServices('initial/doc'); const connections = backend.connectionsArray; docService.currentDocument.subscribe(doc =&gt; latestDocument = doc); expect(latestDocument).toBeUndefined(); connections[0].mockRespond(createResponse(doc0)); expect(latestDocument).toEqual(doc0); locationService.go('new/doc'); connections[1].mockRespond(createResponse(doc1)); expect(latestDocument).toEqual(doc1);&#125;); createResponse 用來建立模擬回傳結果的一個方法 123function createResponse(body: any) &#123; return new Response(new ResponseOptions(&#123; body: JSON.stringify(body) &#125;));&#125; 利用 locationService.go 來做網址的切換 模擬 Http Fail 的狀況 1connections[0].mockError(new Response(new ResponseOptions(&#123; status: 404, statusText: 'NOT FOUND'&#125;)) as any); mockError 會造成 Http 呼叫產生 Exception mockBackend.connectionsArray 這一個陣列會在執行任何 Http 呼叫後，才會有值 使用陣列的原因是，如果一個動作裡面有呼叫多個 Http 時，就可以針對個別的 Connection 給予不同的mockRespond 使用這種方式，可以減少 subscribe 的次數，以接近同步的方式寫測試 重點回顧 測試 service 不一定需要使用 TestBed 的方式來建立 serivce 實體，可以透過 ReflectiveInjector.resolveAndCreate([]) 的方式建立 Injector ，進而使用 injector.get 的方式取得 service 實體 如果要測試 HttpClient ，可以透過 MockBackend 內建的模組來模擬回傳結果或錯誤結果 利用 mockBackend.connectionsArray 的方式取得每次 Http 呼叫時所建立的連線，並給予相對應的模擬資料 ，須留意取得的順序 程式碼 document.service.ts document.service.spec.ts]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Middleware]]></title>
    <url>%2F2017%2F07%2F05%2Fcore-middleware%2F</url>
    <content type="text"><![CDATA[middleware 在 .NET Core 裡也是一個很重要的機制，來學習吧 什麼是 middleware? middleware 就像逆滲透的濾水器，自來水 (Request) 要沿著管路 (pipeline) 經過多層的濾心 (middleware) 後，就能得到乾淨的水 (Response)。 簡單看一下在 .NET Core 內是怎麼使用的 123456789101112public void Configure(IApplicationBuilder app)&#123; app.UseExceptionHandler("/Home/Error"); // Call first to catch exceptions // thrown in the following middleware. app.UseStaticFiles(); // Return static files and end pipeline. app.UseIdentity(); // Authenticate before you access // secure resources. app.UseMvcWithDefaultRoute(); // Add MVC to the request pipeline.&#125; 這樣子系統就會依設定的順序，依序執行 IApplicationBuilder 123456789101112131415public interface IApplicationBuilder&#123; ... // // Summary: // /// Adds a middleware delegate to the application's request pipeline. /// // // Parameters: // middleware: // The middleware delgate. // // Returns: // The Microsoft.AspNetCore.Builder.IApplicationBuilder. IApplicationBuilder Use(Func&lt;RequestDelegate, RequestDelegate&gt; middleware);&#125; 這裡跟 middleware 有關的，就是最後一個 Use，如果想要加入 middleware ，就是透過 Use 這方法加入(方法之一)，用以下簡單的程式碼做個說明 1234567891011121314151617181920212223242526272829303132public void Configure(IApplicationBuilder app)&#123; app.Use((context, next) =&gt; &#123; this.list.Clear(); this.list.Add(context.Request.Host.Host); return next(); &#125;); app.Use(async (context, next) =&gt; &#123; //Do some work here context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); //Pass the request on down to the next pipeline (Which is the MVC middleware) await next.Invoke(); &#125;); app.Use((context, next) =&gt; &#123; this.list.Add("pipe 2"); return next(); &#125;); app.Use(async (context, next) =&gt; &#123; await context.Response.WriteAsync(string.Join(" || ", this.list)); &#125;); app.Use((context, next) =&gt; &#123; this.list.Add("pipe 3"); return next(); &#125;);&#125; 這樣的執行結果如下 重點整理 context 的變數是代表 HttpContext 本體 可以從 context 裡取得 Request的資訊，也可以增加 Response Headers的內容 如果在 middleware 間有異動到 Response時，之後的 middleware 就會失效 可以使用 return next() 或是 await next.Invoke() 兩種方式執行下一個 middleware middleware 是有順序性的，要留意!! 進階用法：Map、MapWhen 針對不同的網址，給予不同的 Response Header 如果想要做到上述的情境，就可以利用 Map 這方法，寫法如下 12app.Map("/api/post", HandlePath2);app.Map("/api", HandlePath1); 或是這樣子寫也是可以的 12345app.Map("/api", apiLevel =&gt;&#123; apiLevel.Map("/post", HandlePath2); apiLevel.Map("", HandlePath1);&#125;); 1234567891011121314private static void HandlePath1(IApplicationBuilder app)&#123; app.Use(async (context, next) =&gt; &#123; //Do some work here context.Response.Headers.Add("X-Content-Type-Options", "api"); //Pass the request on down to the next pipeline (Which is the MVC middleware) await next.Invoke(); &#125;); app.Use(async (context, next) =&gt; &#123; await context.Response.WriteAsync("API Page"); &#125;);&#125; 另外一種寫法是使用 MapWhen 12app.MapWhen(context =&gt; context.Request.Query.ContainsKey("branch"), HandleBranch); **注意事項 : ** 如果使用 Map 的話，就會與主線脫離關係了，變成是獨立的執行環境。這點要留意。 Run、Map、MapWhen 皆是 IApplicationBuilder 的擴充方法 內建 Middleware Middleware Description Authentication Provides authentication support. CORS Configures Cross-Origin Resource Sharing. Response Caching Provides support for caching responses. Response Compression Provides support for compressing responses. Routing Defines and constrains request routes. Session Provides support for managing user sessions. Static Files Provides support for serving static files and directory browsing. URL Rewriting Middleware Provides support for rewriting URLs and redirecting requests. 自訂 Middleware 自訂 middleware 有兩種寫法，一種是如一開始使用 Use 的方式來寫，另外一種，就是寫成 Middleware 的元件，如同內建的 middleware 基本架構如下 12345678910111213141516171819202122using Microsoft.AspNetCore.Http;using System.Globalization;using System.Threading.Tasks;namespace Demo&#123; public class MyDemoMiddleware &#123; private readonly RequestDelegate _next; public MyDemoMiddleware(RequestDelegate next) &#123; _next = next; &#125; public Task Invoke(HttpContext context) &#123; // Call the next delegate/middleware in the pipeline return this._next(context); &#125; &#125;&#125; 要使用自己所寫的 middleware時，有兩種方式 擴充 IApplicationBuilder 的方法，使用 Extension Methods 的方式。 1234public static IApplicationBuilder UseRequestCulture(this IApplicationBuilder builder)&#123; return builder.UseMiddleware&lt;MyDemoMiddleware&gt;();&#125; 利用 UseMiddleware 的方式加入 123456public void Configure(IApplicationBuilder app)&#123; ... app.UseMiddleware&lt;MyDemoMiddleware&gt;(); ...&#125; 參考資料 Middleware]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Extension Method]]></title>
    <url>%2F2017%2F07%2F03%2Fangular-method-extension%2F</url>
    <content type="text"><![CDATA[如果有寫 C# 的人，多少都會寫到擴充方法(Extension Method) ，在 JavaScript 裡面也有雷同的功能，就是直接擴充 prototype 的功能，而 TypeScript 也同理，這裡整理 3 種擴充方法的寫法，並將擴充方法加入到 Angular 專案內使用 擴充 情境：要讓文字有可以直接轉述字型的功能，不想自己在寫 parseFloat 了 我目前想到的寫法有以下三種 寫法一 直接擴充 prototype 123String.prototype.toNumber = function():number &#123; return parseFloat(this); &#125; 這樣的寫法作為直接 寫法二 Object.assign 12345Object.assign(String.prototype, &#123; toNumber(): number &#123; return parseFloat(this); &#125;&#125;); 寫法三 Object.defineProperty 12345Object.defineProperty(String.prototype, 'toNumber', &#123; value(): number &#123; return parseFloat(this); &#125;&#125;) 使用這種方式，可以有更多的彈性來設定物件的功能。可參閱API文件 加入至 Angular 專案中 以上的三種方式都可以達到目的，就依個人喜好選擇了。現在問題是，如何將寫好的擴充方法，加入至 Angular 專案裡。 基本上，只要有網站也載入該擴充功能，整個網站底層就會直接生效，但在開發時期，會遇到的錯誤提示是 TypeScript 編譯器不認識擴充的功能，這時候，就需要再 typings.d.ts 內加上所擴充的功能 123interface String &#123; toNumber(): number;&#125; 當這樣子將擴充方法的定義補上後，TypeScript 編譯器就會認識我們所擴充的功能了，之後就是開心的寫程式了。 參考資料 Object.assign() Object.defineProperty()]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 另外一種簡單的方式載入 Component]]></title>
    <url>%2F2017%2F07%2F02%2Fangular-component-outlet%2F</url>
    <content type="text"><![CDATA[原本 Angular 就提供動態載入 Component 的方式，但是 Angular 又提供另外一種更簡單的方式，ngComponentOutlet，簡單到一個變態的境界 Overview 123456789directive NgComponentOutlet implements OnChanges, OnDestroy &#123; constructor(_viewContainerRef: ViewContainerRef) ngComponentOutlet: Type&lt;any&gt; ngComponentOutletInjector: Injector ngComponentOutletContent: any[][] ngComponentOutletNgModuleFactory: NgModuleFactory&lt;any&gt; ngOnChanges(changes: SimpleChanges) ngOnDestroy()&#125; 基本款 在介紹之前，先簡單看一下程式碼 1234567@Component(&#123; selector: 'ng-component-outlet-simple-example', template: `&lt;ng-container *ngComponentOutlet="Hello"&gt;&lt;/ng-container&gt;`&#125;)class NgTemplateOutletSimpleExample &#123; Hello = HelloComponent;&#125; 沒錯，就只有這樣。這是不是比另外一種動態載入 Component 的方式更簡單 備註: 只要是要動態載入的，就必須在 ngModule 的 entryComponents 裡註冊 進階使用 Injector 當想要動態載入的 Component 需要注入其他服務時，又該如何處理呢，還好 ngComponentOutlet 也有提供 injector 的方法 1234567891011121314151617181920212223import &#123; Component, Injector, ReflectiveInjector &#125; from '@angular/core';import &#123; HelloComponent &#125; from './hello/hello.component';import &#123; GreeterService &#125; from './greeter.service';@Component(&#123; selector: 'app-root', template: ` &lt;ng-container *ngComponentOutlet="HelloWorld; injector: myInjector"&gt; &lt;/ng-container&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; HelloWorld = HelloComponent; myInjector: Injector; constructor(injector: Injector) &#123; this.myInjector = ReflectiveInjector.resolveAndCreate( [GreeterService], injector ); &#125;&#125; Content 如果動態載入的Component, 有 &lt;ng-content&gt; 時，要如何將內容填入呢? ngComponentOutlet 有提供 content 的方式可以將 DOM 內容傳入並顯示 123456789101112131415161718192021import &#123; Component, Injector, ReflectiveInjector &#125; from '@angular/core';import &#123; HelloComponent &#125; from './hello/hello.component';import &#123; GreeterService &#125; from './greeter.service';@Component(&#123; selector: 'app-root', template: ` &lt;ng-container *ngComponentOutlet="HelloWorld; content: myContent"&gt; &lt;/ng-container&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; HelloWorld = HelloComponent; myContent = [ [document.createTextNode('Ahoj')], [document.createTextNode('second content')] ]; constructor() &#123;&#125;&#125; 注意: content 接受一個二微陣列，陣列的第一層的順序，是依 &lt;ng-content&gt; 的顯示順序 第二層的這陣列，則是所屬的 &lt;ng-content&gt; 要顯示的內容 需使用 document.createXX 的方式建立顯示內容 顯示結果 ngModuleFactory 如果想要載入的 Component 是來自其他的 Module 時，又該怎麼處理呢? 這時就要利用 ngModuleFactory 了，寫法也很簡單，請參閱下面的程式碼 123456789101112131415161718192021import &#123; Component, Compiler, NgModuleFactory &#125; from '@angular/core';import &#123; HelloComponent &#125; from './other/hello/hello.component';import &#123; OtherModule &#125; from './other/other.module';@Component(&#123; selector: 'app-root', template: ` &lt;ng-container *ngComponentOutlet="HelloWorld; ngModuleFactory: myModule"&gt; &lt;/ng-container&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; HelloWorld = HelloComponent; myModule: NgModuleFactory&lt;any&gt;; constructor(compiler: Compiler) &#123; this.myModule = compiler.compileModuleSync(OtherModule); &#125;&#125; 這裡的 OtherModule 不需要事先 Import 到 AppModule 裡 範例: 動態切換 123456789101112131415161718192021222324252627282930313233import &#123; Component, Compiler, NgModuleFactory &#125; from '@angular/core';import &#123; GreeterService &#125; from './greeter.service';import &#123; HelloComponent &#125; from './other/hello/hello.component';import &#123; OtherModule &#125; from './other/other.module';import &#123; WorldComponent &#125; from './other/world/world.component';@Component(&#123; selector: 'app-root', template: ` &lt;ng-container *ngComponentOutlet="HelloWorld; ngModuleFactory: myModule"&gt; &lt;/ng-container&gt; &lt;button type="button" (click)="switch()"&gt;switch&lt;/button&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; HelloWorld: any; myModule: NgModuleFactory&lt;any&gt;; constructor(compiler: Compiler) &#123; this.myModule = compiler.compileModuleSync(OtherModule); this.HelloWorld = HelloComponent; &#125; switch() &#123; if (this.HelloWorld.name === 'HelloComponent') &#123; this.HelloWorld = WorldComponent; &#125; else &#123; this.HelloWorld = HelloComponent; &#125; &#125;&#125; 參考資料 NgComponentOutlet]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular 下拉選單的隱藏菜單]]></title>
    <url>%2F2017%2F07%2F02%2Fangular-select-option%2F</url>
    <content type="text"><![CDATA[看完 Sam 所寫的 如何使用 Angular 實作下拉選單?，其實 Angular 針對 Select 這個控制項，有提供一些額外的功能，這邊文章就來整理一下這控制項的隱藏菜單 隱藏菜單 ngValue AngularJS 有提供 ngOptions 的方法，可以讓我們把 Object 當作 Option 的值，當我們做下拉選單選擇時，就可以取得所選取的物件資料，十分的方便。但在 Angular 裡面應該要怎麼寫才能有同樣的效果。 Angular 如果想要達到同樣的效果，就需要將 Object資料 塞到 ngValue 內即可達到一樣的效果 123456789101112131415161718192021222324252627import &#123;Component&#125; from '@angular/core'; @Component(&#123; selector: 'example-app', template: ` &lt;form #f="ngForm"&gt; &lt;select name="state" ngModel&gt; &lt;option value="" disabled&gt;Choose a state&lt;/option&gt; &lt;option *ngFor="let state of states" [ngValue]="state"&gt; &#123;&#123; state.abbrev &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;p&gt;Form value: &#123;&#123; f.value | json &#125;&#125;&lt;/p&gt; &lt;!-- example value: &#123;state: &#123;name: 'New York', abbrev: 'NY'&#125; &#125; --&gt; `,&#125;)export class SelectControlComp &#123; states = [ &#123;name: 'Arizona', abbrev: 'AZ'&#125;, &#123;name: 'California', abbrev: 'CA'&#125;, &#123;name: 'Colorado', abbrev: 'CO'&#125;, &#123;name: 'New York', abbrev: 'NY'&#125;, &#123;name: 'Pennsylvania', abbrev: 'PA'&#125;, ];&#125; compareWith 當使用 Object 當作資料時，要怎麼設定下拉選單所選取的值呢，這時候可以透過 compareWith 的方法來實現 123456classs AppComponent&#123; ... compareFn(c1: Country, c2: Country): boolean &#123; return c1 &amp;&amp; c2 ? c1.id === c2.id : c1 === c2; &#125;&#125; template 的部分是 12345&lt;select [compareWith]="compareFn" [(ngModel)]="selectedCountries"&gt; &lt;option *ngFor="let country of countries" [ngValue]="country"&gt; &#123;&#123;country.name&#125;&#125; &lt;/option&gt;&lt;/select&gt; 透過自訂的方式來決定要依什麼條件來選取下拉選單的選項 注意: compareWith 是監聽 change 事件，因為 input 事件在 Firefox 和 IE 上是不會被觸發的。 參考資料 SelectControlValueAccessor]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記005]]></title>
    <url>%2F2017%2F06%2F19%2Fangular-aio-code-study-005%2F</url>
    <content type="text"><![CDATA[&lt;aio-doc-viewer&gt; Component 是顯示主要內容的區域，來研讀一下是如何動態抽換顯示內容的 &lt;aio-doc-viewer&gt; 預設的 template 是空白的，所以並沒有預設的 html template, &lt;aio-doc-viewer&gt; 是類似 placeholder 的角色，用來定位內容顯示位置用 初始值 12const initialDocViewerElement = document.querySelector('aio-doc-viewer');const initialDocViewerContent = initialDocViewerElement ? initialDocViewerElement.innerHTML : ''; 這兩行是定義在 class DocViewerComponent，主要的用途是避免畫面閃爍 constructor constructor 共注入了以下幾個 provider ComponentFactoryResolver：用來動態產生 component 的方法 ElementRef：當下 Component 的 DOM 參考 EmbeddedComponents：可以動態載入的自訂component 陣列 Injector：可以手動取得 provider 的方法 Title：用來更新網頁標題的服務 TocService：自訂的 service，負責 TOC 區塊的相關行為 建立 components 12345678910111213141516interface EmbeddedComponentFactory &#123; contentPropertyName: string; factory: ComponentFactory&lt;any&gt;;&#125;private embeddedComponentFactories: Map&lt;string, EmbeddedComponentFactory&gt; = new Map();constructor(...)&#123; ... for (const component of embeddedComponents.components) &#123; const factory = componentFactoryResolver.resolveComponentFactory(component); const selector = factory.selector; const contentPropertyName = this.selectorToContentPropertyName(selector); this.embeddedComponentFactories.set(selector, &#123; contentPropertyName, factory &#125;); &#125;&#125; 根據預先設定好的 components 陣列，分別動態建立 componentFactory，供之後顯示使用 selectorToContentPropertyName 123private selectorToContentPropertyName(selector: string) &#123; return selector.replace(/-(.)/g, (match, $1) =&gt; $1.toUpperCase()) + 'Content';&#125; 執行效果: 12selector = 'aio-doc-viewer';selectorToContentPropertyName(selector); //輸出結果: aioDocViewerContent 觸發點 - set doc 當外部指定新的 DocumentContents 至 DocViewerComponent 時，需要執行的工作 1234567891011@Output()docRendered = new EventEmitter();@Input()set doc(newDoc: DocumentContents) &#123; this.ngOnDestroy(); if (newDoc) &#123; this.build(newDoc); this.docRendered.emit(); &#125;&#125; 先清空現有的狀態 重新建置要顯示的內容 當建置完成後，透過 docRendered 發出完成通知 ngOndestory 12345ngOnDestroy() &#123; // destroy these components else there will be memory leaks this.embeddedComponents.forEach(comp =&gt; comp.destroy()); this.embeddedComponents.length = 0;&#125; 摧毀產生的 componennts 將 embeddedComponents 清空 build 123456789101112131415161718192021222324private build(doc: DocumentContents) &#123; // security: the doc.content is always authored by the documentation team // and is considered to be safe this.hostElement.innerHTML = doc.contents || ''; if (!doc.contents) &#123; return; &#125; this.addTitleAndToc(doc.id); // TODO(i): why can't I use for-of? why doesn't typescript like Map#value() iterators? this.embeddedComponentFactories.forEach((&#123; contentPropertyName, factory &#125;, selector) =&gt; &#123; const embeddedComponentElements = this.hostElement.querySelectorAll(selector); // cast due to https://github.com/Microsoft/TypeScript/issues/4947 for (const element of embeddedComponentElements as any as HTMLElement[])&#123; // hack: preserve the current element content because the factory will empty it out // security: the source of this innerHTML is always authored by the documentation team // and is considered to be safe element[contentPropertyName] = element.innerHTML; this.embeddedComponents.push(factory.create(this.injector, [], element)); &#125; &#125;);&#125; 調整網頁的抬頭並建立 TOC 樣版 由於官網的 docContent 都是預先產生的，所以這裡認定為無安全性的問題。實務上也請盡量避免直接操作 DOM，以避免不必要的問題 根據 content html 的內容，決定要產生哪些 component 透過在 constructor 存入的 componentFactory 來建立 component，並將建立後的 componentRef 存入至 embeddedComponents 陣列中 addTitleAndToc 123456789101112131415private addTitleAndToc(docId: string) &#123; this.tocService.reset(); let title = ''; const titleEl = this.hostElement.querySelector('h1'); // Only create TOC for docs with an &lt;h1&gt; title // If you don't want a TOC, add "no-toc" class to &lt;h1&gt; if (titleEl) &#123; title = titleEl.innerText.trim(); if (!/(no-toc|notoc)/i.test(titleEl.className)) &#123; this.tocService.genToc(this.hostElement, docId); titleEl.insertAdjacentHTML('afterend', '&lt;aio-toc class="embedded"&gt;&lt;/aio-toc&gt;'); &#125; &#125; this.titleService.setTitle(title ? `Angular - $&#123;title&#125;` : 'Angular');&#125; 透過 insertAdjacentHTML 將內容新增到想要的位置 DoCheck 12345private embeddedComponents: ComponentRef&lt;any&gt;[] = [];ngDoCheck() &#123; this.embeddedComponents.forEach(comp =&gt; comp.changeDetectorRef.detectChanges());&#125; 每次當畫面上有觸發 Check 動作時，執行每一個動態產生的 componentRef 的 changeDetectorRef 的 detectChagnes (功能: 檢查是否有資料異動) ChangeDetectorRef 是的功能是用來檢查資料異動並同步頁面與程式。在每一個 Component 都會有自己的 ChangeDetector。 參考資料 ComponentFactoryResolver ComponentFactory Injector Title ComponentRef ChangeDetectorRef insertAdjacentHTML]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記004]]></title>
    <url>%2F2017%2F06%2F19%2Fangular-aio-code-study-004%2F</url>
    <content type="text"><![CDATA[這篇會研讀 &lt;aio-nav-menu&gt; 及 &lt;aio-select&gt; component，就是這一區塊 template 1234567&lt;md-sidenav [ngClass]="&#123;'collapsed': !isSideBySide &#125;" #sidenav class="sidenav" [opened]="isOpened" [mode]="mode" (open)="updateHostClasses()" (close)="updateHostClasses()"&gt; &lt;aio-nav-menu *ngIf="!isSideBySide" [nodes]="topMenuNarrowNodes" [currentNode]="currentNodes?.TopBarNarrow" [isWide]="false"&gt;&lt;/aio-nav-menu&gt; &lt;aio-nav-menu [nodes]="sideNavNodes" [currentNode]="currentNodes?.SideNav" [isWide]="isSideBySide"&gt;&lt;/aio-nav-menu&gt; ...&lt;/md-sidenav&gt; 這裡的 &lt;aio-nav-menu&gt;有兩個，依 isSideBySide 變數來決定要顯示哪一個，這兩個不會同時存在，判斷的規則是根據視窗大小 1234567private sideBySideWidth = 992;@HostListener('window:resize', ['$event.target.innerWidth'])onResize(width) &#123; this.isSideBySide = width &gt; this.sideBySideWidth; ...&#125; nodes 的取法，請參閱這篇文章 12345this.navigationService.navigationViews.subscribe(views =&gt; &#123; ... this.topMenuNodes = views['TopBar'] || []; this.topMenuNarrowNodes = views['TopBarNarrow'] || this.topMenuNodes;&#125;); ​ NavMenuComponent 12&lt;aio-nav-item *ngFor="let node of filteredNodes" [node]="node" [selectedNodes]="currentNode?.nodes" [isWide]="isWide"&gt;&lt;/aio-nav-item&gt; 123456export class NavMenuComponent &#123; @Input() currentNode: CurrentNode; @Input() isWide = false; @Input() nodes: NavigationNode[]; get filteredNodes() &#123; return this.nodes ? this.nodes.filter(n =&gt; !n.hidden) : []; &#125;&#125; NavItemComponent ngOnChanges 12345678910111213141516171819@Input() isWide = false;@Input() level = 1;@Input() node: NavigationNode;@Input() selectedNodes: NavigationNode[];ngOnChanges(changes: SimpleChanges) &#123; if (changes['selectedNodes'] || changes['node'] || changes['isWide']) &#123; if (this.selectedNodes) &#123; const ix = this.selectedNodes.indexOf(this.node); this.isSelected = ix !== -1; // this node is the selected node or its ancestor this.isExpanded = this.isSelected || // expand if selected or ... // preserve expanded state when display is wide; collapse in mobile. (this.isWide &amp;&amp; this.isExpanded); &#125; else &#123; this.isSelected = false; &#125; &#125; this.setClasses();&#125; ngOnChanges 的 changes 內會包含所有 @Input 的變數 小技巧 如果想要定義的型別，不確定裡面的型態會如何，可以裡用這樣子定義 1classes: &#123;[index: string]: boolean &#125;; 這樣定義的資料格式會是 { 'level-1': true, collapsed: false} 在 template 上面的用法，f其實還聰明的 1[ngClass]="classes" aio-select Component 檔案位置: src/app/shared/select 此 Component 使用 ul 來模擬 select-option的效果 Version 資訊的來源 12345678910 // Compute the version picker list from the current version and the versions in the navigation // mapcombineLatest( this.navigationService.versionInfo.map(versionInfo =&gt; (&#123;title: versionInfo.raw, url: null&#125;)), this.navigationService.navigationViews.map(views =&gt; views['docVersions']), (currentVersion, otherVersions) =&gt; [currentVersion, ...otherVersions]) .subscribe(versions =&gt; &#123; this.docVersions = versions; this.currentDocVersion = this.docVersions[0];&#125;); 利用 combineLatest 來將兩組資料源合併成一個新的資料源 onDocVersionChange 會跳至所選擇的版本網址 小技巧 HostListener搭配 document:event 就可以監聽到全域事件 constructor內所取得的 ElementRef 就是 Component 本身的 DOM]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記003]]></title>
    <url>%2F2017%2F06%2F16%2Fangular-aio-code-study-003%2F</url>
    <content type="text"><![CDATA[繼續筆記002，繼續研究下去。這篇會研讀 &lt;aio-search-box&gt; 與 &lt;aio-search-result&gt; component aio-search-box 檔案位置 src/app/search/search-box search-box.component 1234567891011121314@Component(&#123; selector: 'aio-search-box', template: `&lt;input #searchBox type="search" aria-label="search" placeholder="Search" (input)="doSearch()" (keyup)="doSearch()" (focus)="doFocus()" (click)="doSearch()"&gt;`&#125;)export class SearchBoxComponent implements OnInit &#123; ...&#125; ngOnInit 如果網址有類似這種情況時 https://angular.io/?search=xxxxxx， 會預先使用網址的查詢條件並執行搜尋 1234567ngOnInit() &#123; const query = this.locationService.search()['search']; if (query) &#123; this.query = query; this.doSearch(); &#125;&#125; locationService.search() 的程式碼如下 1234567891011121314151617search(): &#123; [index: string]: string; &#125; &#123; const search = &#123;&#125;; const path = this.location.path(); const q = path.indexOf('?'); if (q &gt; -1) &#123; try &#123; const params = path.substr(q + 1).split('&amp;'); params.forEach(p =&gt; &#123; const pair = p.split('='); if (pair[0]) &#123; search[decodeURIComponent(pair[0])] = pair[1] &amp;&amp; decodeURIComponent(pair[1]); &#125; &#125;); &#125; catch (e) &#123; /* don't care */ &#125; &#125; return search;&#125; doSearch() 1234567private searchSubject = new Subject&lt;string&gt;();@Output() onSearch = this.searchSubject.distinctUntilChanged();doSearch() &#123; this.searchSubject.next(this.query);&#125; searchSubject 是 @Output，所以會將查詢條件輸出並觸發 app.component.ts 的搜尋功能 app.component.ts 的 doSearch(query) 會執行 searchService.search(query) 的動作，並判斷是否要顯示 aio-search-result 1234doSearch(query) &#123; this.searchService.search(query); this.showSearchResults = !!query;&#125; 另外一個要注意的地方是，這一個 @Output onSearch 是使用 Subject 的方式作為溝通介面，以下幾點原因 EventEmitter 的本質原本就是 Subject，所以使用 Subject 做替換是沒有問題的 直接使用 Subject 而不使用 EventEmitter 的好處是，可以搭配 RxJS 的 Operator，例如 distinctUntilChanged 使用 distinctUntilChanged 可以減少不必要的執行查詢的動作 doFocus() 12345678@Output() onFocus = new EventEmitter&lt;string&gt;();doFocus() &#123; this.onFocus.emit(this.query);&#125;focus() &#123; this.searchBox.nativeElement.focus();&#125; 當停駐於這個物件時，也會觸發搜尋功能 focus() 是公開方法，可以讓游標停留在搜尋欄位。 小技巧 1234@ViewChild('searchBox') searchBox: ElementRef;private get query() &#123; return this.searchBox.nativeElement.value; &#125;private set query(value: string) &#123; this.searchBox.nativeElement.value = value; &#125; 使用 getter / setter 的方式，來簡化程式碼的撰寫，這個專案內，這技巧到處都可以看到。 aio-search-result 檔案位置 src/app/search/search-results search-results.component 樣板 12345678910111213141516171819202122232425262728&lt;div class="search-results"&gt; &lt;div *ngIf="searchAreas.length; then searchResults; else notFound"&gt;&lt;/div&gt;&lt;/div&gt;&lt;ng-template #searchResults&gt; &lt;h2 class="visually-hidden"&gt;Search Results&lt;/h2&gt; &lt;div class="search-area" *ngFor="let area of searchAreas"&gt; &lt;h3&gt;&#123;&#123;area.name&#125;&#125; (&#123;&#123;area.pages.length + area.priorityPages.length&#125;&#125;)&lt;/h3&gt; &lt;ul class="priority-pages" &gt; &lt;li class="search-page" *ngFor="let page of area.priorityPages"&gt; &lt;a class="search-result-item" href="&#123;&#123; page.path &#125;&#125;" (click)="onResultSelected(page)"&gt; &lt;span class="symbol &#123;&#123;page.type&#125;&#125;" *ngIf="area.name === 'api'"&gt;&lt;/span&gt;&#123;&#123; page.title &#125;&#125; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li class="search-page" *ngFor="let page of area.pages"&gt; &lt;a class="search-result-item" href="&#123;&#123; page.path &#125;&#125;" (click)="onResultSelected(page)"&gt; &lt;span class="symbol &#123;&#123;page.type&#125;&#125;" *ngIf="area.name === 'api'"&gt;&lt;/span&gt;&#123;&#123; page.title &#125;&#125; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/ng-template&gt;&lt;ng-template #notFound&gt; &lt;p&gt;No results found.&lt;/p&gt;&lt;/ng-template&gt; 利用 ngIf then else 搭配 &lt;ng-template&gt; 加樣版變數來控制要顯示的內容區塊 ngOnInit 1234ngOnInit() &#123; this.resultsSubscription = this.searchService.searchResults .subscribe(search =&gt; this.searchAreas = this.processSearchResults(search));&#125; 註冊 searchService的 searchResults 當有資料產生時經過 processSearchResults 處理後，再將其結果顯示 ngOnDestory 123ngOnDestroy() &#123; this.resultsSubscription.unsubscribe();&#125; 取消searchService.searchResults 的訂閱 processSearchRestuls 123456789101112export interface SearchResults &#123; query: string; results: SearchResult[];&#125;export interface SearchResult &#123; path: string; title: string; type: string; titleWords: string; keywords: string;&#125; 12345678910111213141516171819202122232425262728293031private processSearchResults(search: SearchResults) &#123; const searchAreaMap = &#123;&#125;; search.results.forEach(result =&gt; &#123; if (!result.title) &#123; return; &#125; // bad data; should fix const areaName = this.computeAreaName(result) || this.defaultArea; const area = searchAreaMap[areaName] = searchAreaMap[areaName] || []; area.push(result); &#125;); const keys = Object.keys(searchAreaMap).sort((l, r) =&gt; l &gt; r ? 1 : -1); return keys.map(name =&gt; &#123; let pages: SearchResult[] = searchAreaMap[name]; // Extract the top 5 most relevant results as priorityPages const priorityPages = pages.splice(0, 5); pages = pages.sort(compareResults); return &#123; name, pages, priorityPages &#125;; &#125;);&#125;// Split the search result path and use the top level folder, if there is one, as the area name.private computeAreaName(result: SearchResult) &#123; if (this.topLevelFolders.indexOf(result.path) !== -1) &#123; return result.path; &#125; const [areaName, rest] = result.path.split('/', 2); return rest &amp;&amp; areaName;&#125;// outside classfunction compareResults(l: &#123;title: string&#125;, r: &#123;title: string&#125;) &#123; return l.title.toUpperCase() &gt; r.title.toUpperCase() ? 1 : -1;&#125; 將結果依組別並字母排序顯示]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記002]]></title>
    <url>%2F2017%2F06%2F15%2Fangular-aio-code-study-002%2F</url>
    <content type="text"><![CDATA[繼續筆記001，繼續研究下去。這篇會研讀 &lt;aio-top-menu&gt; component aio-top-menu component 所在路徑 src/app/layout/top-menu 1234567891011121314import &#123; Component, Input &#125; from '@angular/core';import &#123; NavigationNode &#125; from 'app/navigation/navigation.service';@Component(&#123; selector: 'aio-top-menu', template: ` &lt;ul role="navigation"&gt; &lt;li *ngFor="let node of nodes"&gt;&lt;a class="nav-link" [href]="node.url" [title]="node.title"&gt;&#123;&#123; node.title &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;`&#125;)export class TopMenuComponent &#123; @Input() nodes: NavigationNode[];&#125; 由 app.component.ts 提供要顯示的資料 1234567export interface NavigationNode &#123; url?: string; title?: string; tooltip?: string; hidden?: string; children?: NavigationNode[];&#125; app.component.ts 提供 &lt;aio-top-menu&gt;的資料來源是 navigationService.navigationViews 12345this.navigationService.navigationViews.subscribe(views =&gt; &#123; ... this.topMenuNodes = views['TopBar'] || []; ... &#125;); 在 navigationService 內的 navigationView 方法如下 12const navigationInfo = this.fetchNavigationInfo();this.navigationViews = this.getNavigationViews(navigationInfo); fetchNavigationInfo 123456789const navigationPath = CONTENT_URL_PREFIX + 'navigation.json';private fetchNavigationInfo(): Observable&lt;NavigationResponse&gt; &#123; const navigationInfo = this.http.get(navigationPath) .map(res =&gt; res.json() as NavigationResponse) .publishLast(); navigationInfo.connect(); return navigationInfo;&#125; 其實這段很有趣，以下是程式碼裡的註解，詳細說明為什麼他們要這樣子寫 Get an observable that fetches the NavigationResponse from the server. We create an observable by calling http.get but then publish it to share the result among multiple subscribers, without triggering new requests. We use publishLast because once the http request is complete the request observable completes. If you use publish here then the completed request observable will cause the subscribed observables to complete too. We connect to the published observable to trigger the request immediately. We could use .refCount here but then if the subscribers went from 1 -&gt; 0 -&gt; 1 then you would get another request to the server. We are not storing the subscription from connecting as we do not expect this service to be destroyed. publishLast() 只會記錄 Observable 完成後的值。 connect() 會立即執行 Obervable。 透過這兩個 Operator 的組合就可以避免重複發出 request，又可以保留最後的資料。 1export type NavigationResponse = &#123;__versionInfo: VersionInfo &#125; &amp; &#123; [name: string]: NavigationNode[]|VersionInfo &#125;; 這種 type 的定義方式為 TypeScript 的 Intersection Types，意思是指當指定到這種型別時，需同時符合第一種及第二種型別。 而在這 function 內所取得的資料來源 (generated/navigation.json)，就是符合這種格式的。 getNavigationViews 繼上一段取完資料後的 Observable，接著會傳進這個 function，這 function 的功能是將關於 View 的部分抽離出來 12345678910111213private getNavigationViews(navigationInfo: Observable&lt;NavigationResponse&gt;): Observable&lt;NavigationViews&gt; &#123; const navigationViews = navigationInfo .map(response =&gt; &#123; const views = Object.assign(&#123;&#125;, response); Object.keys(views).forEach(key =&gt; &#123; if (key[0] === '_') &#123; delete views[key]; &#125; &#125;); return views as NavigationViews; &#125;) .publishLast(); navigationViews.connect(); return navigationViews;&#125; Object.assign({}, response) 將原有的資料複製成一份全新的 map 裡的行為是將 __versionInfo 的部分從既有的資料中刪除 使用 publishLast() 跟 connect() 的理由同上一段 回傳的結果，就只會剩下 NavigationViews 而已 123export interface NavigationViews &#123; [name: string]: NavigationNode[];&#125; 接著回到 app.component.ts ，在 subscribe 之後就可以取得 NavigationViews 了 12345this.navigationService.navigationViews.subscribe(views =&gt; &#123; ... this.topMenuNodes = views['TopBar'] || []; ... &#125;); 所以 topmenuNodes 就透過 KeyValue 的形式從 NavigationViews 中取出並讓 &lt;aio-top-menu&gt; 做顯示的動作 參考資料 rx-subject]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]angular.io官網程式碼學習筆記001]]></title>
    <url>%2F2017%2F06%2F15%2Fangular-aio-code-study-001%2F</url>
    <content type="text"><![CDATA[近期 angular.io 換新版，使用 Angular 4 重新撰寫官方網站，網站開啟速度非常的快 (PWA)，所以就想要從官方出手寫的程式碼學習 Angular 程式碼可以怎麼寫，接下來的一系列學習筆記將圍繞的這個主題，程式碼可以從 github 下載 main.ts 12345678platformBrowserDynamic().bootstrapModule(AppModule).then(ref =&gt; &#123; if (environment.production &amp;&amp; 'serviceWorker' in (navigator as any)) &#123; const appRef: ApplicationRef = ref.injector.get(ApplicationRef); appRef.isStable.first().subscribe(() =&gt; &#123; (navigator as any).serviceWorker.register('/worker-basic.min.js'); &#125;); &#125;&#125;); bootstrapModule 完成後會回傳一個 NgModuleRef，可以透過 ngModuleRef 的 injector 取得 ApplicationRef，利用這樣子的寫法，可以將 service-worker 注入到網頁裡。原本這一段是寫在 index.html 裡，但透過這樣子的方式註冊，更有彈性，例如我們可以設定只有在 production模式下才要註冊 service-worker。 app.component.ts template html 使用 Angular Materia 2 當作專案樣式 gotop anchor 1&lt;div id="top-of-page"&gt;&lt;/div&gt; GoTOP的錨點 loading bar 123&lt;div *ngIf="isFetching" class="progress-bar-container"&gt; &lt;md-progress-bar mode="indeterminate" color="warn"&gt;&lt;/md-progress-bar&gt;&lt;/div&gt; 顯示條件: isFetching是 true時 &lt;md-progress-bar&gt; 是一個 materia2 橫向進度顯示物件 mode 可以有以下的參數設定， 共 4 種顯示模式 determinate: 標準的進度表，從 0 ~ 100 % indeterminate: 用來顯示有事情正在進行中 buffer: 可以同時顯示兩種進度，例如撥放影片時，顯示緩衝讀取進度，與影片撥放進度 query: 顯示兩種狀態模式，預設顯示樣式為 indeterminate反過來的樣式，值到另外一種狀態發生時，就會切換至 determinate 模式 顏色 color 參數 Primary Accent Warn Value 用來設定進度的百分比 bufferValue 用來設定 buffer模式下的緩衝進度百分比 top-menu 1234567891011&lt;md-toolbar color="primary" class="app-toolbar"&gt; &lt;button class="hamburger" [class.starting]="isStarting" md-button (click)="sidenav.toggle()" title="Docs menu"&gt; &lt;md-icon [ngClass]="&#123;'sidenav-open': !isSideBySide &#125;" svgIcon="menu"&gt;&lt;/md-icon&gt; &lt;/button&gt; &lt;a class="nav-link home" href="/"&gt;&lt;img src="&#123;&#123; homeImageUrl &#125;&#125;" title="Home" alt="Home"&gt;&lt;/a&gt; &lt;aio-top-menu *ngIf="isSideBySide" [nodes]="topMenuNodes"&gt;&lt;/aio-top-menu&gt; &lt;aio-search-box class="search-container" #searchBox (onSearch)="doSearch($event)" (onFocus)="doSearch($event)"&gt;&lt;/aio-search-box&gt;&lt;/md-toolbar&gt;&lt;aio-search-results #searchResults *ngIf="showSearchResults" (resultSelected)="hideSearchResults()"&gt;&lt;/aio-search-results&gt; &lt;md-toobar&gt; 可用來當作 headers、titles、 或 actions 的容器 可透過 color 設定背景顏色: Primary、Accent、Warn &lt;aio-top-menu&gt; 、&lt;aio-search-box&gt;、&lt;aio-search-results&gt; 皆為自訂的 component &lt;aio-search-box&gt; 的行為 onFocus: 會根據目前搜尋視窗內的值，進行搜尋的動作 onSearch: 每一次 keyUp 都會被觸發一次 content display 1234567891011121314151617&lt;md-sidenav-container class="sidenav-container" [class.starting]="isStarting" [class.has-floating-toc]="hasFloatingToc" role="main"&gt; &lt;md-sidenav [ngClass]="&#123;'collapsed': !isSideBySide &#125;" #sidenav class="sidenav" [opened]="isOpened" [mode]="mode" (open)="updateHostClasses()" (close)="updateHostClasses()"&gt; &lt;aio-nav-menu *ngIf="!isSideBySide" [nodes]="topMenuNarrowNodes" [currentNode]="currentNodes?.TopBarNarrow" [isWide]="false"&gt;&lt;/aio-nav-menu&gt; &lt;aio-nav-menu [nodes]="sideNavNodes" [currentNode]="currentNodes?.SideNav" [isWide]="isSideBySide"&gt;&lt;/aio-nav-menu&gt; &lt;div class="doc-version" title="Angular docs version &#123;&#123;currentDocVersion?.title&#125;&#125;"&gt; &lt;aio-select (change)="onDocVersionChange($event.index)" [options]="docVersions" [selected]="docVersions &amp;&amp; docVersions[0]"&gt;&lt;/aio-select&gt; &lt;/div&gt; &lt;/md-sidenav&gt; &lt;section class="sidenav-content" [id]="pageId" role="content"&gt; &lt;aio-doc-viewer [doc]="currentDocument" (docRendered)="onDocRendered()"&gt;&lt;/aio-doc-viewer&gt; &lt;aio-dt [on]="dtOn" [(doc)]="currentDocument"&gt;&lt;/aio-dt&gt; &lt;/section&gt;&lt;/md-sidenav-container&gt; &lt;md-sidenav-container&gt; 是用來包 &lt;md-sidenav&gt; 及主要顯示內容的容器 是顯示側邊選單物件 &lt;aio-nav-menu&gt;、&lt;aio-select&gt;、&lt;aio-doc-viewer&gt; 及 &lt;aio-dt&gt; 皆為自訂 component toc 123&lt;div *ngIf="hasFloatingToc" class="toc-container" [style.max-height.px]="tocMaxHeight" (mousewheel)="restrainScrolling($event)"&gt; &lt;aio-toc&gt;&lt;/aio-toc&gt;&lt;/div&gt; 針對 mousewheel 事件進行判斷，限制頁面滾動的行為 &lt;aio-toc&gt; 為自訂 component footer 123&lt;footer&gt; &lt;aio-footer [nodes]="footerNodes" [versionInfo]="versionInfo" &gt;&lt;/aio-footer&gt;&lt;/footer&gt; &lt;aio-footer&gt; 為自訂 component class AppComponent constructor 注入所需的 service DocumentService ElementRef LocationService NavigationService ScrollService SearchService SwUpdateNotificationsService TocService ngOnInit 判斷是否有支援 serviceWorker，如果有，則初始化 『search-worker』 12345 // Do not initialize the search on browsers that lack web worker supportif ('Worker' in window) &#123; this.searchService.initWorker('app/search/search-worker.js'); this.searchService.loadIndex();&#125; 調整顯示大小，並設定 &lt;md-sidenav-container&gt; 的 class.has-floating-toc 屬性 12345678910111213141516...private showFloatingToc = new BehaviorSubject(false);...ngOnInit()&#123; this.onResize(window.innerWidth); ... const hasNonEmptyToc = this.tocService.tocList.map(tocList =&gt; tocList.length &gt; 0); combineLatest(hasNonEmptyToc, this.showFloatingToc) .subscribe(([hasToc, showFloatingToc]) =&gt; this.hasFloatingToc = hasToc &amp;&amp; showFloatingToc);&#125;@HostListener('window:resize', ['$event.target.innerWidth'])onResize(width) &#123; this.isSideBySide = width &gt; this.sideBySideWidth; this.showFloatingToc.next(width &gt; this.showFloatingTocWidth);&#125; 監控並註冊目前所在的 document 123456789101112131415161718192021222324252627282930313233343536373839404142export interface DocumentContents &#123; /** The unique identifier for this document */ id: string; /** The HTML to display in the doc viewer */ contents: string;&#125;//==========================================currentDocument: DocumentContents;ngOnInit()&#123; ... this.documentService.currentDocument.subscribe(doc =&gt; &#123; this.currentDocument = doc; this.setPageId(doc.id); this.setFolderId(doc.id); this.updateHostClasses(); &#125;); ...&#125; setPageId(id: string) &#123; // Special case the home page this.pageId = (id === 'index') ? 'home' : id.replace('/', '-');&#125;setFolderId(id: string) &#123; // Special case the home page this.folderId = (id === 'index') ? 'home' : id.split('/', 1)[0];&#125;// 更新本身component的class @HostBinding('class') hostClasses = '';updateHostClasses() &#123; const sideNavOpen = `sidenav-$&#123;this.sidenav.opened ? 'open' : 'closed'&#125;`; const pageClass = `page-$&#123;this.pageId&#125;`; const folderClass = `folder-$&#123;this.folderId&#125;`; const viewClasses = Object.keys(this.currentNodes || &#123;&#125;).map(view =&gt; `view-$&#123;view&#125;`).join(' '); this.hostClasses = `$&#123;sideNavOpen&#125; $&#123;pageClass&#125; $&#123;folderClass&#125; $&#123;viewClasses&#125;`;&#125; documentService.currentDocument 12345678910 this.currentDocument = location.currentPath.switchMap(path =&gt; this.getDocument(path));private getDocument(url: string) &#123; const id = url || 'index'; this.logger.log('getting document', id); if ( !this.cache.has(id)) &#123; this.cache.set(id, this.fetchDocument(id)); &#125; return this.cache.get(id);&#125; 監控網址變化，並執行相對應的動作 123456789101112131415161718192021ngOnInit()&#123; ... this.locationService.currentPath.subscribe(path =&gt; &#123; if (path === this.currentPath) &#123; // scroll only if on same page (most likely a change to the hash) this.autoScroll(); &#125; else &#123; // don't scroll; leave that to `onDocRendered` this.currentPath = path; // Start progress bar if doc not rendered within brief time clearTimeout(this.isFetchingTimeout); this.isFetchingTimeout = setTimeout(() =&gt; this.isFetching = true, 200); &#125; &#125;); ...&#125; autoScroll() &#123; this.scrollService.scroll();&#125; 監控瀏覽的狀態，細部的功能檢視會在看 navigationService 時研究 12345678/** * A map of current nodes by view. * This is needed because some urls map to nodes in more than one view. * If a view does not contain a node that matches the current url then the value will be undefined. */export interface CurrentNodes &#123; [view: string]: CurrentNode;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// &lt;&lt;md-sidenav&gt; 物件@ViewChild(MdSidenav) sidenav: MdSidenav;currentNodes: CurrentNodes;ngOnInit()&#123; ... this.navigationService.currentNodes.subscribe(currentNodes =&gt; &#123; this.currentNodes = currentNodes; // Preserve current sidenav open state by default let openSideNav = this.sidenav.opened; // const sideNavView = 'SideNav'; const isSideNavDoc = !!currentNodes[sideNavView]; if (this.isSideNavDoc !== isSideNavDoc) &#123; // View type changed. Is it now a sidenav view (e.g, guide or tutorial)? // Open if changed to a sidenav doc; close if changed to a marketing doc. openSideNav = this.isSideNavDoc = isSideNavDoc; &#125; // May be open or closed when wide; always closed when narrow this.sideNavToggle(this.isSideBySide ? openSideNav : false); &#125;); // Compute the version picker list from the current version and the versions in the navigation map combineLatest( this.navigationService.versionInfo.map(versionInfo =&gt; (&#123; title: versionInfo.raw, url: null &#125;)), this.navigationService.navigationViews.map(views =&gt; views['docVersions']), (currentVersion, otherVersions) =&gt; [currentVersion, ...otherVersions]) .subscribe(versions =&gt; &#123; this.docVersions = versions; this.currentDocVersion = this.docVersions[0]; &#125;); this.navigationService.navigationViews.subscribe(views =&gt; &#123; this.footerNodes = views['Footer'] || []; this.sideNavNodes = views['SideNav'] || []; this.topMenuNodes = views['TopBar'] || []; this.topMenuNarrowNodes = views['TopBarNarrow'] || this.topMenuNodes; &#125;); this.navigationService.versionInfo.subscribe( vi =&gt; this.versionInfo = vi ); ...&#125; sideNavToggle(value?: boolean) &#123; this.sidenav.toggle(value); &#125; 啟動 swUpdateNotification 12345ngOnInit()&#123; ... this.swUpdateNotifications.enable(); ...&#125; onClick 1234567891011121314151617181920212223242526@HostListener('click', ['$event.target', '$event.button', '$event.ctrlKey', '$event.metaKey', '$event.altKey'])onClick(eventTarget: HTMLElement, button: number, ctrlKey: boolean, metaKey: boolean, altKey: boolean): boolean &#123; // Hide the search results if we clicked outside both the "search box" and the "search results" if (!this.searchElements.some(element =&gt; element.nativeElement.contains(eventTarget))) &#123; this.hideSearchResults(); &#125; // Show developer source view if the footer is clicked while holding the meta and alt keys if (eventTarget.tagName === 'FOOTER' &amp;&amp; metaKey &amp;&amp; altKey) &#123; this.dtOn = !this.dtOn; return false; &#125; // Deal with anchor clicks; climb DOM tree until anchor found (or null) let target = eventTarget; while (target &amp;&amp; !(target instanceof HTMLAnchorElement)) &#123; target = target.parentElement; &#125; if (target instanceof HTMLAnchorElement) &#123; return this.locationService.handleAnchorClick(target, button, ctrlKey, metaKey); &#125; // Allow the click to pass through return true;&#125; 監聽頁面上所有的 click事件 如果在 search box 外的地方點擊，會把搜尋結果的區塊隱藏起來。 win+alt+click on footer (1)的地方，會切換顯示/隱藏頁面內容的原始碼(2) 處理連結錨點 onDocRendered 123456789101112131415onDocRendered() &#123; // Stop fetching timeout (which, when render is fast, means progress bar never shown) clearTimeout(this.isFetchingTimeout); // Put page in a clean visual state this.scrollService.scrollToTop(); // Scroll 500ms after the doc-viewer has finished rendering the new doc // The delay is to allow time for async layout to complete setTimeout(() =&gt; &#123; this.autoScroll(); this.isStarting = false; this.isFetching = false; &#125;, 500);&#125; 觸發時機點是在&lt;aio-doc-viewer&gt;的 docRendered output 事件 1&lt;aio-doc-viewer [doc]="currentDocument" (docRendered)="onDocRendered()"&gt;&lt;/aio-doc-viewer&gt; onDocVersionChange 123456onDocVersionChange(versionIndex: number) &#123; const version = this.docVersions[versionIndex]; if (version.url) &#123; this.locationService.go(version.url); &#125;&#125; 觸發時機點是在&lt;aio-select&gt;下拉選單選擇完後 1&lt;aio-select (change)="onDocVersionChange($event.index)" [options]="docVersions" [selected]="docVersions &amp;&amp; docVersions[0]"&gt;&lt;/aio-select&gt; onScroll 根據滾動的狀態，決定 ToC 的高度 1234567891011121314// Dynamically change height of table of contents container@HostListener('window:scroll')onScroll() &#123; if (!this.tocMaxHeightOffset) &#123; // Must wait until now for md-toolbar to be measurable. const el = this.hostElement.nativeElement as Element; this.tocMaxHeightOffset = el.querySelector('footer').clientHeight + el.querySelector('md-toolbar.app-toolbar').clientHeight + 44; // margin &#125; this.tocMaxHeight = (document.body.scrollHeight - window.pageYOffset - this.tocMaxHeightOffset).toFixed(2);&#125; 123&lt;div *ngIf="hasFloatingToc" class="toc-container" [style.max-height.px]="tocMaxHeight"...&gt; &lt;aio-toc&gt;&lt;/aio-toc&gt;&lt;/div restrainScrolling 限制滑鼠滾輪在 ToC 範圍內的滾動頁面的功能 123456789101112131415161718// Restrain scrolling inside an element, when the cursor is over it restrainScrolling(evt: WheelEvent) &#123; const elem = evt.currentTarget as Element; const scrollTop = elem.scrollTop; if (evt.deltaY &lt; 0) &#123; // Trying to scroll up: Prevent scrolling if already at the top. if (scrollTop &lt; 1) &#123; evt.preventDefault(); &#125; &#125; else &#123; // Trying to scroll down: Prevent scrolling if already at the bottom. const maxScrollTop = elem.scrollHeight - elem.clientHeight; if (maxScrollTop - scrollTop &lt; 1) &#123; evt.preventDefault(); &#125; &#125; &#125; 123&lt;div *ngIf="hasFloatingToc" class="toc-container" ... (mousewheel)="restrainScrolling($event)"&gt; &lt;aio-toc&gt;&lt;/aio-toc&gt;&lt;/div&gt; onKeyUp 使用鍵盤控制頁面功能 使用 / 進入 searchbox 使用 ESC 取消搜尋結果，並重新將焦點設定於 searchbox上 1234567891011121314@HostListener('document:keyup', ['$event.key', '$event.which'])onKeyUp(key: string, keyCode: number) &#123; // forward slash "/" if (key === '/' || keyCode === 191) &#123; this.focusSearchBox(); &#125; if (key === 'Escape' || keyCode === 27 ) &#123; // escape key if (this.showSearchResults) &#123; this.hideSearchResults(); this.focusSearchBox(); &#125; &#125;&#125; 筆記 有很多事件都被註冊於 app.component 內，主要的原因是 app.component 為 root component ，除非把網頁關掉，否哲永遠不會被摧毀掉。 services 與 component 之間的溝通，大多數都使用 RxJS 的 Subject 作為溝通的橋樑，這樣子 component 或是其他 child component 都可以被通知有資料異動 HostListener 善用第二個參數，只取出需要的屬性即可，即可將程式碼的可讀性大幅的提升 適當的使用 get 寫法，簡化變數的長度或將判斷邏輯封裝 商業邏輯的部分盡量封裝到 service 內 顯示區塊拆成子 component ，透過 @Input、@Output、services 的方式做溝通 ViewChildren的 selector 可以同時撈取多格範本變數(Template Reference Variable) 12@ViewChildren('searchBox, searchResults', &#123;read: ElementRef&#125;)searchElements: QueryList&lt;ElementRef&gt;; ​ 參考資料 NgModuleRef ApplicationRef material2]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Dependency Injection]]></title>
    <url>%2F2017%2F06%2F13%2Fdotnetcore-dependency-injection%2F</url>
    <content type="text"><![CDATA[.NET Core web 專案, a.k.a ASP.NET Core, 內建了 Dependency Injection 機制，不需要再另外安裝套件才可使用 DI 了。事實上，.NET Core的專案要擴充功能，也都是利用 DI 來新增至系統內。例如 .AddMvc() 內建服務 初始時，就已經有以下的服務 ASP.NET 也內建許多服務，像是 MVC, EntityFramework，而這一類的新增方式是透過 AddServiceName 的模式新增至 IServiceCollection 中。 1234567891011121314// This method gets called by the runtime. Use this method to add services to the container.public void ConfigureServices(IServiceCollection services)&#123; // Add framework services. services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;() .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;() .AddDefaultTokenProviders(); services.AddMvc();&#125; 註冊服務 當自己所開發的功能想要註冊系統內，也需要走一樣的路徑。是需要被加到 ServiceCollection 內。但根據生命週期的差異，所使用的註冊方式也會有所不一樣 AddTransient Transient : 服務在每次被執行時，都會建立一個新的執行實體。這模式很適合 lightweight、stateless的服務。 1services.AddTransient&lt;IOperationTransient, Operation&gt;(); AddScoped Scoped : 服務會在被要求時建立一次，而在這次要求期間，服務不論執行幾次，都不會再次被重新建立。 1services.AddScoped&lt;IOperationScoped, Operation&gt;(); AddSingleton Singleton 會在第一次呼叫時被建立或是在 ConfigureServies 內被執行，之後程序如果有執行到這一個服務時，基本上都是使用相同的實體 12services.AddSingleton&lt;IOperationSingleton, Operation&gt;();services.AddSingleton&lt;IOperationSingletonInstance&gt;(new Operation(Guid.Empty)); // 立即執行 參考資料 Dependency Injection]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] 加入設定參數]]></title>
    <url>%2F2017%2F06%2F11%2Fcore-configuration%2F</url>
    <content type="text"><![CDATA[.NET Core 提供多種參數設定資料的來源，例如: Json 檔案、ini 檔案或使用 Azure 的 KeyValue 設定檔。雖然預設啟動的 web 環境，已經有載入 appsetting.json 及 appsettings.[environment].json 設定檔，但是如果要自行設定，或是其他 Controller 要使用參數設定，又該怎麼處理呢? Startup.cs 設定檔可以透過 ConfigurationBuilder建立，以下為簡單的基本架構 123456789101112public class Startup&#123; public IConfigurationRoot Configuration &#123; get; set; &#125; public Startup(IHostingEnvironment env) &#123; var builder = new ConfigurationBuilder() .SetBasePath(env.ContentRootPath) .AddJsonFile("appsettings.json", optional: true); Configuration = builder.Build(); &#125;&#125; 如 這篇筆記，在 constructor 可以取得 IHostingEnvironment 的服務，這個 env 提供了目前程式系統的基本環境，例如根目錄的資訊 ConfigurationBuilder 提供多種設定檔來源的選擇 Add 新增符合 IConfigurationSource 格式的自訂設定檔 AddAzureKeyValue 使用 Azure KeyValue 服務，作為參數設定檔的資料來源，基本程式架構如下 1234builder.AddAzureKeyVault( $"https://&#123;Vault&#125;.vault.azure.net/", "ClientId", "ClientSecret"); AddAzurekeyValue 也提供 IKeyVaultSecretManager ，實作方式範本如下 12345678910111213141516171819public class EnvironmentSecretManager : IKeyVaultSecretManager&#123; private readonly string _appNamePrefix; public EnvironmentSecretManager(string appName) &#123; _appNamePrefix = appName + "-"; &#125; public bool Load(SecretItem secret) &#123; return secret.Identifier.Name.StartsWith(_appNamePrefix); &#125; public string GetKey(SecretBundle secret) &#123; return secret.SecretIdentifier.Name.Substring(_appNamePrefix.Length); &#125;&#125; 12345builder.AddAzureKeyVault( $"https://&#123;config["Vault"]&#125;.vault.azure.net/", config["ClientId"], config["ClientSecret"], new EnvironmentSecretManager(env.ApplicationName)); AddCommandLine 利用 command line 的方式，將參數設定值，傳入至系統內 123public static IConfigurationBuilder AddCommandLine( this IConfigurationBuilder configurationBuilder, string[] args, IDictionary&lt;string, string&gt; switchMappings); 123456789101112131415161718192021222324public static Dictionary&lt;string, string&gt; GetSwitchMappings( IReadOnlyDictionary&lt;string, string&gt; configurationStrings) &#123; return configurationStrings.Select(item =&gt; new KeyValuePair&lt;string, string&gt;( "-" + item.Key.Substring(item.Key.LastIndexOf(':') + 1), item.Key)) .ToDictionary( item =&gt; item.Key, item =&gt; item.Value); &#125; public static void Main(string[] args = null) &#123; var dict = new Dictionary&lt;string, string&gt; &#123; &#123;"Profile:MachineName", "Rick"&#125;, &#123;"App:MainWindow:Left", "11"&#125; &#125;; var builder = new ConfigurationBuilder(); builder.AddInMemoryCollection(dict) .AddCommandLine(args, GetSwitchMappings(dict)); Configuration = builder.Build(); ... &#125; 1dotnet run /Profile:MachineName=Bob /App:MainWindow:Left=1234 AddCommandLine 也可以搭配 AddInMemoryCollection 一起使用，如上述的程式碼 AddDockerSecrets 使用 Docker Secrets 作為參數設定檔的資料來源 12var builder = new ConfigurationBuilder() .AddDockerSecrets() AddEnvironmentVariables 使用系統環境變數作為參數設定檔的資料來源 12var builder = new ConfigurationBuilder() .AddEnvironmentVariables(); AddIniFile 使用 ini 檔案作為參數設定檔的資料來源 123var builder = new ConfigurationBuilder() .SetBasePath(env.ContentRootPath) .AddJsonFile("appsettings.ini", optional: true); AddInMemoryCollection 使用自訂的 Dictionary 作為參數設定檔的資料來源 12345678var dict = new Dictionary&lt;string, string&gt; &#123; &#123;"Profile:MachineName", "Rick"&#125;, &#123;"App:MainWindow:Left", "11"&#125; &#125;;var builder = new ConfigurationBuilder() .AddInMemoryCollection(dict) AddJsonFile 使用 Json 檔案作為參數設定檔的資料來源 123var builder = new ConfigurationBuilder() .SetBasePath(env.ContentRootPath) .AddJsonFile("appsettings.json", optional: true); AddUserSecrets 使用UserSecrets作為參數設定檔的資料來源，這一個檔案並不會存在於專案資訊裡，實際的檔案會存放在於開發者的電腦內，故這個功能在預設模式下，只有處於開發模式下才會被開啟。 12var builder = new ConfigurationBuilder() .AddUserSecrets&lt;Startup&gt;(); 至於他的實際的存放位置是在哪裡，在 專案.csproj 裡會存放一組 UserSecretsId ，這組 ID 會是資料夾的名稱 AddXmlFile 使用 xml 檔案作為參數設定檔的資料來源 123var builder = new ConfigurationBuilder() .SetBasePath(env.ContentRootPath) .AddJsonFile("appsettings.xml", optional: true); 註冊至Service內 將 Configuration 加入到 service 內 1234public void ConfigureServices(IServiceCollection services)&#123; services.Configure&lt;MyOptions&gt;(Configuration);&#125; MyOptions 是 Configuration 的格式定義 使用方式如下，在 Controller 的地方，利用 IOptions 的方式取得在 Startup.cs 內加入至 services 內的設定檔 12345678910111213private MyOptions _myOptions = null;public HomeController(IOptions&lt;MyOptions&gt; options)&#123; this._myOptions = options.Value;&#125;public IActionResult Index()&#123; string option1 = this._myOptions.Option1; int Option2 = this._myOptions.Option2; ...&#125; Recap .NET Core 提供很多種方式可以取得或是設定設定檔，其他地方如果要使用，是透過注入的方式取得，這樣子的模式，在管理設定檔上，就變得非常有彈性了。 參考資料 Azure Key Vault configuration provider Configuration Accessing Docker Swarm Secrets from ASP.NET Core Creating a custom ConfigurationProvider in ASP.NET Core to parse YAML]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Animation 4.2版 = wow]]></title>
    <url>%2F2017%2F06%2F11%2Fng-animation-4-2%2F</url>
    <content type="text"><![CDATA[Animation 在 4.2 版以後，整個功能強度往上跳了好幾級，我對 Animation 本身真的沒什麼研究，但是還是盡量整理了一下，新增的功能有哪些(目前尚無完整的文件) 新增功能 Animation在 4.2 版以後有增加了許多功能，以下一一的整理，如果有遺漏或是不正確的地方，還請指教 animation animation 方法讓我們可以使用包裝動畫效果，也可使用變數來當作動畫的參數範本。範例程式碼 1export declare function animation(steps: AnimationMetadata | AnimationMetadata[], options?: AnimationOptions | null): AnimationReferenceMetadata; 1234567891011export let flyIn = animation( [ ... group([ animate( '0.3s 0.1s ease', style(&#123;transform: 'translateX(0px)', width: '&#123;&#123;width&#125;&#125;px'&#125;)), animate('0.3s ease', style(&#123;opacity: 1&#125;)) ]) ], &#123;params: &#123;width: 120&#125;&#125;); 透過上述的方式，可以將 animation 單獨的抽離至新檔案，也可以給予參數的能力，如果使用這個 animation 的當下如設定任何參數時，就會使用預設值。 useAnimation 如果要使用單獨抽離的 animation 時，可以使用 useAnimation ，第一個參數是要使用的 animation 名稱，如果使用的 animation 允使使用參數來改變內建的變數，那就可以設定於第二個參數位置 1export declare function useAnimation(animation: AnimationReferenceMetadata, options?: AnimationOptions | null): AnimationAnimateRefMetadata; 123456789import &#123;flyIn&#125; from './my-animation';... animations: [trigger( 'heroState', [ ... transition('void =&gt; *', [useAnimation(flyIn, &#123;params: &#123;width: 100&#125;&#125;)]), ... ])] query 這也是另外一個強大的新功能，這功能允許使用類似 jquery 的 query 功能，透過這個可以快速地針對特定的 HTMLElement 加上動畫 123456789101112131415animations: [trigger( 'flyInOut', [ ... transition(':enter', [group([ useAnimation(flyIn, &#123;params: &#123;width: 100&#125;&#125;), query('p', [ style(&#123; opacity: 0 &#125;), animate(4000, style(&#123; opacity: 1 &#125;)) ]) ]) ]) ... ])] 12345&lt;ul&gt; &lt;li *ngFor="let hero of heroes" [@flyInOut]="'in'"&gt; &lt;p&gt;&#123;&#123;hero.name&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; animateChild animateChild 搭配 query 的使用，可以觸發內層元件的動畫事件。 12345678910111213141516171819202122232425@Component(&#123; selector: 'parent-child-component', animations: [ trigger('parentAnimation', [ transition('false =&gt; true', [ query('header', [ style(&#123; opacity: 0 &#125;), animate(500, style(&#123; opacity: 1 &#125;)) ]), query('@childAnimation', [ animateChild() ]) ]) ]), trigger('childAnimation', [ transition('false =&gt; true', [ style(&#123; opacity: 0 &#125;), animate(500, style(&#123; opacity: 1 &#125;)) ]) ]) ]&#125;)class ParentChildCmp &#123; exp: boolean = false;&#125; 123456789101112&lt;div [@parentAnimation]="exp"&gt; &lt;header&gt;Hello&lt;/header&gt; &lt;div [@childAnimation]="exp"&gt; one &lt;/div&gt; &lt;div [@childAnimation]="exp"&gt; two &lt;/div&gt; &lt;div [@childAnimation]="exp"&gt; three &lt;/div&gt;&lt;/div&gt; stagger stagger 這個方法可以去設定再跑 ngFor 時，可以讓動畫一筆一筆的跑，這方法需要再 query 內使用 1export declare function stagger(timings: string | number, animation: AnimationMetadata | AnimationMetadata[]): AnimationStaggerMetadata; 1234567891011121314151617181920212223242526272829303132333435@Component(&#123; templateUrl: 'list.component.html', animations: [ trigger('listAnimation', [ transition('* =&gt; *', [ // each time the binding value changes query(':leave', [ stagger(100, [ animate('0.5s', style(&#123; opacity: 0 &#125;)) ], &#123;optional: true&#125;) ]), query(':enter', [ style(&#123; opacity: 0 &#125;), stagger(100, [ animate('0.5s', style(&#123; opacity: 1 &#125;)) ], &#123;optional: true&#125;) ]) ]) ]) ] &#125;) class ListComponent &#123; items = []; showItems() &#123; this.items = [0,1,2,3,4]; &#125; hideItems() &#123; this.items = []; &#125; toggle() &#123; this.items.length ? this.hideItems() : this.showItems(); &#125; &#125; 1234567&lt;button (click)="toggle()"&gt;Show / Hide Items&lt;/button&gt; &lt;hr /&gt; &lt;div [@listAnimation]="items.length"&gt; &lt;div *ngFor="let item of items"&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt;&lt;/div&gt; AnimationBuilder AnimationBuilder 的 build 方法會產生一個 AnimationFactory，而 AnimationFactory 的 create 方法可以產生一個 AnimationPlayer，這個 AnimationPlayer 是可以被撥放，暫停或停止。這模式可以讓我們用程式碼的方式，建立與 decorator 內 animations 區塊相同功能出來，且可以手動控制執行動畫的時間點。 1234567891011121314...export class HeroListComponent &#123; constructor(private _builder: AnimationBuilder) &#123;&#125; ... makeAnimation(element: any) &#123; // first build the animation const myAnimation = this._builder.build( [style(&#123;opacity: 0&#125;), animate('0.3s 0.2s ease', style(&#123;opacity: 1&#125;))]); // then create a player from it const player = myAnimation.create(element); player.play(); &#125;&#125; 總結 Angular 4.2 版大大的加強 animation 的功能，或許還有些新功能我沒有注意到，但是上述的這些新用法，就已經足以玩出很多種變化。 尤其是讓動畫的效果可以重複使用，對於前端設計者，就可以專注於動畫的設計，而其他對於 animation 不熟悉的人，也可以簡單的使用已經設計好的動畫效果。 非常期待一些大師發布 angular animation 作品，可以讓我們簡單的使用設計好的動畫效果。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 開發 Excel 增益集]]></title>
    <url>%2F2017%2F05%2F28%2Fangular-excel-addins%2F</url>
    <content type="text"><![CDATA[Office 2016 的增益集，讓我們可以使用 javascript + html 來開發。既然可以使用 Jquery，那 Angular 應該是沒有問題的，這是使用 Angular 實作 Excel 增益集的筆記 建立 Angular 專案 使用 Angular CLI 建立新專案，如果有需要使用路由的，記得要將 LocationStrategy 設定為 HashLocationStrategy 安裝 @types npm install --save-dev @types/office-js tsconfig.app.json 在 types 的的區塊加上 office-js 123"types": [ "office-js"] main.ts 1234567891011import &#123;enableProdMode&#125; from '@angular/core';import &#123;platformBrowserDynamic&#125; from '@angular/platform-browser-dynamic';import &#123;AppModule&#125; from './app/app.module';import &#123;environment&#125; from './environments/environment';declare const Office: any;Office.initialize = function() &#123; platformBrowserDynamic().bootstrapModule(AppModule);&#125;; platformBrowser 這段一定要包在 function() {…} 裡面。 index.html 1234567... &lt;script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.4.min.js"&gt;&lt;/script&gt;&lt;script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"&gt;&lt;/script&gt;&lt;link rel="stylesheet" href="https://appsforoffice.microsoft.com/fabric/1.0/fabric.min.css"&gt;&lt;link rel="stylesheet" href="https://appsforoffice.microsoft.com/fabric/1.0/fabric.components.min.css"&gt;... 新增這四行到 &lt;head&gt; 內 app.component.ts 這裡的程式，我是先用官方提供的範例翻寫的。詳細的 API 部分，請參閱官方文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import 'rxjs/add/observable/from';import 'rxjs/add/operator/map';import 'rxjs/add/operator/mergeMap';import &#123;ApplicationRef, Component&#125; from '@angular/core';import &#123;Http, Response&#125; from '@angular/http';import &#123;Observable&#125; from 'rxjs/Observable';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; title = '用Angular寫Excel Addin!!'; data = []; constructor(private appRef: ApplicationRef, private http: Http) &#123;&#125; loadData() &#123; return this.http.get('https://jsonplaceholder.typicode.com/posts') .map((res: Response) =&gt; res.json()); &#125; clickMe() &#123; // Run a batch operation against the Excel object model this.loadData() .mergeMap( (data: any[]) =&gt; &#123;return Observable.from(Excel.run((ctx) =&gt; &#123; // Create a proxy object for the active worksheet const sheet: Excel.Worksheet = ctx.workbook.worksheets.getActiveWorksheet(); sheet.getRange().clear(); // sheet.charts.items.forEach(c =&gt; c.delete()); if (sheet) &#123; // Queue commands to set the report title in the worksheet sheet.getRange('A1').values = [['Quarterly Sales Report']]; sheet.getRange('A1').format.font.name = 'Century'; sheet.getRange('A1').format.font.size = 26; &#125; // Create an array containing sample data let values = [ ['Product', 'Qtr1', 'Qtr2', 'Qtr3', 'Qtr4'], ['Frames', 5000, 7000, 6544, 4377], ['Saddles', 400, 323, 276, 651], ['Brake levers', 12000, 8766, 8456, 9812], ['Chains', 1550, 1088, 692, 853], ['Mirrors', 225, 600, 923, 544], ['Spokes', 6005, 7634, 4589, 8765] ]; // Queue a command to write the sample data to the specified // range in the worksheet and bold the header row const range = sheet.getRange('A2:E8'); range.values = values; sheet.getRange('A2:E2').format.font.bold = true; // Queue a command to add a new chart const chart = sheet.charts.add('ColumnClustered', range, 'auto'); // Queue commands to set the properties and format the chart chart.setPosition('G1', 'L10'); chart.title.text = 'Quarterly sales chart'; chart.legend.position = 'right' chart.legend.format.fill.setSolidColor('white'); chart.dataLabels.format.font.size = 15; chart.dataLabels.format.font.color = 'black'; const points = chart.series.getItemAt(0).points; points.getItemAt(0).format.fill.setSolidColor('pink'); points.getItemAt(1).format.fill.setSolidColor('indigo'); const i = 12; this.data = data; values = data.reduce((preValue, d) =&gt; &#123; return [...preValue, [d.userId, d.id, d.title, d.body]]; &#125;, []); sheet.getRange(`A$&#123;i + 1&#125;:D$&#123;i + data.length&#125;`).values = values; // Run the queued commands, and return a promise to indicate // task completion return ctx.sync(); &#125;))&#125;) .subscribe( () =&gt; &#123; this.appRef.tick(); console.log('Success!'); &#125;, error =&gt; &#123; &#125;); &#125;&#125; 程式碼解釋 loadData() 這個 method 主要是用來驗證 CORS 的情況下， 是否還可以在 Excel 裡正常的運作。 Excel.run Ｅxcel.run((ctx) =&gt; { … }) 這段是準備要在Excel上顯示的資料 ctx.sync() 準備好的內容，更新同步到 Excel 的 activateSheet 上 polyfills.ts 需要打開以下的檔案 123456789101112131415/** IE9, IE10 and IE11 requires all of the following polyfills. **/import 'core-js/es6/symbol';import 'core-js/es6/object';import 'core-js/es6/function';import 'core-js/es6/parse-int';import 'core-js/es6/parse-float';import 'core-js/es6/number';import 'core-js/es6/math';import 'core-js/es6/string';import 'core-js/es6/date';import 'core-js/es6/array';import 'core-js/es6/regexp';import 'core-js/es6/map';import 'core-js/es6/weak-map';import 'core-js/es6/set'; 到這邊為止，已經完成了 Angular 端最基本的環境設定 新增 Manifest.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--Created:cb85b80c-f585-40ff-8bfc-12ff4d0e34a9--&gt; &lt;OfficeApp xmlns="http://schemas.microsoft.com/office/appforoffice/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="TaskPaneApp"&gt; &lt;Id&gt;534a9c82-e492-4b03-a0df-7e6e97815039&lt;/Id&gt; &lt;Version&gt;1.0.0.0&lt;/Version&gt; &lt;ProviderName&gt;Microsoft&lt;/ProviderName&gt; &lt;DefaultLocale&gt;en-US&lt;/DefaultLocale&gt; &lt;DisplayName DefaultValue="Angular App Sample" /&gt; &lt;Description DefaultValue="Angular App Sample"/&gt; &lt;Capabilities&gt; &lt;Capability Name="Workbook" /&gt; &lt;/Capabilities&gt; &lt;DefaultSettings&gt; &lt;SourceLocation DefaultValue="https://localhost:4200" /&gt; &lt;/DefaultSettings&gt; &lt;Permissions&gt;ReadWriteDocument&lt;/Permissions&gt; &lt;/OfficeApp&gt; Manifest 的進階說明，請參閱這篇文件 Excel 的環境設定 要在 Excel 內新增我們自己開發的增益集，首先 建立一個分享資料夾 將設定好的 Manifest.xml 搬進去，記得每一個增益集的 manifest 檔名都要不一樣 將分享資料夾的位置新增到 Excel 裡面去 檔案 --&gt; 選項 信任中心 受信任的增益集目錄 確定完成 插入 -&gt; 我的增益集 -&gt; 共享資料夾 可以看到自己寫的增益集了 選擇要安裝的增益集 安裝完成後，即可看到所建立的增益集畫面在螢幕的右側出現 這時右側的操作，就可以直接反應在左側 Excel 工作表內了。 Debug 請參閱這篇文章，在 windows 內提供 F12 開發者工具可以做 Add In 的網頁除錯，但目前看起來是 Windows 10 限定 參閱資料 Manifest Tips for creating Office Add-ins with Angular 2 Excel JavaScript API programming overview Build your first Excel add-in Office Add-ins XML manifest Debug add-ins using F12 developer tools on Windows 10]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] Web MVC 001 - program.cs]]></title>
    <url>%2F2017%2F05%2F15%2Fcore-web-mvc-001%2F</url>
    <content type="text"><![CDATA[.NET Core 的專案的底層，都是從 Console Program 開始的。就稍微比較一下透過 dotnet cli 所產生的 console program 和 empty web program 的檔案差異。 檔案差異 Program.cs Console 123456789101112using System;namespace study_001&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Hello World"); &#125; &#125;&#125; Web 123456789101112131415161718using System;... namespace study_002&#123; public class Program &#123; public static void Main(string[] args) &#123; BuildWebHost(args).Run(); &#125; public static IWebHost BuildWebHost(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;() .Build(); &#125;&#125; 差異 Console 與 Web 專案架構基本上是一樣的，唯一有差異的是，Web 專案需要跑 WebHost Builder 來建立網站。 .csproj Console 123456&lt;Project Sdk="Microsoft.NET.Sdk"&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; Web 12345678910111213141516&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt; &lt;UserSecretsId&gt;aspnet-study_002-741020AF-3B35-4E03-A07A-E2EFF47D6CCA&lt;/UserSecretsId&gt; &lt;/PropertyGroup&gt; &lt;ItemGroup&gt; &lt;Folder Include="wwwroot\" /&gt; &lt;/ItemGroup&gt; &lt;ItemGroup&gt; &lt;PackageReference Include="Microsoft.AspNetCore.All" Version="2.0.0-preview1-final" /&gt; &lt;/ItemGroup&gt;&lt;/Project&gt; 差異 web 專案多包含了一個 wwwroot 資料夾，及 Microsoft.AspNetCore.All 的 package。 建立WebHost WebHost 透過 WebHost.CreateDefaultBuilder 建立一個 Microsoft.AspNetCore.Hosting.IWebHost 並在 Main 下執行 CreateDefaultBuilder 執行CreateDefaultBuilder(args) 時， WebHostBuilder 會有以下的預設值 使用 Kestrel 為網站伺服器 跟目錄為目前所在的資料夾位置 預設載入 appsetting.json 及 appsettings.[environment].json 設定檔 如果是開發模式時，會載入 User Secrets 使用環境變數 (environment variables) 接受從命令列傳入的參數 當做 logging 時，會輸出到 console 跟 debug output 開啟 IISIntegration 如果是開發模式，新增例外狀況頁面 UseStartup UseStartUp 是 IWebHostBuilder 的擴充功能，接受一個 AssemblyName 並使用 IWebHostBuilder 內部的 UseSetting 的方法新增或更新 _config 裡鍵值為WebHostDefaults.ApplicationKey 與 WebHostDefaults.StartupAssemblyKey 下，_config為一個 IConfiguration 物件。建立程式碼如下，僅供參考使用 123456789101112private IConfiguration _config;_config = new ConfigurationBuilder() .AddEnvironmentVariables(prefix: "ASPNETCORE_") .Build();...public IWebHostBuilder UseSetting(string key, string value)&#123; _config[key] = value; return this;&#125; build 建立 WebHost 物件 Startup Startup 用來設定網站會使用到的 service，參數、middleware 等。基本上都在這支程式內搞定 ConfigureServices 設定有哪些服務可以使用 12345678910111213141516public void ConfigureServices(IServiceCollection services)&#123; // Add framework services. services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;() .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;() .AddDefaultTokenProviders(); services.AddMvc(); // Add application services. services.AddTransient&lt;IEmailSender, AuthMessageSender&gt;(); services.AddTransient&lt;ISmsSender, AuthMessageSender&gt;();&#125; ConfigureServices不一定要存在，如果有，他會在 Configure前被執行 如果要設定 Configuration options，需要在此設定 使用的服務需要設定時，可透過IServiceCollection的 Add[Service] 的方式註冊 如上述範例為註冊 Entity Framework、Identity、MVC DI 也會在 ConfigureServices裡設定 Configure 設定使用哪些服務 123456789101112131415161718192021222324252627public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&#123; loggerFactory.AddConsole(Configuration.GetSection("Logging")); loggerFactory.AddDebug(); if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage(); app.UseBrowserLink(); &#125; else &#123; app.UseExceptionHandler("/Home/Error"); &#125; app.UseStaticFiles(); app.UseIdentity(); app.UseMvc(routes =&gt; &#123; routes.MapRoute( name: "default", template: "&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"); &#125;);&#125; Congiure 是用來設定 ASP.NET 應用程式會對請求，透過 middleware 組合的方式，做出一系列的動作與回應。 middleware 物件使用 Use 的方法，將物件家到在 IApplicationBuilder 上 初始服務 在一開始就有一些初始服務的存在，分別為 constructor: IHostingEnvironment，ILoggerFactory ConfigureServices: IServiceCollecton Configure: IApplicationBuilder、IHostingEnvironment、ILoggerFactory、IApplicationLifetime Empty Web Template 的 startup.cs 12345678910111213141516171819public class Startup &#123; public void ConfigureServices(IServiceCollection services) &#123; &#125; public void Configure(IApplicationBuilder app, IHostingEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.Run(async (context) =&gt; &#123; await context.Response.WriteAsync("Hello World!"); &#125;); &#125; &#125; 在初始的專案範本裡，只有在 Configure 的地方寫了兩個功能 注入 IApplicationHilder 與 IHostingEnvironment 兩個服務 判斷如在開發模式下，新增顯示開發者例外狀況頁面功能 回傳 「Hello World!」 的文字給畫面顯示 回顧 Web 應用程式也是 Console 程式 使用 IWebHostBuilder 的方式建立一個 WebHost 並將其執行起來，就可將 Console 程式變成一個網頁伺服器 可透過 Startup.cs 的方式設定 WebHost 所有的 Dependency Injection 需要在 Startup.cs 檔案內的 ConfigureServices 方法做註冊動作 .NET Core Web 是使用 middleware 的方式來設定網站會如何對連線請求做回應 在 Configure 方法內做 middleware 的順序及相關功能設定 參考資料 WebHost - CreateDefaultBuilder WebHostBuilder WbeHostBuilderExtensions - UseStartup WebHost Startup Class]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>Core MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[.NET Core] DotNet Core 基本環境設定]]></title>
    <url>%2F2017%2F05%2F14%2Fcore-environment-setup%2F</url>
    <content type="text"><![CDATA[.NET Core 在近期發布了 2.0 preview，看起來離 2.0 的正式發表也不遠了。是時候可以出手學習一下 .NET Core 這一新架構，但在正式學習之前，還是得把環境設定好。 .NET Core 是一個可跨平台的架構，所以在 windows 或是 mac 甚至 Ubuntu 上都可以做開發，微軟講好久的跨平台的口號，終於實踐啦。 開發 .NET Core 的方式基本上有兩種 使用 IDE windows版本，直接上 visual studio 2017 mac 版本，可以使用 visual studio for mac Jetbrains Rider 使用 CLI + Visual Studio Core CLI on GitHub 穩定版 安裝步驟不難，把安裝下載下來，執行安裝，完成後即可。之後的學習筆記將會以 CLI 的方式進行。 建立第一個專案 當 CLI 安裝完成後，可以使用 dotnet --info 的方式得知目前所安裝的版本資訊 dotnet --help 可以知道有那些指令可以使用 建立新專案 CLI 建立專案的順序是 建立一個新的專案用的資料夾 進入開資料夾 執行 dotnet new [專案類型] 完成 在 步驟 3 所提到的專案類型，可以利用 dotnet new的指令查詢 這裡可以看到，CLI 提供了一些初始範本可以使用。因為我們要從頭開始學習，所以預設先由最單純的 Console Application 開始 專案的檔案結構 programs.cs 是專案的進入點 123456789101112using System;namespace study_001&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Hello World!"); &#125; &#125;&#125; xxx.csproj 是專案檔，用來管理該專案的狀態，例如 package 的使用等 12345678&lt;Project Sdk="Microsoft.NET.Sdk"&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 執行 透過 CLI 將 .NET Core 的程式執行起來，可以下 dotnet run 就可以執行了。 建置 指令 dotnet build 會將程式建置為一個 dll 檔案，並放在 bin 的資料夾下 執行該 dll 的方式，執行 dotnet xxx.dll Recap dotnet --help 查詢可使用的指令 dotnet --info 查詢目前 CLI 版本 dotnet new &lt;template&gt; 建立範本專案 dotnet restore 恢復安裝 packages dotnet run 執行專案程式 dotnet build 建置專案 dotnet &lt;xxx&gt;.dll 執行建置後的 dll 檔案]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Pipe]]></title>
    <url>%2F2017%2F05%2F13%2Fangular-pipe%2F</url>
    <content type="text"><![CDATA[Angular Pipe 是一個很強大的資料顯示轉型的工具，可以透過 Pipe 的幫忙，將原始資料轉換成我們想要顯示的樣式，且不會異動到原始資料的內容。 Angular 有內建了一些 Pipe 像是 DatePipe、 UpperCasePipe、LowerCasePipe、 CurrencyPipe 和 PercentPipe及其他的 Pipe。當然 Angular 也允許讓我們自訂 Pipe 的功能。 先從內建的 Pipe 介紹起 內建 Pipe 在詳細介紹內建 Pipe之前，有一點要注意的是，如果有使用到 DatePipe 和 CurrencyPipe 時，要在舊版瀏覽器上正常運作的話，需要額外再加上一個 polyfill 的 library 1&lt;script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en"&gt;&lt;/script&gt; DatePipe 功能 將日期根據當地的顯示規則顯示 使用方式 date_expression | date[:format] 說明 date_expression 必須是日期型別的物件或是數字(milliseconds) 或是 ISO文字 format 可以用來調整要顯示的日期格式，可以使用的格式說明如下 'short': 相當於 'yMdjm' (例如 9/3/2010, 12:05 PM for en-US) 'medium': 相當於 'yMMMdjms' (例如 Sep 3, 2010, 12:05:08 PM for en-US) long: 相當於 MMMM d, y, h:mm:ss a z (例如 June 15, 2015 at 9:03:01 AM GMT+1) 'full': 相當於 'EEEE, MMMM d, y, h:mm:ss a zzzz' (例如 Monday, June 15, 2015 at 9:03:01 AM GMT+01:00) 'fullDate': 相當於 'yMMMMEEEEd' (例如 Friday, September 3, 2010 for en-US) 'shortDate': 相當於 'yMd' (例如 9/3/2010 for en-US) 'longDate': 相當於 'yMMMMd' (例如 September 3, 2010 for en-US) 'mediumDate': 相當於 'yMMMd' (例如 Sep 3, 2010 for en-US) 'fullDate': 相當於 'EEEE, MMMM d, y' (例如 Monday, June 15, 2015) 'shortTime': 相當於 'jm' (例如 12:05 PM for en-US) 'mediumTime': 相當於 jms' (例如 12:05:08 PM for en-US) 'longTime': 相當於 'h:mm:ss a z' (例如 9:03:01 AM GMT+1) 'fullTime': 相當於 'h:mm:ss a zzzz' (例如 9:03:01 AM GMT+01:00) 描述 符號 短表示 長表示 數值 2位數 ear G GGG(AD) GGGG(Anno Domini) year y y(2015) yy(15) month M MMM(Sep) MMMM(September) M(9) MM(09) day d d(3) dd(03) weekday E EEE(Sun) EEEE(Sunday) hour j j(13) jj(13) hour12 h h(1 PM) hh(01 PM) hour24 H h(13) HH(13) minute m m(5) mm(05) second s s(9) ss(09) timezone z z (Pacific Standard Time) timezone Z Z(GMT-8:00) timezone a a(PM) 範例 12345678910111213141516import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;DatePipe&lt;/h1&gt; &lt;p&gt;&#123;&#123; dateObj | date &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; dateObj | date:'medium' &#125;&#125; &lt;/p&gt; &lt;p&gt;&#123;&#123; dateObj | date:'shortTime' &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; dateObj | date:'mmss' &#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; dateObj = new Date();&#125; 顯示結果 UpperCasePipe 功能 將所有英文字轉換成大寫 使用方式 string_expression | uppercase 範例 12345678910111213import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;UpperCase&lt;/h1&gt; &lt;p&gt;&#123;&#123; display | uppercase &#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; display = 'this is upperCase testcase';&#125; 顯示結果 LowerCasePipe 功能 將所有英文字轉換成小寫 使用方式 string_expression | lowercase 範例 12345678910111213import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;LowerCasePipe&lt;/h1&gt; &lt;p&gt;&#123;&#123; display | lowercase &#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; display = 'this is LOWERCASE testcase';&#125; 顯示結果 TitleCasePipe 功能 將每一個英文單字的第一個字母變成大寫 使用方式 string_expression | titlecase 範例 12345678910111213import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;TitleCasePipe&lt;/h1&gt; &lt;p&gt;&#123;&#123; display | titlecase &#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; display = 'this is TILECASE testcase';&#125; 顯示結果 CurrencyPipe 功能 將數字根據當地貨幣的顯示規則顯示 使用方式 number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]] 說明 只接收數字型別的資料 currencyCode 是 ISO 4217 貨幣代碼，例如 USD 代表美金， TWD 代表新台幣。 symbolDisplay 是布林值，用來決定是否顯示貨幣符號或是貨幣代碼 true 使用符號 (例如 $). false (預設): 使用貨幣代碼 (e.g. USD). digitInfo 請參閱DecimalPipe 的說明. 範例 12345678910111213141516171819import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;CurrencyPipe&lt;/h1&gt; &lt;p&gt;A: &#123;&#123;a | currency:'USD':false&#125;&#125;&lt;/p&gt; &lt;p&gt;B: &#123;&#123;b | currency:'USD':true:'4.2-2'&#125;&#125;&lt;/p&gt; &lt;p&gt;C: &#123;&#123;c | currency:'TWD':false&#125;&#125;&lt;/p&gt; &lt;p&gt;D: &#123;&#123;d | currency:'TWD':true:'4.2-2'&#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; a: number = 0.259; b: number = 1.3495; c: number = 15000; d: number = 20000;&#125; 顯示結果 PercentPipe 功能 將數字根據當地顯示規則顯示百分比 使用方式 number_expression | percent[:digitInfo] 說明 只接收數字型別的資料 digitInfo 請參閱DecimalPipe 的說明. 範例 123456789101112131415import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;PercentPipe&lt;/h1&gt; &lt;p&gt;A: &#123;&#123;a | percent&#125;&#125;&lt;/p&gt; &lt;p&gt;B: &#123;&#123;b | percent:'4.3-5'&#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; a: number = 0.259; b: number = 1.3495;&#125; 顯示結果 DecimalPipe 功能 將數字根據當地顯示規則顯示 使用方式 number_expression | number[:digitInfo] 說明 只接收數字型別的資料 digitInfo 以文字形式來設定數字顯示規則 1&#123;minIntegerDigits&#125;.&#123;minFractionDigits&#125;-&#123;maxFractionDigits&#125; minIntegerDigits 是整數最小顯示位數，預設為 1. minFractionDigits 是小數點後最小顯示位數，預設為 0. maxFractionDigits 是小數點後最大顯示位數，預設為 3 範例 1234567891011121314151617import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h1&gt;DecimalPipe&lt;/h1&gt; &lt;p&gt;e (no formatting): &#123;&#123;e&#125;&#125;&lt;/p&gt; &lt;p&gt;e (3.1-5): &#123;&#123;e | number:'3.1-5'&#125;&#125;&lt;/p&gt; &lt;p&gt;pi (no formatting): &#123;&#123;pi&#125;&#125;&lt;/p&gt; &lt;p&gt;pi (3.5-5): &#123;&#123;pi | number:'3.5-5'&#125;&#125;&lt;/p&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; pi: number = 3.141592; e: number = 2.718281828459045;&#125; 顯示結果 JsonPipe 功能 將值轉換成 JSON 文字 使用方式 expression | json 說明 使用 JSON.stringify 的方法將值轉換成文字 範例 ​12345678910111213141516171819202122import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &lt;h1&gt;JsonPipe&lt;/h1&gt; &lt;p&gt;Without JSON pipe:&lt;/p&gt; &lt;pre&gt;&#123;&#123;object&#125;&#125;&lt;/pre&gt; &lt;p&gt;With JSON pipe:&lt;/p&gt; &lt;pre&gt;&#123;&#123;object | json&#125;&#125;&lt;/pre&gt; &lt;/div&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; object: Object = &#123; foo: 'bar', baz: 'qux', nested: &#123;xyz: 3, numbers: [1, 2, 3, 4, 5]&#125; &#125;;&#125; 顯示結果 SlicePipe 功能 建立新的清單或是切割後的部分文字 使用方式 array_or_string_expression | slice:start[:end] 說明 只接收陣列或是文字型的資料 start 是切割的開始位置 如果是 正整數 則會回傳該位置以後的資料或文字。 如果是 負整數 則會從資料或文字結尾往回計算開始位置，在回傳該位置之後的資料或文字。 如果是 正整數 而且該整數大於陣列或是文字長度時，則會回傳空的陣列或文字。 如果是 負整數 而且該整數大於陣列或是文字長度時，則會回傳整個陣列或文字。 end 是切割的結束位置 如果是沒有給予任何數字時，則回傳到結尾的所有資料。 如果是 正整數 則回傳結束位置前的所有資料或文字。 如果是 負整數 則會從資料或文字結尾往回計算結束位置，並回傳結束位置前的所有資料或文字。 所有的行為都是基於 Array.prototype.slice() 和 String.prototype.slice() 的基礎上。 如果操作的對象是一個陣列，每次都會回傳一個全新的陣列 如果操作的資料是空值，Pipe 會回傳空值 範例 ​1234567891011121314151617181920212223242526import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &lt;h1&gt;SlicePipe&lt;/h1&gt; &lt;h2&gt;操作陣列&lt;/h2&gt; &lt;ul&gt; &lt;li *ngFor="let i of collection | slice:1:3"&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;操作文字&lt;/h2&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[0:4]: '&#123;&#123;str | slice:0:4&#125;&#125;' - 預期輸出為 'abcd'&lt;/p&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[4:0]: '&#123;&#123;str | slice:4:0&#125;&#125;' - 預期輸出為 ''&lt;/p&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[-4]: '&#123;&#123;str | slice:-4&#125;&#125;' - 預期輸出為 'ghij'&lt;/p&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[-4:-2]: '&#123;&#123;str | slice:-4:-2&#125;&#125;' - 預期輸出為 'gh'&lt;/p&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[-100]: '&#123;&#123;str | slice:-100&#125;&#125;' - 預期輸出為 'abcdefghij'&lt;/p&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;[100]: '&#123;&#123;str | slice:100&#125;&#125;' - 預期輸出為 ''&lt;/p&gt; &lt;/div&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; collection: string[] = ['a', 'b', 'c', 'd']; str: string = 'abcdefghij';&#125; 顯示結果 AsyncPipe 功能 從非同步動作 (Promise/Observable) 中取出資料 使用方式 observable_or_promise_expression | async 說明 async pipe 會訂閱一個 Observable 或是 Promise 物件，並獲取最後發生的資料。當有新的資料產生時，async pipe 會提示 ChangeDetector 要檢查 Component 的值。 當 Comoponent 被摧毀時，通常是離開該 Component的時候，async 會自動取消訂閱 ( unsubscribe)，避免潛在的記憶體洩漏問題。 範例 12345678910111213141516171819import &#123;Component&#125; from '@angular/core';import &#123;Observable&#125; from 'rxjs/Observable';import &#123;Subscriber&#125; from 'rxjs/Subscriber';@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &lt;h1&gt;AsyncPipe&lt;/h1&gt; &lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;: Time: &#123;&#123; time | async &#125;&#125;&lt;/div&gt; &lt;/div&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; time = new Observable&lt;string&gt;((observer: Subscriber&lt;string&gt;) =&gt; &#123; setInterval(() =&gt; observer.next(new Date().toString()), 1000); &#125;);&#125; 顯示結果 I18nPluralPipe &amp; I18nSelectPipe 由於這兩個 Pipe 跟多國語系功能有關係，且皆處於 Experimental 階段，故在次先不做說明。 自訂 Pipe 透過 CLI 產生 Pipe 是最快的，指令是 ​1ng g p "pipeName" 所產生出來的基本架構是 ​123456789101112import &#123; Pipe, PipeTransform &#125; from '@angular/core';@Pipe(&#123; name: 'exponential'&#125;)export class ExponentialPipe implements PipeTransform &#123; transform(value: number, exponent: string): number &#123; let exp = parseFloat(exponent); return Math.pow(value, isNaN(exp) ? 1 : exp); &#125;&#125; transform function 所回傳的值，會用來顯示在畫面上 第一個參數 value 是所要轉換的資料來源 第二個之後的參數可以用來接 Template 傳給 pipe 的參數值 如果要傳入多個參數的時後，transform 的地方值直接加上第3的參數或是使用 …args 也是可以，而在 template 的使用方式則是 {{ value | xxpipe: 1_arg: 2_arg: 3:arg }} 以此類推。 Pipe 與 ChangeDetection Angular 會透過 change detection 方法執行的過程中，去檢查 data-bound值的變化，而 change detection 會在每一次 DOM Eevent 後被觸發，例如按下鍵盤的鍵，滑鼠的移動，伺服器的回應等事件，這個過程是需要付出相對的成本，為了效能，Angular會盡量降低 change detection 的次數 所以 Pipe 會採用最簡單又快速的判斷規則，ChangeDetectionStrategy.OnPush。 這表示當 Pipe 如果用在陣列上，就有機會出現不在預期內的顯示結果，如以下的範例 12345678910import &#123;Pipe, PipeTransform&#125; from '@angular/core';import &#123;Flyer&#125; from './app.component';@Pipe(&#123;name: 'flyingHeroes'&#125;)export class FlyingHeroesPipe implements PipeTransform &#123; transform(allHeroes: Flyer[]) &#123; return allHeroes.filter(hero =&gt; hero.canFly); &#125;&#125; component 123456789101112131415161718192021222324252627282930313233343536@Component(&#123; selector: 'app-root', template: ` &lt;input type="text" #box (keyup.enter)="addHero(box.value); box.value=''" placeholder="hero name"&gt; &lt;button (click)="reset()"&gt;Reset&lt;/button&gt; &lt;div *ngFor="let hero of heroes | flyingHeroes"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/div&gt;`, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; heroes: any[] = []; canFly = true; constructor() &#123; this.reset(); &#125; addHero(name: string) &#123; name = name.trim(); if (!name) &#123; return; &#125; let hero = &#123;name, canFly: this.canFly&#125;; // this.heroes.push(hero); // 這個不會更新畫面，因為不符合 OnPush 的條件 this.heroes = [...this.heroes, hero]; // 因會產生一個新的 Array Object, 所以會觸發 CD &#125; reset() &#123; this.heroes = HEROS.slice(); &#125;&#125; Pure and Impure Pipes Angular 的 Pipe 預設皆為 Pure，如果需要設定為 Impure的話，請這樣子設定 12345@Pipe(&#123; name: 'flyingHeroesImpure', pure: false&#125;)... 至於什麼是 Pure Pipe ，什麼是 Impure Pipe Pure Pipe 這裡所指的 Pure，至針對 Pipe 所要轉換的值是否為 Pure Change，所謂的 Pure Change 是改變 primitive input value( String, Number, Boolean, Symbol) 或是改變 Object 參考的位址 (Date, Array, Function, Object)。 這規則與 ChangeDetectionStrategy.OnPush 是一樣的。在上面的例子中，因為 heroes 是一個陣列物件，如果是 push的行為並不會改變該陣列所參考的位址 (ByReference)，必須重新建立一個新的陣列物件，才會改變參考位址。 Impure Pipe Impure Pipe 就是 Pure的相反，也是 ChangeDetectionStrategy 預設的執行方式，只要有資料異動，就會觸發改變。 來調整一下上面的範例，來讓 array.push 也可以做到畫面更新顯示的功能。 12345678910import &#123;Pipe, PipeTransform&#125; from '@angular/core';import &#123;Flyer&#125; from './app.component';@Pipe(&#123;name: 'flyingHeroes', pure: false&#125;)export class FlyingHeroesPipe implements PipeTransform &#123; transform(allHeroes: Flyer[]) &#123; return allHeroes.filter(hero =&gt; hero.canFly); &#125;&#125; 當這樣子設定為 Impure時，下面的 push 就可以使用而且畫面也會更新 12345678910addHero(name: string) &#123; name = name.trim(); if (!name) &#123; return; &#125; let hero = &#123;name, canFly: this.canFly&#125;; this.heroes.push(hero); &#125; 參考資料 官方文件 ngx-translate]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Meta 與 Route]]></title>
    <url>%2F2017%2F04%2F20%2Fangular-meta%2F</url>
    <content type="text"><![CDATA[Angular 4 版內建了 Meta 的服務，雖然目前還是標示 EXPERIMENTAL (表示未來有可能會有 break change)，但還是先來玩看看，希望能和路由設定檔綁在一起。 路由設定 我們知道 Route 的設定檔裡面可以設定 data 或是透過 resolve 來預先處理非同步的資料取得行為 ( 例如 call API)，可參閱這篇文章 假設，我們的路由設定檔，長這樣 1234567891011121314151617181920&#123; path: '', component: HomeComponent, data: &#123; meta: [ &#123;name: 'twitter:title', content: 'Good Morning Harwood'&#125;, &#123;property: 'og:title', content: 'Good Morning Harwood'&#125; ] &#125; &#125;, &#123; path: 'about', component: AboutComponent, data: &#123; meta: [ &#123;name: 'twitter:title', content: 'About Us'&#125;, &#123;property: 'og:title', content: 'About Us'&#125; ] &#125; &#125; 以上的設定，就可以透過 Router 和 ActivatedRoute的方式取得 data 下 meta 的資訊。而這些資訊就是要設定到 &lt;head&gt;&lt;/head&gt; 間的訊息 Meta 1234567891011class Meta &#123; constructor(_doc: any) addTag(tag: MetaDefinition, forceCreation?: boolean) : HTMLMetaElement addTags(tags: MetaDefinition[], forceCreation?: boolean) : HTMLMetaElement[] getTag(attrSelector: string) : HTMLMetaElement getTags(attrSelector: string) : HTMLMetaElement[] updateTag(tag: MetaDefinition, selector?: string) : HTMLMetaElement removeTag(attrSelector: string) : void removeTagElement(meta: HTMLMetaElement) : void&#125; 雖然有這麼多功能，比較需要提的是 updateTag 這一個包含新增的功能，他會判斷如果你想要更新的MetaDefiniton 不存在時，就會幫你建立一個。 實作範例 路由設定檔關於 meta 資料這邊就先略過，可以參照上面的路由設定範例，這段範例的主要目的，要讓 Angular 可以自動更新 Meta 資訊，我先把程式貼出來，在一行行的解釋 12345678910111213141516constructor( private metaService: Meta, private router: Router, private activatedRoute: ActivatedRoute) &#123; this.router.events.filter(event =&gt; (event instanceof NavigationEnd)) .switchMap(() =&gt; &#123; const snapshot = this.activatedRoute.snapshot; let child = snapshot.firstChild; while (child.firstChild !== null) &#123; child = child.firstChild; &#125; return Observable.from(child.data.meta); &#125;) .do((meta: any) =&gt; this.metaService.updateTag(meta)) .subscribe(); &#125;; 為了避免重複執行，這段程式碼我是放在 app.component.ts的地方，因為正常情況下，app.component 只會被執行一次。 1this.router.events.filter(event =&gt; (event instanceof NavigationEnd)) 這我之前有寫過，就參讀這篇文章 吧 12345678.switchMap(() =&gt; &#123; const snapshot = this.activatedRoute.snapshot; let child = snapshot.firstChild; while (child.firstChild !== null) &#123; child = child.firstChild; &#125; return Observable.from(child.data.meta);&#125;) 為什麼要取snapShot，因為 snapShot 是當時的值，透過這種方式取得的資料就不是 Observable 型別了。透過 while 的方式取得 data 區段的資料。然後將 meta 的陣列轉換成 stream 的模式 1.do((meta: any) =&gt; this.metaService.updateTag(meta)) 依前一個 Operator 傳回的結果，一個一個的更新 meta 資訊 1.subscribe(); 執行上面的工作。 執行結果]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] EventManager]]></title>
    <url>%2F2017%2F04%2F19%2Fangular-eventmanager%2F</url>
    <content type="text"><![CDATA[EventManager 是一個很強大的 Angular 內建功能。預設有開啟三種 Event，Dom、Key、HammerGestures Plugin可以使用。EventManager 可以讓我們很簡單的控制全域 (window) 的事件。 EventManager EventManager 的 Class 如下 123456class EventManager &#123; constructor(plugins: EventManagerPlugin[], _zone: NgZone) addEventListener(element: HTMLElement, eventName: string, handler: Function) : Function addGlobalEventListener(target: string, eventName: string, handler: Function) : Function getZone() : NgZone&#125; constructor 所指的 plugins 項目，在 browser 一開始讀取時，就已經在 provider 的地方設定好了 根據文件，我們可以使用 addGlobalEventListener 的方式來註冊事件到某一個對象上，所以如果要將 keyup 事件註冊到 windows物件上，那我們可以這樣子寫 12345constructor(private eventManger: EventManager) &#123; this.eventManger.addGlobalEventListener('window', 'keyup.enter', (e: KeyboardEvent) =&gt; &#123; // do something here &#125;);&#125; 範例 ctrl+a全選的功能，也可以透過這個方式給覆寫掉 1234567this.eventManger.addGlobalEventListener('window', 'keydown.control.a', (e: KeyboardEvent) =&gt; &#123; e.preventDefault(); &#125;);this.eventManger.addGlobalEventListener('window', 'keyup.control.a', (e: KeyboardEvent) =&gt; &#123; // do soemthing.. &#125;); 其他說明 那至於 EventManager 會使用哪一個 EventPlugin，他自己會去判斷。 參考資料 source code]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ngIf 跟他的新朋友 else 和 then]]></title>
    <url>%2F2017%2F04%2F19%2Fangular-ngIf-else%2F</url>
    <content type="text"><![CDATA[Angular 4 將原本的 ngIf 的功能給擴充了。多了兩個新朋友 else 跟 then，就讓我們了解一下用法跟使用情境 else else 比較好理解。就是當 ngIf 的條件還是假的時候，就顯示else所指定的 &lt;ng-template&gt;，先比較之前的寫法與使用 else寫法的差異。 舊寫法 123456&lt;div&gt; &lt;strong&gt;UserName:&lt;/strong&gt; &lt;span *ngIf="user|async"&gt; &#123;&#123; (user|asnyc)?.name &#125;&#125; &lt;/span&gt; &lt;/div&gt; 這樣的寫法個問題，因為 async 跑了兩次，所以 user 這個 Observable 也就被執行了兩次 (該Observable沒有設定為multicast的模式)，站在效能的角度來看，並不是很好。 新版的 ngIf else的語法就可以幫我們解決這個問題。 新寫法 123456789&lt;div&gt; &lt;strong&gt;UserName:&lt;/strong&gt; &lt;span *ngIf="user|async as _user; else elseTmpl"&gt; &#123;&#123; _user.name &#125;&#125; &lt;/span&gt; &lt;ng-template #elseTmpl&gt; loading user... &lt;/ng-template&gt;&lt;/div&gt; 這個 as 可以讓我們將前面的資料儲存成一個變數 (storing the value locally)，供自己的 template 使用。這範例裡 _user 變數就是會儲存 user subscribe 回來的結果，而 as 的語法，也可以使用在 ngFor的情境1 執行效果如下 then 那 then 又是怎麼一回事呢? 我們知道 三元條件運算 的用法 condition? true: false ，而 then 在這邊是指 條件為真的情形，就顯示所指定的 &lt;ng-template&gt;。 12345678910111213141516171819202122232425@Component(&#123; selector: 'ng-if-then-else', template: ` &lt;button (click)="show = !show"&gt;&#123;&#123;show ? 'hide' : 'show'&#125;&#125;&lt;/button&gt; &lt;button (click)="switchPrimary()"&gt;Switch Primary&lt;/button&gt; show = &#123;&#123;show&#125;&#125; &lt;br&gt; &lt;div *ngIf="show; then thenBlock; else elseBlock"&gt;this is ignored&lt;/div&gt; &lt;ng-template #primaryBlock&gt;Primary text to show&lt;/ng-template&gt; &lt;ng-template #secondaryBlock&gt;Secondary text to show&lt;/ng-template&gt; &lt;ng-template #elseBlock&gt;Alternate text while primary text is hidden&lt;/ng-template&gt;`&#125;)class NgIfThenElse implements OnInit &#123; thenBlock: TemplateRef&lt;any&gt; = null; show: boolean = true; @ViewChild('primaryBlock') primaryBlock: TemplateRef&lt;any&gt; = null; @ViewChild('secondaryBlock') secondaryBlock: TemplateRef&lt;any&gt; = null; switchPrimary() &#123; this.thenBlock = this.thenBlock === this.primaryBlock ? this.secondaryBlock : this.primaryBlock; &#125; ngOnInit() &#123; this.thenBlock = this.primaryBlock; &#125;&#125; 執行效果如下 參考資料 NgIf ​1.*ngFor=「let user of users | async as _users」 ↩]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 啟用 strictNullChecks]]></title>
    <url>%2F2017%2F04%2F13%2Fangular-strictNullChecks%2F</url>
    <content type="text"><![CDATA[Typescript 2.0 新增了一個功能 strictNullChecks ，這一功能的主要目的是將 null 與 undefined 視為不同的型別。在這個選項啟動時， Typescript 會去檢查所有有可能發生 null 的程式碼，在下面會看到當開啟時，需要調整的項目有哪些。這樣的嚴謹模式，可以大大的降低一些例外的發生 而 Angular 所使用的 Typescript 版本也是 2.0 以後的版本，爾當然支援這樣的功能，以下我就拿一個手上練習的專案將該功能該起後，所遇到的一些狀況跟解決方式。 前言 Null- and undefined-aware types TypeScript has two special types, Null and Undefined, that have the values null and undefined respectively. Previously it was not possible to explicitly name these types, but null and undefined may now be used as type names regardless of type checking mode. The type checker previously considered null and undefined assignable to anything. Effectively, null and undefined were valid values of every type and it wasn’t possible to specifically exclude them (and therefore not possible to detect erroneous use of them). Angular 環境設定 在 tsconfig.json 內開啟 strictNullChecks 功能，由於 Angular 主程式內還有部分的程式碼還沒有辦法通過 strictNullChecks 的檢查，所以必須再多開啟 skipLibCheck 的選項 123456789&#123; "compileOnSave": false, "compilerOptions": &#123; ... "strictNullChecks": true, "skipLibCheck": true, ... &#125;&#125; 檢查開始 當執行 npm start 時，Typescript 就會開始做檢查的動作了，在最近更新的 Visual Studio Code 支援從 Terminal 直接開啟該檔案的功能，Ctrl + Click 就可以開啟了。 第一次的檢查，會跳出很多紅色的錯誤。就一個一個看吧 錯誤 1: Type any[] is not assignable to type never[] 圖片中的 errMessage 是發生錯誤的地方。造成這個錯誤的原因是 errMessage 在定義時，並沒有宣告型別，而是直接給予一個空陣列。 修正方式 : 明確的給予型別，即可修正此類型的錯誤 12345678let errMessage: string[] = [];for (const prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; if (Array.isArray(obj[prop])) &#123; errMessage = [...errMessage, ...obj[prop]]; &#125; &#125;&#125; 錯誤 2: Argument of Type … is not assignable to type 『…』 這裡的 AuthConfig 接受的參數型別是 IAuthConfigOptional，而程式碼裡所傳入的 Object 並未指定型別。 修正方式 : 給予正確的型別 12345return new AuthHttp(new AuthConfig(&lt;IAuthConfigOptional&gt;&#123; tokenName: 'token', noJwtError: true, tokenGetter: (() =&gt; localStorage.getItem('token')), &#125;), http, options); 錯誤 3: Object is possibly null 在這裡的錯誤訊息是指，這段程式碼有可能因為某一個Object是 null 時，後續的程式碼就無法繼續下去，所以必須先排除 null 的狀態，才能確保後續的動作是正常的。而這個行為，在 Typescript 2.0 稱為 Control flow based type analysis 2 這裡有幾種修正方式 告訴 Typescript, 這裡有可能發生 null 的 Object 是不會有 null 值的情形，需使用 ! 1 123456const number = this.document.body.scrollTop; if (number &gt; 130) &#123; this.document!.getElementById('control-panel')!.classList.add('panel-fixed'); &#125; else &#123; this.document!.getElementById('control-panel')!.classList.remove('panel-fixed'); &#125; 根據 Type 來控制流程 12345678910111213if (this.document === null) &#123; return;&#125;const number = this.document.body.scrollTop;const panel = this.document.getElementById('control-panel');if (panel === null) &#123; return;&#125;if (number &gt; 130) &#123; panel.classList.add('panel-fixed');&#125; else &#123; panel.classList.remove('panel-fixed');&#125; 錯誤4: Type 『null』 is not assignable to type 『file | undefined』 修正方式 : 這個錯誤其實很簡單，就是不要指定 null 到變數上即可 1photo.file = undefined; 結論 透過這一系列的型別設定檢查，雖然在開發時期，因為型別的指定會降低開發的速度，可是當系統越來越龐大時，可以在開發時期確保程式不會壞掉。就投報率的角度來說，是非常值得投資的。 參考資料 TypeScript 2.0 1.A new ! post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation x! produces a value of the type of xwith null and undefined excluded. Similar to type assertions of the forms &lt;T&gt;x and x as T, the ! non-null assertion operator is simply removed in the emitted JavaScript code. ↩2.TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to if statements and ?: conditional expressions and didn't include effects of assignments and control flow constructs such as return and break statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the narrowed type) at any given location for a local variable or parameter that is declared to have a union type. ↩]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular 4 - Universal with ASP.NET Core]]></title>
    <url>%2F2017%2F03%2F26%2Fangular4-universal-aspnetcore%2F</url>
    <content type="text"><![CDATA[Angular 4 將 Universal 的功能整合到 @angular/platform-server 裡，目前(2017/3/26) dotnet cli 所提供的 SPA 樣板尚未更新至最新版，如果在這個時間點想要更新到最新版時，就需要手動更新部分的檔案內容，這篇文章就是這描述這些異動，或許在未來的某一個時間點後，就不需要這麼麻煩了 引言 以下的操作步驟，有可能在未來的版本更新後就不需要了，請詳閱相關的說明文件。 步驟1: package.json 手動更新 package.json 的內容 scripts 1234567"scripts": &#123; "test": "karma start ClientApp/test/karma.conf.js", "postinstall": "npm run build:webpack", "build:webpack": "npm run webpack-vendor &amp;&amp; npm run webpack", "webpack": "webpack --progress", "webpack-vendor": "webpack --config webpack.config.vendor.js --progress" &#125; Dependencies 替換 123456789"@angular/common": "^2.4.5","@angular/compiler": "^2.4.5","@angular/core": "^2.4.5","@angular/forms": "^2.4.5","@angular/http": "^2.4.5","@angular/platform-browser": "^2.4.5","@angular/platform-browser-dynamic": "^2.4.5","@angular/platform-server": "^2.4.5","@angular/router": "^3.4.5", 將上列的 @angular 模組的版本更換成下列的版本 123456789101112"@angular/animations": "^4.0.0","@angular/common": "^4.0.0","@angular/compiler": "^4.0.0","@angular/compiler-cli": "^4.0.0","@angular/core": "^4.0.0","@angular/forms": "^4.0.0","@angular/http": "^4.0.0","@angular/platform-browser": "^4.0.0","@angular/platform-browser-dynamic": "^4.0.0","@angular/platform-server": "^4.0.0","@angular/router": "^4.0.0","@angular/tsc-wrapped": "^0.5.0", 移除 1234"angular2-platform-node": "~2.0.11","angular2-universal": "^2.1.0-rc.1","angular2-universal-patch": "^0.2.1","angular2-universal-polyfills": "^2.1.0-rc.1", 步驟2: webpack.config.vendor.ts 移除 將下列的兩項 library 給刪除掉 123456entry: &#123; vendor: [ 'angular2-universal', 'angular2-universal-polyfills', ]&#125; 步驟3: 異動 ClientApp 異動 boot-client.ts 1234567891011121314151617181920212223242526272829import './polyfills/browser.polyfills';import &#123; enableProdMode &#125; from '@angular/core';import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppBrowserModule &#125; from './app/browser-app.module';const rootElemTagName = 'app'; // Update this if you change your root component selector// Enable either Hot Module Reloading or production modeif (module['hot']) &#123; module['hot'].accept(); module['hot'].dispose(() =&gt; &#123; // Before restarting the app, we create a new root element and dispose the old one const oldRootElem = document.querySelector(rootElemTagName); const newRootElem = document.createElement(rootElemTagName); oldRootElem.parentNode.insertBefore(newRootElem, oldRootElem); platform.destroy(); &#125;);&#125; else &#123; enableProdMode();&#125;// Boot the application, either now or when the DOM content is loadedconst platform = platformBrowserDynamic();const bootApplication = () =&gt; &#123; platform.bootstrapModule(AppBrowserModule); &#125;;if (document.readyState === 'complete') &#123; bootApplication();&#125; else &#123; document.addEventListener('DOMContentLoaded', bootApplication);&#125; 移除 import 'angular2-universal-polyfills/browser' 移除 import { platformUniversalDynamic } from 'angular2-universal'; 新增 import './polyfills/browser.polyfills'; 新增 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; 修正 platform 的建立方式，從 platformUniversalDynamic 更換成 platformBrowserDynamic 修正 bootstrapMoudle，從 AppModule 更換成 AppBrowserModule boot-server.ts 1234567891011121314151617181920212223242526272829import './polyfills/server.polyfills';import &#123; enableProdMode &#125; from '@angular/core';import &#123; INITIAL_CONFIG &#125; from '@angular/platform-server';import &#123; createServerRenderer, RenderResult &#125; from 'aspnet-prerendering';// Grab the (Node) server-specific NgModuleimport &#123; AppServerModule &#125; from './app/server-app.module';// Temporary * the engine will be on npm soon (`@universal/ng-aspnetcore-engine`)import &#123; ngAspnetCoreEngine &#125; from './polyfills/temporary-aspnetcore-engine';enableProdMode();export default createServerRenderer(params =&gt; &#123; // Platform-server provider configuration const providers = [&#123; provide: INITIAL_CONFIG, useValue: &#123; document: '&lt;app&gt;&lt;/app&gt;', // Our Root application document url: params.url &#125; &#125;]; return ngAspnetCoreEngine(providers, AppServerModule).then(response =&gt; &#123; return (&#123; html: response.html, globals: response.globals &#125;); &#125;);&#125;); app/app.module.ts 12345678910111213141516171819202122232425262728293031323334import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule &#125; from '@angular/router';import &#123; CommonModule &#125; from '@angular/common';import &#123; HttpModule &#125; from '@angular/http';import &#123; AppComponent &#125; from './components/app/app.component'import &#123; NavMenuComponent &#125; from './components/navmenu/navmenu.component';import &#123; HomeComponent &#125; from './components/home/home.component';import &#123; FetchDataComponent &#125; from './components/fetchdata/fetchdata.component';import &#123; CounterComponent &#125; from './components/counter/counter.component';@NgModule(&#123; bootstrap: [AppComponent], declarations: [ AppComponent, NavMenuComponent, CounterComponent, FetchDataComponent, HomeComponent ], imports: [ CommonModule, HttpModule, RouterModule.forRoot([ &#123; path: '', redirectTo: 'home', pathMatch: 'full' &#125;, &#123; path: 'home', component: HomeComponent &#125;, &#123; path: 'counter', component: CounterComponent &#125;, &#123; path: 'fetch-data', component: FetchDataComponent &#125;, &#123; path: '**', redirectTo: 'home' &#125; ]) ]&#125;)export class AppModule &#123;&#125; 移除 UniversalModule 移除 bootstrap 區塊 新增 CommonModule、HttpModule 新增檔案 browser-app.module.ts 12345678910111213141516171819import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppModule &#125; from './app.module';import &#123; AppComponent &#125; from './components/app/app.component';import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';@NgModule(&#123; bootstrap: [AppComponent], imports: [ BrowserAnimationsModule, BrowserModule.withServerTransition(&#123; appId: 'my-app-id' &#125;), AppModule ]&#125;)export class AppBrowserModule &#123;&#125; server-app.module.ts 12345678910111213141516171819202122import &#123; NgModule &#125; from '@angular/core';import &#123; ServerModule &#125; from '@angular/platform-server';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NoopAnimationsModule &#125; from '@angular/platform-browser/animations';import &#123; AppModule &#125; from './app.module';import &#123; AppComponent &#125; from './components/app/app.component';@NgModule(&#123; bootstrap: [ AppComponent ], imports: [ NoopAnimationsModule, BrowserModule.withServerTransition(&#123; appId: 'my-app-id' &#125;), ServerModule, AppModule ]&#125;)export class AppServerModule &#123; &#125; polyfills/temporary-aspnetcore-engine.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* ********* TEMPORARILY HERE ************** * - will be on npm soon - * import &#123; ngAspnetCoreEngine &#125; from `@universal/ng-aspnetcore-engine`; */import &#123; Type, NgModuleRef, ApplicationRef, Provider &#125; from '@angular/core';import &#123; platformDynamicServer, PlatformState &#125; from '@angular/platform-server';export function ngAspnetCoreEngine( providers: Provider[], ngModule: Type&lt;&#123;&#125;&gt;): Promise&lt;&#123; html: string, globals: &#123; styles: string, title: string, meta: string, [key: string]: any &#125; &#125;&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const platform = platformDynamicServer(providers); return platform.bootstrapModule(&lt;Type&lt;&#123;&#125;&gt;&gt;ngModule).then((moduleRef: NgModuleRef&lt;&#123;&#125;&gt;) =&gt; &#123; const state: PlatformState = moduleRef.injector.get(PlatformState); const appRef: ApplicationRef = moduleRef.injector.get(ApplicationRef); appRef.isStable .filter((isStable: boolean) =&gt; isStable) .first() .subscribe((stable) =&gt; &#123; // Fire the TransferCache const bootstrap = moduleRef.instance['ngOnBootstrap']; bootstrap &amp;&amp; bootstrap(); // The parse5 Document itself const AST_DOCUMENT = state.getDocument(); // Strip out the Angular application const htmlDoc = state.renderToString(); console.log(htmlDoc); const APP_HTML = htmlDoc.substring( htmlDoc.indexOf('&lt;body&gt;') + 6, htmlDoc.indexOf('&lt;/body&gt;') ); // Strip out Styles / Meta-tags / Title const STYLES = []; const META = []; const LINKS = []; let TITLE = ''; const STYLES_STRING = htmlDoc.substring( htmlDoc.indexOf('&lt;style ng-transition'), htmlDoc.lastIndexOf('&lt;/style&gt;') + 8 ); // console.log(AST_DOCUMENT); const HEAD = AST_DOCUMENT.head; let count = 0; for (let i = 0; i &lt; HEAD.children.length; i++) &#123; let element = HEAD.children[i]; console.log(element.name); console.log(element.children); if (element.name === 'title') &#123; TITLE = element.children[0].data; &#125; // Broken after 4.0 (worked in rc) // if (element.name === 'style') &#123; // let styleTag = '&lt;style '; // for (let key in element.attribs) &#123; // styleTag += `$&#123;key&#125;="$&#123;element.attribs[key]&#125;"&gt;`; // &#125; // styleTag += `$&#123;element.children[0].data&#125;&lt;/style&gt;`; // STYLES.push(styleTag); // &#125; if (element.name === 'meta') &#123; count = count + 1; console.log(`\n\n\n ******* Meta count = $&#123;count&#125;`); let metaString = '&lt;meta'; for (let key in element.attribs) &#123; metaString += ` $&#123;key&#125;="$&#123;element.attribs[key]&#125;"`; &#125; META.push(`$&#123;metaString&#125; /&gt;\n`); &#125; if (element.name === 'link') &#123; let linkString = '&lt;link'; for (let key in element.attribs) &#123; linkString += ` $&#123;key&#125;="$&#123;element.attribs[key]&#125;"`; &#125; LINKS.push(`$&#123;linkString&#125; /&gt;\n`); &#125; &#125; resolve(&#123; html: APP_HTML, globals: &#123; styles: STYLES_STRING, title: TITLE, meta: META.join(' '), links: LINKS.join(' ') &#125; &#125;); moduleRef.destroy(); &#125;); &#125;).catch(err =&gt; &#123; reject(err); &#125;); &#125;);&#125; polyfills/browser.polyfills.ts 1234import 'zone.js/dist/zone';import 'reflect-metadata';import './rx-imports'; polyfills/server.polyfills.ts 1234567import 'es6-promise';import 'es6-shim';import 'reflect-metadata';import 'zone.js';import './rx-imports'; polyfills/rx-imports.ts 12345678910111213141516171819/* -=- RxJs imports -=- * * Here you can place any RxJs imports so you don't have to constantly * import them throughout your App :) */// Observableimport 'rxjs/Observable';import 'rxjs/Observable/throw';// Subjectimport 'rxjs/Subject';// Operatorsimport 'rxjs/add/operator/filter';import 'rxjs/add/operator/first';import 'rxjs/add/operator/catch';import 'rxjs/add/operator/map';import 'rxjs/add/operator/mergeMap'; 步驟四: npm install 重新執行 npm install，由於我們在一開始有新增一個 postinstall的工作，所以在安裝完後，npm 會跟著執行我們所設定的動作。 步驟五: dotnet run 重新將 asp.net core 跑起來，看看有沒有發生什麼錯誤 結論 以上就是手動升級需要異動的項目，希望之後 SPA Template 更新後，就不需要這麼麻煩了。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 結構性 Directive]]></title>
    <url>%2F2017%2F03%2F23%2Fangular-structural-directive%2F</url>
    <content type="text"><![CDATA[Angular 的 directive 真的很厲害，幾乎什麼都能做，除了可以擴充原本 element 的功能外，也還可以做到結構上的控制變化，而這一類型的稱為 Structural directive Structural directives—change the DOM layout by adding and removing DOM elements. 我們常用的 ngIf 就是其中之一，我們可以透過這一款的 directive 來新增或移除 DOM element。但在這之前，需要重新介紹 * 這一個語法糖 asterisk (*) * 會用 &lt;ng-template&gt; 將 directive 所處的 element 包起來。[1] 1234567&lt;div *ngIf="hero" &gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;// 上述將會轉換成下述&lt;ng-template [ngIf]="hero" &gt; &lt;div&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;/ng-template&gt; ng-template 裡的內容可以透過 TemplateRef 取得 簡易版 1234567891011121314151617@Directive(&#123; selector: '[myIf]'&#125;)export class MyIfDirective &#123; constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) &#123; &#125; @Input() set myIf(condition: boolean) &#123; if (condition) &#123; // 新增 DOM this.viewContainer.createEmbeddedView(this.templateRef); &#125; else &#123; // 移除 DOM this.viewContainer.clear(); &#125; &#125;&#125; 使用 directive 的方式 1&lt;div *myIf='condition'&gt;&lt;/div&gt; templteRef 的部分，請參閱上一區段的說明 ViewContainerRef 是指目前 directive的所在位置 透過這兩個物件，就可以完成 structural directive的實作，其實並不困難 稍微進階版 我們也可以將 service 注入到 directive 裡面，透過 RxJS 的幫助，可以讓 directive 處於自動監測的狀態，當全域某特定變數改變時，directive 也會跟著改變。聽起來很神奇，那實作起來會很困難嗎? 1234567891011121314151617181920212223@Directive(&#123; selector: '[isAuth]'&#125;)export class MyIfDirective &#123; user$ : Subscription; constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef private userService: UserService) &#123; &#125; ngOnInit() &#123; this.user$ = this.userService.user .do(() =&gt; this.viewContainer.clear()) .filter(user =&gt; user.isLogin) .subscribe(() =&gt; &#123; this.viewContainer.createEmbeddedView(this.templateRef); &#125;); &#125; ngOnDestroy() &#123; this.user$.unsubscribe(); &#125;&#125; 打完收工，其實還蠻簡單的。 這寫法跟寫 Component 根本就沒有差別，這就是 Angular 的優點，程式碼格式的一致性很高。 參考閱讀 STRUCTURAL DIRECTIVES Angular 4 以後，原本的&lt;template&gt; 會使用 &lt;ng-template&gt; 替代 ↩]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Custom Validator]]></title>
    <url>%2F2017%2F03%2F10%2Fangular-custom-validator%2F</url>
    <content type="text"><![CDATA[Angular 內建的表單驗證項目其實不多，網路上雖然也有人寫好的驗證擴充套件可以使用。但是，真正強大的是 Angular 允許我們自訂驗證規則，且很容易的套用到系統內，當然也可以簡單的讓其他專案使用。 這裡將會介紹 Custom Validator 的幾種實作方式 什麼是 Validator Validator 是用來做資料驗證的，資料驗證的結果只會有兩種，null 或 錯誤訊息，Angular 內建的 validator 有這些 required: 必填欄位 minLength: 最短長度 maxLength: 最長長度 pattern: regex 驗證 內建的表單驗證功能真的很少，所以是否有其他人寫好的驗證規則可以使用呢? 其實是有的，GitHub 連結 在此 如果想自己自訂驗證規則，要怎麼寫呢? 自訂 Validator Version 1 最簡單的 Validator 就是一個 function，但是這樣子的寫法，只能在 Reactive Form (model-driven) 下使用 12345678910111213141516export function validateEmail(c: FormControl) &#123; let EMAIL_REGEXP = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/; return EMAIL_REGEXP.test(c.value) ? null : &#123; validateEmail: &#123; valid: false &#125; &#125;;&#125;ngOnInit() &#123; this.form = new FormGroup(&#123; ... email: new FormControl('', validateEmail) &#125;);&#125; 如果要在 template-driven 表單下也可以使用這個驗證方法的話，又該怎麼辦? Version 2 我們可以透過 directive 的方式將我們自訂的驗證規則給 template-driven 表單使用，在需要被驗證的 FormControl 上，加上我們設定的屬性即可，所以我們需要來建立一個 directive，建立步驟如下 使用 CLI 的指令 1ng generate directive emailValidator 所產生出來的程式碼會長這樣 12345678910import &#123; Directive &#125; from '@angular/core';@Directive(&#123; selector: '[appEmailValidator]'&#125;)export class EmailValidatorDirective &#123; constructor() &#123; &#125;&#125; 稍微調整一下 Class 的名稱，讓這個更容易辨識，並將之前寫好的 validateEmail 方法搬進來 1234567891011121314import &#123; Directive &#125; from '@angular/core';import &#123; NG_VALIDATORS, FormControl &#125; from '@angular/forms';export function validateEmail(c: FormControl) &#123; ...&#125;@Directive(&#123; selector: '[validateEmail][ngModel]', providers:[ &#123; provide: NG_VALIDATORS, useValue: validateEmail, multi: true &#125; ]&#125;)export class EmailValidator &#123;&#125; selector 的部分，[valiateEmail] 和 [ngModel]，表示要使用這個 directive 的條件是 element 裡需要同時擁有這兩個 attribute 才會生效，範例如下 1234&lt;form #myForm="ngForm" novalidate&gt; &lt;input type="email" name="email" ngModel validateEmail #email="ngModel"&gt; &#123;&#123; email.errors | json &#125;&#125;&lt;/form&gt; Version 3 上面的寫法，雖然是可以跑，但是，程式碼看起來就有點散落在四處，有沒有可以把驗證的規則包在 directive 裡面呢? 1234567891011121314151617181920212223242526import &#123; Directive &#125; from '@angular/core';import &#123; NG_VALIDATORS, Validator, FormControl &#125; from '@angular/forms';@Directive(&#123; selector: '[validateEmail][ngModel]', providers: [ &#123; provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; EmailValidator), multi: true &#125; ]&#125;)export class EmailValidator implements Validator &#123; validator: Function; constructor() &#123; &#125; validate(c: FormControl) &#123; let EMAIL_REGEXP = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/; return EMAIL_REGEXP.test(c.value) ? null : &#123; validateEmail: &#123; valid: false &#125; &#125;; &#125;&#125; 修正了幾個地方 class 需要實作 Validator 使用 useExisting 來設定 provider 使用 forwardRef 來避免初始時 NG_VALIDATORS token 尚未產生的錯誤 使用 multi 來擴充 NG_VALIDTORS的功能 將原本的驗證 function 的程式碼搬進 validate 裡面 到這個階段，template-driven 的表單已經可以使用了，可是， model-driven 的表單就不能直接在樣版上使用，原因是 selector 裡並沒有給予 formControlName 使用的條件，所以，再來將缺少的部分補上 Version 4 123456789101112131415import &#123; Directive &#125; from &apos;@angular/core&apos;;import &#123; NG_VALIDATORS, Validator, AbstractControl &#125; from &apos;@angular/forms&apos;;@Directive(&#123; selector: &apos;[validateEmail][ngModel],[formControlName][ngModel],[formControl][ngModel]&apos;, providers: [ ... ]&#125;)export class EmailValidator implements Validator &#123; ... validate(c: AbstractControl) &#123; ... &#125;&#125; 以上就是一個自訂驗證的基本型的寫法 顯示結果 補充資訊 provide 的部分有兩種可以設定 NG_VALIDATORS 和 NG_ASYNC_VALIDATORS，class 的 validator 的寫法是一樣的，唯一的差別是回傳的型別， NG_ASYNC_VALIDATORS 可以回傳 Promise/Observable 的型別。可參考延伸閱讀的第一篇文章 延伸閱讀 Create Async Validator Directive How to Implement a Custom Validator Directive (Confirm Password) in Angular 2 FORWARD REFERENCES IN ANGULAR]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Router 的 resetConfig 方法]]></title>
    <url>%2F2017%2F03%2F03%2Fangular2-router-resetconfig%2F</url>
    <content type="text"><![CDATA[這次要介紹的是 Router 的 resetConfig 方法，這個方法可以讓我們動態的設定路由。以下就詳細的介紹一下 resetConfig resetConfig(config: Routes) : void Resets the configuration used for navigation and generating links. 1234567router.resetConfig([ &#123; path: 'team/:id', component: TeamCmp, children: [ &#123; path: 'simple', component: SimpleCmp &#125;, &#123; path: 'user/:name', component: UserCmp &#125; ]&#125;]); 我們可以透過這樣子的方式，重新設定路由的規則。 這裡有個地方要注意的是，如果所指定的 component 沒有在現有的路由規則中使用時，則需要再 ngModule的設定檔內的 entryComponents 設定，而這裡也跟要動態產生 component 的情況是一樣的。 進階使用法 那可不可以從 server 端下載路由的設定檔，答案是可以的，但是這裡需要留意的是，從 server 取下來的設定檔，裡面的 component 是文字型態，而路由設定檔的 component 是不能接受文字，只能接受 componentType 型態 所以要從 Angular 的應用程式裡面取得 componentType 的方式，可以參考以下的程式碼 12345678910111213141516171819202122232425262728293031323334353637import &#123; Component, OnInit, ComponentFactoryResolver &#125; from '@angular/core';...class AppComponent implements OnInit &#123; factories = []; constructor(private http: Http, private router: Router, private resolver: ComponentFactoryResolver) &#123; // resolver['_factories'] 可取到 ngModule 裡 bootstrap, // entryComponents 裡定義的 Component this.factories = Array.from(this.resolver['_factories'].values()); &#125; ngOnInit() &#123; ... this.http.get('./routes.json').map(res =&gt; res.json()) .subscribe(data =&gt; &#123; ... this.router.resetConfig(this.processRoute(data)); &#125;) &#125; processRoute(routes: any[]) &#123; let _finalRoutes = []; routes.forEach(r =&gt; &#123; // 根據 componentType 的名稱取回對應的 componentType let factory: any = this.factories.find((x: any) =&gt;&#123; return x.componentType.name === r.component; &#125;); _finalRoutes.push(&#123; path: r.path, component: factory.componentType &#125;) &#125;) return _finalRoutes; &#125;&#125; 以上的寫法，就可以完成從 server 端取得路由設定檔後並更新 Angular 應用程式的路由設定檔，希望這段程式碼對你們有幫助 參考資料 API]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS]使用情境(3)- 利用 BehaviorSubject 來管理使用者登入狀態]]></title>
    <url>%2F2017%2F02%2F26%2Frxjs-context-demo-3%2F</url>
    <content type="text"><![CDATA[RxJS 裡的 Subject 有 4 種類型，Subject、BehaviorSubject、ReplaySubject 和 AsyncSubject，每一種類型的 Subject 都有各自的特性及使用時機，這次會使用 BehaviorSubject來管理使用者的登入狀態 BehaviorSubject BehaviorSubject 與一般的 Subject 有什麼不一樣，差別有兩個 BehaviorSubject 可以給予初始值 每一個 Observer 都可以在註冊的當下，立刻取得目前 BehavoirSubject 的值 (以下皆簡稱為 Subject) 這兩種特性，就非常適合用在使用者登入狀態管理的這種情境 使用情境 使用者登入基本上，狀態就兩種，登入與尚未登入，而每一個頁面都可以在取得該使用者目前的登入狀態。也可以即時知道已登入的使用者登出的時間點。 根據上列的描述，我們會實作一個 UserService，用來執行跟管理使用者的登入，登出行為及狀態。 123456789101112131415161718192021222324252627282930313233343536373839import &#123; Injectable &#125; from '@angular/core';import &#123; BehaviorSubject, Observable &#125; from "rxjs";@Injectable()export class UserService &#123; isLoginSubject = new BehaviorSubject&lt;boolean&gt;(this.hasToken()); /** * 如果有取得token，表示使用者有登入系統 * @returns &#123;boolean&#125; */ private hasToken() : boolean &#123; return !!localStorage.getItem('token'); &#125; /** * 登入使用者，並通知所有訂閱者 */ login() : void &#123; localStorage.setItem('token', 'JWT'); this.isLoginSubject.next(true); &#125; /** * 登出使用者，並通知所有訂閱者 */ logout() : void &#123; localStorage.removeItem('token'); this.isLoginSubject.next(false); &#125; /** * * @returns &#123;Observable&lt;T&gt;&#125; */ isLoggedIn() : Observable&lt;boolean&gt; &#123; return this.isLoginSubject.asObservable(); &#125;&#125; Component 的使用方式 123456789101112131415161718192021222324import &#123; Component, OnInit &#125; from '@angular/core';import &#123; AuthService &#125; from "../auth.service";import &#123; Observable &#125; from "rxjs";@Component(&#123; selector: 'app-main-nav', template: ` &lt;ul&gt; &lt;li *ngIf="!(isLoggedIn | async)" (click)="authService.login()&gt; &lt;a&gt;Login&lt;/a&gt; &lt;/li&gt; &lt;li *ngIf="(isLoggedIn | async)" (click)="authService.logout()"&gt; &lt;a&gt;Logout&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class MainNavComponent implements OnInit &#123; isLoggedIn : Observable&lt;boolean&gt;; constructor( public userService : UserService ) &#123; this.isLoggedIn = userService.isLoggedIn(); &#125;&#125; 這樣子就完成了一個陽春型的使用者登入狀態管理 service。 最後 其實，善用 Subject 與 Subscribe 的特性，可以讓 Component 裡的程式碼減少很多，Component之間的溝通也變得很簡單。 參考資料 BehaviroSubject]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS]使用情境(2)- Component Input watcher]]></title>
    <url>%2F2017%2F02%2F12%2Frxjs-context-demo-2%2F</url>
    <content type="text"><![CDATA[另外一個簡單的使用情境：Angular Component的 @Input Value，我要怎麼持續併動態的根據 @Input Value 取得相對應的資料呢? 假設我有一個 Component，這個 Component 有一個 @Input() 的 id 欄位，我想要根據這個 id 的值，每 5 秒跟主機要一次資料，但是這個 id 有可能會被改變掉，所以從主機要資料回來的條件，也要跟著改變。以下解法，可以參考看看，並非唯一解法。 123456789101112131415161718192021222324252627282930export class DetailComponent implements OnChanges, OnDestroy &#123; @Input() id: number; sub$: Subscription; subject: Subject&lt;any&gt; = new Subject(); data: any; constructor() &#123; this.sub$ = Observable.combineLatest( Observable.timer(0,5000), this.subject, (t, s) =&gt; s) .switchMap(id =&gt; this.getData(id)) .subscribe(x =&gt; this.data = x); &#125; ngOnChanges() &#123; this.subject.next(this.id); &#125; ngOnDestroy() &#123; this.sub$.unsubscribe(); &#125; getData(s) &#123; // here can be http call return Observable.of(s); &#125;&#125; 這裡用到 combineLatest 這個 operator，有三個參數要輸入，前兩個接受 Observable，第三個參數是前兩個 Observable 最後一次分別所產生的資料，可以透過第三個參數將兩條 Stream 資料傳出或是傳給下一個 operator 使用。 以上的程式碼，就可以做到每 5 秒取一次資料，再取資料時，會依當下 id 這個欄位作為取資料的條件。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 使用 ngrx/store 來實做 Redux Style's App]]></title>
    <url>%2F2017%2F02%2F05%2Fangular-ngrx-store%2F</url>
    <content type="text"><![CDATA[Angular 裡面有許多管理 Application State 的方法 ，ngrx 是其中一種。ngrx 提供幾個 libraries 可以讓將 RxJS 與 Redux Style 結合在一起。 設定 為每一個資料集建立一個 Reducer Function，這個 Reducer 就負責用來更新 Store 內的資料。而各個 Reducer 集合起來就是整個應用程式的資料狀態了。下面為Reducer的範例程式 12345678910111213141516171819202122// counter.tsimport &#123; ActionReducer, Action &#125; from '@ngrx/store';export const INCREMENT = 'INCREMENT';export const DECREMENT = 'DECREMENT';export const RESET = 'RESET';export function counterReducer(state: number = 0, action: Action) &#123; switch (action.type) &#123; case INCREMENT: return state + 1; case DECREMENT: return state - 1; case RESET: return 0; default: return state; &#125;&#125; 在 AppModule 下，將Reducer註冊到 Store裡，範例如下 1234567891011import &#123; NgModule &#125; from '@angular/core'import &#123; StoreModule &#125; from '@ngrx/store';import &#123; counterReducer &#125; from './counter';@NgModule(&#123; imports: [ BrowserModule, StoreModule.provideStore(&#123; counter: counterReducer &#125;) ]&#125;)export class AppModule &#123;&#125; 在 Component 要讀取 store內的資料時，程式碼如下 12345678910111213import &#123; Store &#125; from '@ngrx/store';...class MyAppComponent &#123; counter: Observable&lt;number&gt;; constructor(private store: Store&lt;AppState&gt;)&#123; this.counter = store.select('counter'); &#125; ...&#125; 這裡要留意的是， store.select 出來的物件是 Observable 物件。 操作資料的方式，可以透過以下的方式做操作 123456interface Action &#123; type: string; payload?: any;&#125;store.dispatch(&lt;ACTION&gt;action); 1234567891011...class MyAppComponent &#123; constructor(private store: Store&lt;AppState&gt;)&#123; ... &#125; increment()&#123; this.store.dispatch(&#123; type: INCREMENT &#125;); &#125;&#125; Redux的運作流程 Action -&gt; Dispatch -&gt; Reducer -&gt; Store -&gt; View 基本的動作流程是，在 Controller的 method 裡去 Dispatch an Action，之後所有的Reducer都會判斷是否有定義該 Action 行為，如果有的話，就執行該區塊的會重新指定新的資料到 Store 裡。 實際範例 AppModule 1234567891011121314151617181920212223242526272829import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http';import &#123; StoreModule &#125; from '@ngrx/store';import &#123; EffectsModule &#125; from '@ngrx/effects';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; PostReducer &#125; from './post.reducer';import &#123; MyEffects &#125; from './post.effects';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ ... StoreModule.provideStore(&#123; posts: PostReducer &#125;), EffectsModule.runAfterBootstrap(MyEffects) ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 這裡需要自己寫幾個 Function PostReducer PostEffects AppComponent 1234567891011121314151617181920212223242526272829303132333435import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Store &#125; from '@ngrx/store';import &#123; AppState &#125; from './Models/app-state.model';import &#123; Posts, Post, PostComment &#125; from './Models/post.model';import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit &#123; title = 'app works!'; posts: Observable&lt;Posts&gt;; post: Observable&lt;Post&gt;; comment: Observable&lt;PostComment&gt;; constructor(private store: Store&lt;AppState&gt;)&#123; this.posts = store.select(state=&gt; state.posts); // or 你也可以這樣子寫 // this.posts = store.select('posts'); ... &#125; ngOnInit()&#123; this.store.dispatch(&#123;type: "QUERY"&#125;); &#125; display(post: Post)&#123; this.store.dispatch(&#123; type: "DETAIL", payload: post &#125;); &#125;&#125; 123456789101112131415&lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;hr&gt;&lt;ul&gt; &lt;li *ngFor="let post of (posts | async).list"&gt; &lt;span (click)="display(post)"&gt;&#123;&#123; post | json &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &#123;&#123; post | async | json &#125;&#125; &lt;/div&gt;&lt;div&gt; &#123;&#123; comment | async | json &#125;&#125;&lt;/div&gt; AppComponent裡面有兩個動作， 當 OnInit 時，取得 Post 清單。 當點選 Post 時，顯示 Post 的詳細資料及 Comment 資料 這裡會搭配 @ngrx/effects 一起使用，@ngrx/effects 是用來處理任何side-effect的事情，包括 API Call等，這部分的程式碼會寫在 PostEffects裡 PostEffects 123456789101112131415161718192021222324252627282930import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';import &#123; Actions, Effect &#125; from '@ngrx/effects';import &#123; Action &#125; from '@ngrx/store';import &#123; Posts, Post&#125; from './Models/post.model';import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/switchMap';import 'rxjs/add/operator/map';@Injectable()export class PostEffects &#123; constructor(private actions$: Actions, private http: Http) &#123; &#125; @Effect() posts$: Observable&lt;Action&gt; = this.actions$ .ofType("QUERY") .switchMap(action=&gt; &#123; return this.http.get('https://jsonplaceholder.typicode.com/posts') .map(res=&gt;(&#123;type: 'QUERY_SUCCESS', payload: &#123; list: res.json()&#125;&#125;)); &#125;) @Effect() comments$: Observable&lt;Action&gt; = this.actions$ .ofType('DETAIL') .switchMap(action =&gt; this.http.get(`https://jsonplaceholder.typicode.com/posts/$&#123;action.payload.id&#125;/comments`) .map(res =&gt; (&#123; type: 'COMMENT', payload: &#123; detail: action.payload, comment: res.json()&#125; &#125;)) );&#125; @ngrx 提供了effects的 library， 用來處理 side-effect，搭配 RxJS 的 Operator，來組合 service 或是其他的行為，透過這樣子的方式，可以讓資料處理上單純化。 PostReducer 12345678910111213141516171819import &#123; Action &#125; from '@ngrx/store';import &#123; Posts, Post &#125; from './Models/post.model';const initState: Posts = &#123; list: &lt;Post[]&gt;[], detail: &lt;Post&gt;&#123;&#125;, comment: undefined&#125;;export function PostReducer(state: Posts = initState, action: Action) &#123; switch (action.type) &#123; case "QUERY_SUCCESS": return Object.assign(&#123;&#125;, state, action.payload); case "COMMENT": return Object.assign(&#123;&#125;, state, action.payload); default: return state; &#125;&#125; Reducer 是用來更新 Store 的一個 function，每一個的更新是透過給予一個新的值，而不是修改既有的值，這樣子可以避免一些 JavaScript mutable 的問題產生。 結論 @ngrx/store 真的提供一個很簡易但容易管理的 Application State 管理機制。或許在以後的文章可以有更實務上的應用情境。 其實，Redux 也有類似的處理機制，相關的內容可以參閱以下的網址 參考資料 ngrx/store ngrx/effects angular-redux/store Side-Effect Management Using Epics]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 自訂Decorators]]></title>
    <url>%2F2017%2F01%2F30%2Fangular2-decorators%2F</url>
    <content type="text"><![CDATA[Decorators 是 function 掛有 @前綴符號，可以用於 class、paramemter、method 或 property的前面。用來提供額外的資訊。 Angular也將Decorators的功能，應用於本身的架構內，例如 @Component、@NgModule等，本篇文章會討論如果我們也想要自訂Decorators時，我們要怎麼去實作。 自訂Decorator 就如前言所說的，Decorator是一個function, 如果要使用他時，可以在 class/parameter/method/property前面使用 @&lt;function&gt; 就可以了。 一個基本的Decorator會長這樣子 123export function myDecorator(target)&#123; ....&#125; 而使用他的方式如下 123456import &#123; myDecorator &#125; from '...';@myDecoratorexport class class1&#123; ....&#125; 以上就是最基本的使用方式，在decorator的 target 參數，會取得使用者的class/parameter/method/property的程式碼內容 應用情境 Property Decorators 123456789101112131415161718export function ReadOnly(defaultValue) &#123; return (target, key: string) =&gt; &#123; target[key] = defaultValue; Object.defineProperty(target, key, &#123; writable: false &#125;); &#125;&#125;@Component(&#123; ....&#125;)export class AppComponent &#123; @ReadOnly("app works!") title: string; changeTitle() &#123; this.title = 'change app title'; &#125;&#125; 這個例子，是自訂一個ReadOnly的Decorator，功能是讓所設定到的屬性有預設值並且是唯讀狀態, 無法被修改。 如果試著去修改該屬性，如 #16行要做的事情，就會發生錯誤訊息 Class Decorators 如果將Decorators應用在Class上，我們就可以改寫/擴充constructor的行為 123456789101112131415161718192021222324252627export function log(prefix?: string) &#123; return (target) =&gt; &#123; // save a reference to the original constructor var original = target; // a utility function to generate instances of a class function construct(constructor, args) &#123; var c: any = function () &#123; return constructor.apply(this, args); &#125; c.prototype = constructor.prototype; return new c(); &#125; // the new constructor behavior var f: any = function (...args) &#123; console.log(prefix + " - " + original.name); return construct(original, args); &#125; // copy prototype so instanceof operator still works f.prototype = original.prototype; // return new constructor (will override original) return f; &#125;;&#125; 1234567@log("hello world")@Component(&#123; ...&#125;)export class AppComponent &#123; ...&#125; 輸出結果 現有Library有使用自訂Decorators的 ngrx/effects ngrx/store搭配 effects套件，讓angular內在設定redux動作時，變得比較直覺，程式碼也精簡很多 心得 Decorators真的很強大，但是就目前這個階段，我尚未想到到底在哪種情境下是可以使用的，但是早一點知道這個東西的存在也好，因為實作上並不複雜，只是不知道在何時何地會用到他。 參考文件 ngAir 90 - ngrx with Mike Ryan Decorators A deep dive on Angular decorators]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Change Detection]]></title>
    <url>%2F2017%2F01%2F23%2Fangular2-change-detection%2F</url>
    <content type="text"><![CDATA[Angular會讓View上面的結果與Model的值同步，大部分的時候，我們並不需要去管 change detection怎麼運作的，但是，了解 change detection並在適當的時候選擇對的 change detection strategy，可以增加系統的效能 何時會觸發change detection DOM Events (click, keyup, etc) AJAX Requests Timers (setTimeout(), setInterval()) Zone Angular透過Zone來監控上述行為的變化 運作原理 Angular在runtime的時候會為每一個component建立一個Change Detector Change Detector的運行方向是 Top -&gt; Down，在Default模式下，不論是否有改變，仍會繼續往下檢查 而在 OnPush模式下，如果該節點沒有發生異動時，就不會往下檢查了 JS101: Value Types &amp; Reference Types比較 在進入Change Detection Strategy之前，先重新溫習一下Value Types和Reference Type Value Types (Stack Memory) 包含以下類別 string number boolean null undefined 特性 Stack Memory Immutable compared by value copied by value Reference Types (Heap Memory) 包含以下類別 object array function 特性 Heap Memory mutable compared by reference copied by reference Change Detection Strategies Default和 OnPush 細節部份，可參考這篇[Angular] ChangeDetectionStrategy 根據上面的運作原理，我們可以針對個別的Change Detector做策略上的設定，例如下面的圖 OnPush OnPush的設定方法如下列程式碼 12345678910import &#123; Component, Input, ChangeDetectionStrategy &#125; from '@angular/core';@Component(&#123; ... changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class MovieComponent &#123; @Input() movie; ...&#125; 當該Component的changeDetection被設定為ChangeDetectionStrategy.OnPush時，這個Component的檢查關注點就只會在 @Input的這個物件上，所以如果想要讓該Component的 DoCheck被觸發，就必須重新指定新的Input Value。 而這裡應用的的原理是，單獨改變Object內的值而不重新給予一個新的Object，在檢查時，將舊object和異動後的object比較後，結果為兩個是同一個object，所以視為無異動(Reference value的特性) 12345678var obj1 = &#123;title: 'kevin'&#125;;var obj2 = obj1;obj2.title = 'KEVIN';console.log(obj1 == obj2);&gt; trueobj2 = &#123;title: 'KEVIN'&#125;;console.log(obj1 == obj2);&gt; false 結論 用正確的ChangeDetectionStrategy，減少系統檢查資料異動狀態的次數，就可以大大的提升系統的效能。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Router Event]]></title>
    <url>%2F2017%2F01%2F22%2Fangular2-router-event%2F</url>
    <content type="text"><![CDATA[Router Event到底可以怎麼應用，來探討一下吧 enableTracing RouterModule.forRoot 的第二個參數裡，可以透過 enableTracing: true，將路由事件的變化，顯示在console上 1RouterModule.forRoot(routes,&#123; enableTracing: true &#125;) 在console上的顯示結果 Router 也可以從Router的Event內取得跟上面一樣的資訊 12345678910111213141516import &#123; Router, NavigationEnd &#125; from '@angular/router';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; ... constructor(private router: Router) &#123; router.events.filter(event =&gt; event instanceof NavigationEnd) .pairwise().subscribe(event =&gt; &#123; console.log(event); &#125;); &#125;&#125; router.events是屬於持續發生的事件，所以這個監控路由變化的時間點需寫在最上層的component裡，不然就沒有辦法取得旅遊的變化，或是有重複subscribe的情形發生 這裡的程式碼所使用了filter來過濾router event的，我只允許NavigationEnd Event通過， pairwise()是讓Observable的資料，兩個兩個一組的輸出，輸出效果如下 12----1----2----3----4----5----6|---------12---23---34---45---56| 而這一段的程式碼可以讓我們知道路由的變化，例如 知道是從那一個頁面切到目前的頁面。 Navigation Event 每一次導覽的事件，到最後只會有三種狀態：成功，取消，失敗. 有兩種方式可以觀察 router.events 觀察者會有以下幾種事件類型產生 NavigationStart when navigation stars. NavigationEnd when navigation succeeds. NavigationCancel when navigation is canceled. NavigationError when navigation fails. 另外一種是直接呼叫 router.navigate 或是 router.naigateByUrl，這兩種方法會回傳Promise resolve true = navigation succeeds resolve false = navigation gets canceled. reject = navigation fails 但這個並不是這此次的討論範圍內 應用篇 利用上述的特性，我們可以將其加以應用，以下有幾個範例可以參考 Show Spinner 在頁面轉換間，顯示spinner 123456789function isStart(e: Event): boolean &#123; return e instanceof NavigationStart;&#125;function isEnd(e: Event): boolean &#123; return e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError;&#125; 1234567891011router.events.filter(e =&gt; isStart(e) || isEnd(e)) // Returns Observable&lt;boolean&gt;..map(e =&gt; isStart(e)) // Returns Observable&lt;boolean&gt;..distinctUntilChanged() subscribe(showSpinner =&gt; &#123; if (showSpinner) &#123; spinner.show(); &#125; else &#123; spinner.hide(); &#125;&#125;); Custom Error Handler 自訂如果頁面導覽失敗時，可以自訂錯誤訊息 123456789function treatCertainErrorsAsCancelations(error) &#123; if (error isntanceof CancelException) &#123;return false; //cancelation &#125; else &#123;throw error; &#125;&#125;@NgModule(&#123; imports: [RouterModule.forRoot(ROUTES, &#123;errorHandler: treatCertainErrorsAsCanc\elations&#125;)]&#125;)class MailModule &#123;&#125;]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Preloading策略]]></title>
    <url>%2F2017%2F01%2F21%2Fangular2-preloading%2F</url>
    <content type="text"><![CDATA[Angular有提供loadChildren的Lazy loading的模式，也有提供preloadingStrategy的策略模式可供設定，每種設定的方式會影響loadChildren的行為，當然也可以自訂preloading的規則 使用前提 使用ngModule來分類封裝程式 使用router的loadChildren的方法 Router loadChildren的預設行為 預設lazy loading的行為是直到該頁面有被執行時，才會將該部分的js檔案從伺服器端下載到本機，這樣的方法，大大的降低第一次讀取頁面時，所下載的js檔案大小，但是這也帶出另外一個問題，假設我所指定的lazy loading的module是一個很大的module, 那我們原本想要避免的問題，仍存在著。 基於上述理由，Angular提供PreloadingStrategy的設定，讓我們來決定loadChildren的行為，可以設定的方式如下 NoPreloading &lt;預設值&gt; PreloadAllModules 自訂PreloadingStrategy PreloadAllModules 如同在觀看Youtube影片時，Youtube在我們觀看的時候，仍會在背景持續的下載該影片後續的內容到我們的電腦上(那條灰色的進度條)，這樣子的模式，讓我們在觀看影片時，不會有任何lag的情形發生 而PreloadAllModules也是提供一樣的效果，Angular在第一個頁面顯示後，才會陸續的將其他lazyLoading的module下載到本機上，這樣子的話，當使用者瀏覽到該地方時，就不需要再等待下載的時間了，使用者也就不會感受到停頓的感覺。 12345678@NgModule(&#123; imports: [ RouterModule.forRoot(routes, &#123; preloadingStrategy: PreloadAllModules &#125;) ], ...&#125;)export class AppRoutingModule &#123; &#125; 自訂PreloadingStrategy 那如果我想要的效果是，有些事先載入，有些不要的時候，這時我們也可以自訂PreloadingStategy 123456789101112@Injectable()export class SelectivePreloadingStrategy implements PreloadingStrategy &#123; preloadedModules: string[] = []; preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; &#123; if (route.data &amp;&amp; route.data['preload']) &#123; return load(); &#125; else &#123; return Observable.of(null); &#125; &#125;&#125; 上述的規則是，如果路由設定的data有指定preload，而且該值為真實，則會執行預先載入，反之，則不會。 1234567891011@NgModule(&#123; imports: [ RouterModule.forRoot(routes, &#123; preloadingStrategy: SelectivePreloadingStrategy &#125;) ], providers: [ SelectivePreloadingStrategy ] ...&#125;)export class AppRoutingModule &#123; &#125; 結論 如果想要提升效能跟使用者體驗的話，善用NgModule 、Lazy Loading與preloadingStrategy就可以達到非常好的效果 參考資料 ROUTING &amp; NAVIGATION]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]Laravel 5.3邂逅]]></title>
    <url>%2F2017%2F01%2F15%2Fangular2-laravel%2F</url>
    <content type="text"><![CDATA[Laravel 5.x版以後樣板的部分就內建使用Vue.js的方法。 假設今天我想要使用Angular CLI方式搭配Laravel的方式來開發，那又應該怎麼做呢，以下提供一個方式，歡迎討論 建立Laravel專案 修改路由設定檔，routes/web.php 123456789101112131415161718192021222324&lt;?php/*|--------------------------------------------------------------------------| Web Routes|--------------------------------------------------------------------------|| Here is where you can register web routes for your application. These| routes are loaded by the RouteServiceProvider within a group which| contains the "web" middleware group. Now create something great!|*/// put all your REST routes inside api-groupRoute::group(['prefix' =&gt; 'api'], function() &#123; &#125;);Auth::routes();// this route is for Angular and it should be placed after all other back end routes// just keep it at the bottomRoute::get('/&#123;any&#125;', function ($any) &#123; return view('welcome');&#125;)-&gt;where('any', '.*'); ​ 建立Angular專案 使用CLI來建立專案 在laravel的根目錄下，執行以下指令 1ng new &lt;projectName&gt; --routing --skip-commit 或是，自己新增一個存放的資料夾後並切換到該資料夾下，執行以下指令 1ng init &lt;projectName&gt; --routing --skip-commit 執行完後，一個Angular的專案就建置完成了 設定proxy.conf.json 新增proxy.config.json檔案，依Laravel serve的網站位置做修改 123456&#123; "/api": &#123; "target": "http://localhost:8000", "secure": false &#125;&#125; 修改pageage.json的scripts部分 1234"scripts": &#123; "start": "ng serve --proxy-config proxy.conf.json", ... &#125; ​ 設定angular-cli.json 將laravel專案的public資料夾下的檔案都複製到angular專案的src資料夾下 index.php .htaccess robots.txt web.config 將那些檔案都新增到angular-cli.json的assets區段內 設定outDir到laravel的publich資料夾路徑 開發時期 在開發時期，因為上述的設定方式，已經讓前端與後端完全的切割了，所以在開發時期就可以分別開發。 Angular的網站可以透過npm start的方式去執行ng serve with proxy config的動作，由於proxy會將api相關的呼叫，對應到laravel的網站去，所以在呼叫api的部分，就不需要額外去指定host url的部分 Laravel後端的部分，就專心於API資料的提供等動作 部屬Laravel專案 如果要部署的時候，Angular可以透過以下的指令將Angular的程式bundle/AOT輸出到所設定的輸出目錄下 1ng build --prod --aot --output-hashing=media —output-hasing的參數是在angular-cli beta25.5版以後提供的，可以設定所輸出的bundle是否要加上hash值 輸出到Laravel專案的public資料夾下會有一個index.html的檔案，將該檔案的內容複製到laravel起始頁面的blade.php檔案(預設: welcome.blade.php) (第一次修改即可) 依Laravel部署網站的方式部署即可]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Laravel5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]Router Guards]]></title>
    <url>%2F2017%2F01%2F14%2Fangular-router-canactivate%2F</url>
    <content type="text"><![CDATA[通常我們會希望限制某些網址只有某特定規則者才可以進入或離開，Angular的Router提供了一系列的個方法來幫助我們 Angular的Router提供了一系列的方法，可以讓我們來決定是否允許使用者進入或是離開頁面 CanActivate : 避免瀏覽到該網址 CanActivateChild : 讓子路由套用CanActivate規則，避免瀏覽到該網址 CanDeactivate : 避免離開目前的網址 Resolve : 在前往瀏覽網頁前先預載資料 CanLoad : 避免載入非同步的路由設定 CanActivate 12345678910import &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class AuthGuard implements CanActivate &#123; canActivate() &#123; console.log('AuthGuard#canActivate called'); return true; &#125;&#125; 這是基本的CanActivate的程式架構，而在Route的地方，設定的方式如下 123456const adminRoutes: Routes = [ &#123; path: 'admin', component: AdminComponent, canActivate: [AuthGuard] &#125;]; canActivate回傳true時，可以進入，回傳false時，無法進入 進階應用 canActivate接受Observable型態的function，範例如下 12345678910111213@Injectable()export class AuthGuard implements CanActivate &#123; constructor(private authService: AuthService, private router: Router) &#123;&#125; canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; &#123; return Observable.of(true).delay(1000) .do(val =&gt; &#123; if(val == false)&#123; this.router.navigate(['/login']); &#125; &#125;); &#125;&#125; CanActivateChild 123456789101112131415@Injectable()export class AuthGuardService implements CanActivate &#123; constructor() &#123; &#125; canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123; console.log('AuthGuard#canActivate called'); return true; &#125; canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean &#123; console.log('AuthGuard#canActivateChild called'); return this.canActivate(route, state); &#125;&#125; Route Config的地方 123456789&#123; path: 'page1', component: Page1Component, canActivateChild: [ AuthGuardService ], children: [ &#123; path: '', component: Page1DetailComponent &#125; ] &#125; 這樣的設定方式，會讓每一個child Route都會跑canActivate的方法，就不需要一個一個的設定了，非常方便 CanDeactivate canDeactivate比較特殊，可以搭配Component一起使用 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';import &#123; CanDeactivate &#125; from '@angular/router';import &#123; Observable &#125; from 'rxjs/Observable';export interface CanComponentDeactivate &#123; canDeactivate: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;&#125;@Injectable()export class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; &#123; canDeactivate(component: Page2Component, route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123; return component.canDeactivate ? component.canDeactivate() : true; &#125;&#125; Component需Implements上述的CanComponentDeactivate Interface, 才可以讓CanDeactivateGuard作用 當canDeactivate() 回傳 false時，則無法離開該頁面，回傳 true時，才可以離開 Resolve 請參考[Angular] Router Resolve CanLoad CanLoad會封住PRELOAD的功能，我們需要使用PRELOAD來增加效能，所以這裡建議使用CanActivate來控制 至於Preloading Strategy就待下回分曉 ​ 參考資料 ROUTING &amp; NAVIGATION]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS]使用情境(1)-FB爬文]]></title>
    <url>%2F2017%2F01%2F08%2Frxjs-context-demo-1%2F</url>
    <content type="text"><![CDATA[這一篇利用Facebook的GraphAPI+RxJS的方式，來爬Facebook的文章. 基本流程是 步驟1: 先從一個粉絲頁的id 步驟2: 再從粉絲頁去按讚的id擴展下去 步驟2-1: 讀取該粉絲頁的文章(post) 步驟2-2: 如果還有下一頁，根據paging.next的url重複步驟2-2 步驟3: 第二個粉絲頁重複步驟1 步驟4: 將讀取的post顯示在畫面上 Facebook Graph API facebook提供GraphAPI的方式可以撈到Facebook Page的相關資料，例如他有按讚的其他專頁，該專頁發佈的文章，利用這樣的特性，就可以利用一個粉絲專頁擴展下去 相關的訊息可以到 facebook for developers查詢 AngularFire2 我利用AngularFire2的Facebook Auth的方式取得accessToken, 詳細使用方式，請參閱GitHub Repo 這裡就不多解釋 範例程式碼 基本功能 組合GraphSQL的查詢網址 123combineUrl(id, fields) &#123; return `https://graph.facebook.com/v2.8/$&#123;id&#125;?fields=$&#123;fields&#125;&amp;access_token=$&#123;this.accessToken&#125;`; &#125; 查詢粉絲團有按過的讚 1234567891011// 查詢按讚資料queryLikes(id) &#123; let url = this.combineUrl(id, 'likes'); return this.http.get(url).map(res =&gt; res.json()) .mergeMap(data =&gt; &#123; if (data.likes) return Observable.from(data.likes.data); else return Observable.empty(); &#125;)&#125; mergemap return new Observable Observable.from將一個Array轉換成一個一個的資料 1234567var arr = [1,2,3];Observable.from(arr).subscribe(data=&gt;&#123; console.log(data);&#125;)// output: 1// output: 2// output: 3 Observable.empty()回傳一個完成狀態的空Observable queryLikes(id)回傳的資料格式 12345678910111213141516171819202122&#123; "likes": &#123; "data": [ &#123; "name": "Microsoft Visual Studio", "id": "102038129831681" &#125;, &#123; "name": "Microsoft Taiwan", "id": "395317217235059" &#125;, ... ], "paging": &#123; "cursors": &#123; "before": "MTAyMDM4MTI5ODMxNjgx", "after": "MTk5MTgyNTMzNDUzMjU4" &#125; &#125; &#125;, ...&#125; 查詢粉絲頁發佈的文章 1234567891011121314// 查詢文章queryPost(id) &#123; let url = this.combineUrl(id, 'posts'); console.log(url); return this.http.get(url).map(res =&gt; res.json()) .map(data =&gt; data.posts); .expand(data =&gt; &#123; if (data.paging.next) &#123; return this.queryNextPage(data.paging.next); &#125; else &#123; return Observable.empty(); &#125; &#125;);&#125; （重點) expand 遞迴產生新的Observable expand會將內部回傳的Observable產生新的一條資料流 123456789101112131415161718a().expand(data=&gt;&#123; if(condition) return 'complete state Observable'; else return b();&#125;)----&gt;b().expand(data=&gt;&#123; if(condition) return 'complete state Observable'; else return b(); &#125;)----&gt; b().expand(data=&gt;&#123; if(condition) return 'complete state Observable'; else return b(); &#125;) .... 所以基本上，就把expand的運作方式跟遞迴方法的運作方式是一樣的 回傳結果 123456789101112131415161718192021222324&#123; "posts": &#123; "data": [ &#123; "message": "Today's Xamarin Snack Pack Show w/ James Montemagno - http://spr.ly/61898OAJ1 - how to get started using Xamarin Workbooks, Interactive documentation tool for exploring a myriad of topics, from the basics of the C# language to fundamentals of computer science and advanced topics surrounding mobile application development.", "created_time": "2017-01-07T00:26:03+0000", "id": "102038129831681_1188325814536235" &#125;, &#123; "message": "Connect(); // 2016 Session On Demand: SQL Server on Linux: use SQL Tools with SQL Server, http://spr.ly/61898O4PULearn about working with SQL Tools from your platform of choice with SQL Server on Linux. We'll show you how to use SQL Server Management Studio (SSMS) and SQL Server Data Tools (SSDT) with SQL Server on Linux. We'll also show you new cross-platform SQL tooling experiences that are available now in Visual Studio Code on Linux, macOS, and Windows.", "created_time": "2017-01-06T20:35:03+0000", "id": "102038129831681_1188219874546829" &#125; ... ], "paging": &#123; "previous": "https://graph.facebook.com/v2.8/102038129831681/posts?since=1483748763&amp;access_token=EAACEdEose0cBABoGAAqt7WETzqNjXUZBtq6o79mxOdkxrSpwSRp8zTiJHgbGv17AdWXf6mDZBNiZAGmcGjfdVVsghNgGTBjc6ldlAZB2dxwXxSvm9LvEe17bcUqZA5mVztwYjik3uGUnAxT49AjiL0TCYxVx2PUOhKMbOasAIhwZDZD&amp;limit=25&amp;__paging_token=enc_AdBPC2zAP0PXPi25e6aNZBdZA84vevZAF0d7ZB2Y3rMxwaza4UOBaMY90NY8Wk7XHLYHBooiINQQGGdgCeGDoB47yE13L7q7C6HqQMIeKZBnYAGdDZBQZDZD&amp;__previous=1", "next": "https://graph.facebook.com/v2.8/102038129831681/posts?access_token=EAACEdEose0cBABoGAAqt7WETzqNjXUZBtq6o79mxOdkxrSpwSRp8zTiJHgbGv17AdWXf6mDZBNiZAGmcGjfdVVsghNgGTBjc6ldlAZB2dxwXxSvm9LvEe17bcUqZA5mVztwYjik3uGUnAxT49AjiL0TCYxVx2PUOhKMbOasAIhwZDZD&amp;limit=25&amp;until=1482769022&amp;__paging_token=enc_AdBrD7ij1AmakbpdTZBZBWlkHTnuLKyUa2CCa0h6nhojVTa2SDOb3Bg5nJaUBkDjZC2Azk51C4o9DadNDveK5OuKHFsPU7blZBdDP5DTGFt5bysmvAZDZD" &#125; &#125;, ...&#125; 如果還有下一頁資料時，繼續讀取的方法 1234// 查詢下一頁的文章queryNextPage(url) &#123; return this.http.get(url).map(res =&gt; res.json());&#125; 開始執行 1234567891011121314151617start()&#123; let startId = 'xxxxx'; this.queryLikes(startId) .expand((page: any) =&gt; &#123; if (page &amp;&amp; !this.cancelling) return this.queryLikes(page.id).delay(3000); else return Observable.empty(); &#125;) .take(10) .mergeMap(page =&gt; &#123; return this.queryPost(page.id) &#125;) .subscribe(posts =&gt; &#123; this.list = [...this.list, ...posts.data]; &#125;)&#125; 這樣子就可以爬出很多文章了. 小備註: take(10) 只是我用來限制撈資料的次數而已 ​ 執行結果]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 學習筆記(2) - Angular 2 — Testing Guide]]></title>
    <url>%2F2017%2F01%2F07%2Fangular-test-learning-note%2F</url>
    <content type="text"><![CDATA[Angular 2 — Testing Guide的閱讀筆記，這篇文章是由 Gerard Sans撰寫的 這篇文章包含Angular Application的基本單元測試，像是Components, Services, Http and Pipes. 該文章有提供另外一個Testing Checklist 幫助建立測試 Jasmine的基本介紹 Jasmine有幾個基本的元素 Suites - describe(title:string, function) : 基本容器. 用來裝 Specs. Specs - it(title:string, function): 基本測試單位，裡面可以包含一個或多個expectations expectations - expect(actual).toBe(expected) 用來比對測試結果與預期結果 Matchers - 預先設定的運算式, Eg. toBe(expected), toEqual(expected), 更多 Jasmine有提供4個handlers，來處理一些在測試前或是測試後可以額外執行的動作 beforeEach, afterEach 於每一個 spec 前後執行 beforeAll,afterAll 於每一個 Suit 前後執行 可以透過上列的方式避免重複程式碼的產生 Angular 測試 TestBed: 在測試裡面建立ngModule，設定方式與一般設定ngModule一樣，提供方法讓測試案例裡可以取得想要測試的component/service等 12345678910111213141516@NgModule(&#123; declarations: [ ComponentToTest ] providers: [ MyService ]&#125;) mockMyService = &#123;&#125;;class AppModule &#123; &#125;TestBed.configureTestingModule(&#123; declarations: [ ComponentToTest ], providers: [ &#123;provide: MyService, useValue: mockMyService&#125; ] &#125;);//get instance from TestBed (root injector)let service = TestBed.get(MyService); Inject: 允許我們在TestBed Level取得dependencies 123it('should return ...', inject([MyService], service =&gt; &#123; service.foo();&#125;)); Component Injector: 允許我們在Component Level取得dependencies 123456@Component(&#123; providers: [ MyService ] &#125;) class ComponentToTest &#123; &#125;let fixture = TestBed.createComponent(ComponentToTest);let service = fixture.debugElement.injector.get(MyService); 如果DI是在Component裡面定義的話，只能透過上述方法才能取得. TestBed.get或是Inject是取不到的 service測試的範例程式 12345678910111213141516describe('Service: LanguagesService', () =&gt; &#123; let service; beforeEach(() =&gt; TestBed.configureTestingModule(&#123; providers: [ LanguagesService ] &#125;)); beforeEach(inject([LanguagesService], s =&gt; &#123; service = s; &#125;)); it('should return available languages', () =&gt; &#123; expect(service.get()).toContain('en'); &#125;);&#125;); 產生component的方式 1234567891011// synchronous beforeEach(() =&gt; &#123; fixture = TestBed.createComponent(MyTestComponent); &#125;);// asynchronous beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [ MyTestComponent ], &#125;).compileComponents(); // compile external templates and css &#125;)); 用非同步的方式產生component, 這方式同時間會產生zone來負責所有非同步的行為 Testing Checklist 需要決定測試的種類: Isoldated, shallow or integration 參閱 應該使用 Mocks、Stubs or Spies? 同步或非同步? 測試範例 Component 要測試的Component 123456789// Usage: &lt;greeter name="Joe"&gt;&lt;/greeter&gt; // Renders: &lt;h1&gt;Hello Joe!&lt;/h1&gt;@Component(&#123; selector: 'greeter', template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/h1&gt;`&#125;)export class Greeter &#123; @Input() name;&#125; Angular建議使用TestBed來產生component 1234567891011121314151617181920212223242526describe('Component: Greeter', () =&gt; &#123; let fixture, greeter, element, de; //setup beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [ Greeter ] &#125;); fixture = TestBed.createComponent(Greeter); greeter = fixture.componentInstance; // to access properties and methods element = fixture.nativeElement; // to access DOM element de = fixture.debugElement; // test helper &#125;); //specs it('should render `Hello World!`', async(() =&gt; &#123; greeter.name = 'World'; //trigger change detection fixture.detectChanges(); fixture.whenStable().then(() =&gt; &#123; expect(element.querySelector('h1').innerText).toBe('Hello World!'); expect(de.query(By.css('h1')).nativeElement.innerText).toBe('Hello World!'); &#125;); &#125;));&#125;) fixture是用來讀取component的方法. 他有下列的方法 123456abstract class ComponentFixture &#123; debugElement; // test helper componentInstance; // to access properties and methods nativeElement; // to access DOM element detectChanges(); // trigger component change detection&#125; whenStable是當所有非同步的行為都完成後，會執行whenStable，這時，就可以取得應有的結果 其他讀取搜尋debugElement的方式: query(By.all()) query(By.directive(MyDirective)) Service 要測試的serivce範例 123456//a simple serviceexport class LanguagesService &#123; get() &#123; return ['en', 'es', 'fr']; &#125;&#125; 類似測試Component的方式，一樣使用TestBed來產生Service. 12345678910111213141516171819describe('Service: LanguagesService', () =&gt; &#123; let service; beforeEach(() =&gt; TestBed.configureTestingModule(&#123; providers: [ LanguagesService ] &#125;)); beforeEach(inject([LanguagesService], s =&gt; &#123; service = s; &#125;)); it('should return available languages', () =&gt; &#123; let languages = service.get(); expect(languages).toContain('en'); expect(languages).toContain('es'); expect(languages).toContain('fr'); expect(languages.length).toEqual(3); &#125;);&#125;); Using Http 通常在測試階段不會做任何HTTP call. 但是還是簡單介紹一下，因為這時需要使用到HttpModule 要測試的Service程式碼 12345678export class LanguagesServiceHttp &#123; constructor(private http:Http) &#123; &#125; get()&#123; return this.http.get('api/languages.json') .map(response =&gt; response.json()); &#125;&#125; 測試 1234567891011121314151617181920212223describe('Service: LanguagesServiceHttp', () =&gt; &#123; let service; //setup beforeEach(() =&gt; TestBed.configureTestingModule(&#123; imports: [ HttpModule ], // 如果有相依其他的Module, 在此定義 providers: [ LanguagesServiceHttp ] &#125;)); beforeEach(inject([LanguagesServiceHttp], s =&gt; &#123; service = s; &#125;)); //specs it('should return available languages', async(() =&gt; &#123; service.get().subscribe(x =&gt; &#123; expect(x).toContain('en'); expect(x).toContain('es'); expect(x).toContain('fr'); expect(x.length).toEqual(3); &#125;); &#125;));&#125;) Using MockBackend 由於測試時不呼叫真實的後端API, 就會寫一個假的來模擬替代真實的呼叫 123456789101112131415161718192021222324252627282930313233describe('MockBackend: LanguagesServiceHttp', () =&gt; &#123; let mockbackend, service; //setup beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [ HttpModule ], providers: [ LanguagesServiceHttp, &#123; provide: XHRBackend, useClass: MockBackend &#125; ] &#125;) &#125;); beforeEach(inject([LanguagesServiceHttp, XHRBackend], (_service, _mockbackend) =&gt; &#123; service = _service; mockbackend = _mockbackend; &#125;)); //specs it('should return mocked response (async)', async(() =&gt; &#123; let response = ["ru", "es"]; // 模擬後端Response的結果 mockbackend.connections.subscribe(connection =&gt; &#123; connection.mockRespond(new Response(&#123;body: JSON.stringify(response)&#125;)); &#125;); service.get().subscribe(languages =&gt; &#123; expect(languages).toContain('ru'); expect(languages).toContain('es'); expect(languages.length).toBe(2); &#125;); &#125;)); &#125;) Directive 因為Directive沒有view, 而且是相依在dom上，所以必須建立一個component容器來測試directive 123456789101112131415// Example: &lt;div log-clicks&gt;&lt;/div&gt;@Directive(&#123; selector: "[log-clicks]"&#125;)export class logClicks &#123; counter = 0; @Output() changes = new EventEmitter(); @HostListener('click', ['$event.target']) clicked(target) &#123; console.log(`Click on [$&#123;target&#125;]: $&#123;++this.counter&#125;`); //we use emit as next is marked as deprecated this.changes.emit(this.counter); &#125;&#125; 測試 12345678910111213141516171819202122232425262728293031323334353637383940414243// 用來測試Directive的容器Component@Component(&#123; selector: 'container', template: `&lt;div log-clicks (changes)="changed($event)"&gt;&lt;/div&gt;`, directives: [logClicks]&#125;)export class Container &#123; @Output() changes = new EventEmitter(); changed(value)&#123; this.changes.emit(value); &#125;&#125;describe('Directive: logClicks', () =&gt; &#123; let fixture; let container; let element; //setup beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [ Container, logClicks ] &#125;); fixture = TestBed.createComponent(Container); container = fixture.componentInstance; // to access properties and methods element = fixture.nativeElement; // to access DOM element &#125;); //specs it('should increment counter', fakeAsync(() =&gt; &#123; let div = element.querySelector('div'); //set up subscriber container.changes.subscribe(x =&gt; &#123; expect(x).toBe(1); &#125;); //trigger click on container div.click(); //execute all pending asynchronous calls tick(); &#125;));&#125;) fakeAsync 所有的非同步行為會被暫停直到 呼叫tick fakeAsync / tick 不能跟XHR一起使用 Pipe Pipe很容易測試，很單純的Class 123456789101112import &#123;Pipe, PipeTransform&#125; from '@angular/core';@Pipe(&#123; name: 'capitalise'&#125;)export class CapitalisePipe implements PipeTransform &#123; transform(value: string): string &#123; if (typeof value !== 'string') &#123; throw new Error('Requires a String as input'); &#125; return value.toUpperCase(); &#125;&#125; 測試 12345678910111213141516171819202122232425262728describe('Pipe: CapitalisePipe', () =&gt; &#123; let pipe; //setup beforeEach(() =&gt; TestBed.configureTestingModule(&#123; providers: [ CapitalisePipe ] &#125;)); beforeEach(inject([CapitalisePipe], p =&gt; &#123; pipe = p; &#125;)); //specs it('should work with empty string', () =&gt; &#123; expect(pipe.transform('')).toEqual(''); &#125;); it('should capitalise', () =&gt; &#123; expect(pipe.transform('wow')).toEqual('WOW'); &#125;); it('should throw with invalid values', () =&gt; &#123; //must use arrow function for expect to capture exception expect(()=&gt;pipe.transform(undefined)).toThrow(); expect(()=&gt;pipe.transform()).toThrow(); expect(()=&gt;pipe.transform()).toThrowError('Requires a String as input'); &#125;);&#125;) Routes 123456789101112131415161718192021222324252627@Component(&#123; selector: 'my-app', template: `&lt;router-outlet&gt;&lt;/router-outlet&gt;`&#125;)class TestComponent &#123; &#125;@Component(&#123; selector: 'home', template: `&lt;h1&gt;Home&lt;/h1&gt;`&#125;)export class Home &#123; &#125;export const routes: Routes = [ &#123; path: '', redirectTo: 'home', pathMatch: 'full' &#125;, &#123; path: 'home', component: Home &#125;, &#123; path: '**', redirectTo: 'home' &#125;];@NgModule(&#123; imports: [ BrowserModule, RouterModule.forRoot(routes), ], declarations: [TestComponent, Home], bootstrap: [TestComponent], exports: [TestComponent] &#125;)export class AppModule &#123;&#125; 測試 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; RouterTestingModule &#125; from '@angular/router/testing';describe('Router tests', () =&gt; &#123; //setup beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [ RouterTestingModule.withRoutes(routes), AppModule ] &#125;); &#125;); // 3 way to test Router // async it('can navigate to home (async)', async(() =&gt; &#123; let fixture = TestBed.createComponent(TestComponent); TestBed.get(Router) .navigate(['/home']) .then(() =&gt; &#123; expect(location.pathname.endsWith('/home')).toBe(true); &#125;).catch(e =&gt; console.log(e)); &#125;)); // fakeAsync/tick it('can navigate to home (fakeAsync/tick)', fakeAsync(() =&gt; &#123; let fixture = TestBed.createComponent(TestComponent); TestBed.get(Router).navigate(['/home']); fixture.detectChanges(); //execute all pending asynchronous calls tick(); expect(location.pathname.endsWith('/home')).toBe(true); &#125;)); // done it('can navigate to home (done)', done =&gt; &#123; let fixture = TestBed.createComponent(TestComponent); TestBed.get(Router) .navigate(['/home']) .then(() =&gt; &#123; expect(location.pathname.endsWith('/home')).toBe(true); done(); &#125;).catch(e =&gt; console.log(e)); &#125;);&#125;); Observables 如何測試Observable 1234567891011121314151617181920212223242526describe('Observable: basic observable', () =&gt; &#123; var basic$; //setup beforeEach(() =&gt; &#123; basic$ = new Observable(observer =&gt; &#123; //pushing values observer.next(1); observer.next(2); observer.next(3); //complete stream observer.complete(); &#125;); &#125;) //specs it('should create the expected sequence (async)', async(() =&gt; &#123; let expected = [1,2,3], index = 0; basic$ .subscribe(&#123; next: x =&gt; expect(x).toEqual(expected[index++]), error: e =&gt; console.log(e) &#125;); &#125;));&#125;); EventEmitters 12345678910111213141516171819202122@Component(&#123; selector: 'counter', template: ` &lt;div&gt; &lt;h1&gt;&#123;&#123;counter&#125;&#125;&lt;/h1&gt; &lt;button (click)="change(1)"&gt;+1&lt;/button&gt; &lt;button (click)="change(-1)"&gt;-1&lt;/button&gt; &lt;/div&gt;`&#125;)export class Counter &#123; @Output() changes = new EventEmitter(); constructor()&#123; this.counter = 0; &#125; change(increment) &#123; this.counter += increment; //we use emit as next is marked as deprecated this.changes.emit(this.counter); &#125;&#125; 測試方式類似Observable 123456789101112131415161718192021222324252627describe('EventEmitter: Counter', () =&gt; &#123; let counter; //setup beforeEach(() =&gt; TestBed.configureTestingModule(&#123; providers: [ Counter ] &#125;)); beforeEach(inject([Counter], c =&gt; &#123; counter = c; &#125;)) //specs it('should increment +1 (async)', async(() =&gt; &#123; counter.changes.subscribe(x =&gt; &#123; expect(x).toBe(1); &#125;); counter.change(1); &#125;)); it('should decrement -1 (async)', async(() =&gt; &#123; counter.changes.subscribe(x =&gt; &#123; expect(x).toBe(-1); &#125;); counter.change(-1); &#125;));&#125;)]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 學習筆記(1) - Techniques and practices for testing Angular 2]]></title>
    <url>%2F2017%2F01%2F05%2Fangular2-ssw-testing-angular2-note%2F</url>
    <content type="text"><![CDATA[這是Youtube影片(Techniques and practices for testing Angular 2)的觀看筆記 這影片前半段是在介紹Angular2內可以使用的測試方法，由簡單的小範例逐一介紹各方法 影片筆記 工具 karma - test runner jasmine - test library 123456789// syntax exampledescribe('Component: payment', ()=&gt;&#123; it('should instantiate a component', ()=&gt;&#123; execpt(1+1).toEqual(2); &#125;) it('should instantiate a component', ()=&gt;&#123; execpt(1+1).toEqual(2); &#125;)&#125;) wallaby.js - not free display unit test result and status inline the code. angular-cli has test ability build-in test command ng test ng e2e protractor(e2e) 為什麼要測試 因為越來愈多的商業邏輯都往前端走，所以前端的測試就越來越重要了 測試的種類 Unit tests: Test certain functions, areas of units of code e2e test: Runs the real application in the browser and simulateds user behavior ​ Unit Tests的型態 Isolated: No HTML template Shallow: HTML template No Child components integrated Test the entire app ​ Isolated tests jasmine test file is : *.spec.ts(js) 123456describe('Component: payment component', ()=&gt;&#123; it('should add numbers correctly', ()=&gt;&#123; execpt(1+1).toEqual(2); &#125;) ...&#125;) 12345678910111213141516import &#123; PaymentComponent &#125; from './payment.component';describe('Component: payment component', ()=&gt;&#123; it('should have correct title', ()=&gt;&#123; const component = new PaymentComponent(null); execpt(component.formTitle).toEqual('Payment Form'); &#125;); // this is something should test it('should return validate valid credit card number', ()=&gt;&#123; const component = new PaymentComponent(null); let regex = new RegExp(component.CREDIT_CARD_NUMBER_PATTERN); let result = regex.test('aa'); execpt(result).toEqual(true); &#125;)&#125;) Shollow tests - Mocking and Spy’s Mock Service 123mockPaymentService = &#123; processPayment : ()=&gt;&#123;&#125;;&#125; Jasmine Spy spyOn(Object, 『method name』) .and. except(spy).toHaveBeenCalled, etc. 12345678910111213141516171819202122import &#123; PaymentComponent &#125; from './payment.component';describe('Component: payment component', ()=&gt;&#123; let component: PaymentComponent; mockPaymentService: any; beforeEach(()=&gt;&#123; mockPaymentService = &#123; processPayment: ()=&gt;&#123; &#125; &#125; component = new PaymentCompoent(mockPaymentService); &#125;) ... it('should call the payment service.processmethod on submit',()=&gt;&#123; let spy = spyOn(mockPaymentService, 'processPayment'); commponent.processPayment(); // =&gt; method to run PaymentService.processPayment except(spy).toHaveBeenCalled(); &#125;) &#125;) Shollow test - TestBed and Dom access 12345678910111213141516171819// 基本設定TestBed.configureTestingModule(&#123; declarations:[ PaymentComponent ], imports:[ FormsModule ], pvoiders:[ &#123;provide: PaymentService, useValue: mockPaymentService&#125; ]&#125;);// 基本用法fixgure = TestBed.createComponent(PaymentComponent);component = fixture.componentInstance;mockPaymentService = TestBed.get(PaymentServie);// 取得template內某一個物件的nativeElement(HTMLElement)let nativeButtonElement = fixture.debugElement.query(By.css('button')).nativeElement; 範例程式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; PaymentComponent &#125; from './payment.component';import &#123; TestBed, ComponentFixture &#125; from '@angular/core/testing';import &#123; By &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';describe('Component: payment component', ()=&gt;&#123; let component: PaymentComponent; let mockPaymentService: any; let fixture: ComponentFixture&lt;PaymentComponent&gt;; beforeEach(()=&gt;&#123; mockPaymentService = &#123; processPayment: ()=&gt;&#123; &#125; &#125; TestBed.configureTestingModule(&#123; declarations:[ PaymentComponent ], imports:[ FormsModule ], providers:[ &#123;provide: PaymentService, useValue: mockPaymentService&#125; ] &#125;) fixture = TestBed.createComponent(PaymentComponent); component = fixture.componentInstance; mockPaymentSerivce = TestBed.get(PaymentService); &#125;) ... it('should purchase button enabled if credit card valid',()=&gt;&#123; component.payment.creditCardNumber = '1234123412341234'; fixture.detectChanges(); let nativeButtonElement = fixture.debugElement.query(By.css('button')) .nativeElement; // 等非同步動作完成後 fixture.whenStable().then(()=&gt;&#123; // 重新觸發detectChanges() fixture.detectChanges(); execpt(nativeButtonElement.disabled).toEqual(false); &#125;) &#125;) &#125;) e2e 12345678910111213import &#123; element, by, browser &#125; from 'protractor';describe('page: payment Form',async ()=&gt;&#123; it('should a active button with a valid form',()=&gt;&#123; browser.get('./'); element(by.css('input')).sendKeys('1234123412341234'); let submitButton = element(by.css('button')); let isDisabled = await submitButton.getAttribute('disabled'); // return promise; except(isDisabled).toEqual(null); &#125;)&#125;); 其他筆記 設定wallaby.js環境 在專案下新增wallaby.js檔案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var wallabyWebpack = require('wallaby-webpack');var webpackPostprocessor = wallabyWebpack(&#123; entryPatterns: [ 'src/wallabyTest.js', 'src/**/*spec.js' ], module: &#123; loaders: [ &#123;test: /\.css$/, loader: 'raw-loader'&#125;, &#123;test: /\.html$/, loader: 'raw-loader'&#125;, &#123;test: /\.js$/, loader: 'angular2-template-loader', exclude: /node_modules/&#125;, &#123;test: /\.json$/, loader: 'json-loader'&#125;, &#123;test: /\.styl$/, loaders: ['raw-loader', 'stylus-loader']&#125;, &#123;test: /\.less$/, loaders: ['raw-loader', 'less-loader']&#125;, &#123;test: /\.scss$|\.sass$/, loaders: ['raw-loader', 'sass-loader']&#125;, &#123;test: /\.(jpg|png)$/, loader: 'url-loader?limit=128000'&#125; ] &#125;&#125;);var compilerOptions = require('./src/tsconfig.json').compilerOptions;module.exports = function (wallaby) &#123; return &#123; files: [ &#123;pattern: 'src/**/*.ts', load: false&#125;, &#123;pattern: 'src/**/*.d.ts', ignore: true&#125;, &#123;pattern: 'src/**/*.css', load: false&#125;, &#123;pattern: 'src/**/*.html', load: false&#125;, &#123;pattern: 'src/**/*spec.ts', ignore: true&#125; ], tests: [ &#123;pattern: 'src/**/*spec.ts', load: false&#125; ], testFramework: 'jasmine', compilers: &#123; '**/*.ts': wallaby.compilers.typeScript(compilerOptions) &#125;, postprocessor: webpackPostprocessor, setup: function () &#123; window.__moduleBundler.loadTests(); &#125;, debug: true &#125;;&#125;; 在 src資料夾下新增 wallabyTest.ts 123456789101112131415import './polyfills.ts';import 'zone.js/dist/long-stack-trace-zone';import 'zone.js/dist/proxy.js';import 'zone.js/dist/sync-test';import 'zone.js/dist/jasmine-patch';import 'zone.js/dist/async-test';import 'zone.js/dist/fake-async-test';var testing = require('@angular/core/testing');var testingBrowser = require('@angular/platform-browser-dynamic/testing');testing.getTestBed().initTestEnvironment( testingBrowser.BrowserDynamicTestingModule, testingBrowser.platformBrowserDynamicTesting()); 執行 npm install wallaby-webpack angular2-template-loader --save-dev. 在Visual Studio Code安裝Wallaby.ts的Extension 執行Wallaby]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 與ASP.NET Core合體]]></title>
    <url>%2F2017%2F01%2F03%2Fmvccore-with-angular2-cli%2F</url>
    <content type="text"><![CDATA[Angular可以說是一個很稱職的前端Framework，那後端的架構又有什麼選擇呢? 其實ASP.NET MVC Core是一個不錯的選擇。架構很輕，在搭配無敵強大的Visual Studio與Azure超級無縫的接軌。可以說是不二人選，但是. Angular CLI的專案要怎麼跟MVC Core的專案結合呢? 以下使用Visual Studio 2017RC+ Core 1.1.0版來做Demo. 使用 WebAPI 的專案範本建立新專案 按下 OK 後就會是一個含有WebAPI範例的MVC Core的網站了，這時候會發現project.json已經消失了，因為我門是使用Visual Studio 2017建立的關係(Project.json for ASP.NET Core is going away)，接下來就是透過NuGet來升級MVC Core的版本到1.1.0的版本。 502的錯誤排除 如果第一次執行後，出現502的錯誤，請確認環境是否有安裝.NET Core 1.1的Library，安裝後應可排除問題 下載位置 設定路由 在startup.cs裡，修改Configure的部分 可能需要多安裝 Microsoft.AspNetCore.StaticFiles套件 123456789101112131415161718public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&#123; ... app.Use(async (context, next)=&gt;&#123; await next(); if (context.Response.StatusCode == 404 &amp;&amp; !Path.HasExtension(context.Request.Path.Value) &amp;&amp; !context.Request.Path.Value.StartsWith("/api/")) &#123; context.Request.Path = "/index.html"; await next(); &#125; &#125;); app.UseMvc(); app.UseStaticFiles();&#125; 建立一個空的專案，當Angular CLI的家 然後將一些用不到的檔案，例如: program.cs給刪除掉，也可進入到nuget看看有沒有安裝什麼Library 一切清乾淨後，就要來建立Angular CLI專案了 建立Angular專案 開啟命令視窗，執行ng init --name &lt;projectName&gt; 完成後，有幾個設定檔的地方要做調整 angular-cli.json的 outDir要修改到 mvc core project的wwwroot資料夾的位置 1&quot;outDir&quot;: &quot;../WebApplication1/wwwroot&quot; ​ 新增 proxy.conf.json檔案，定義後端Api server的位置，簡化Angular呼叫API的網址的複雜度 ​ ​ 123456&#123; "/api": &#123; "target": "http://localhost:22846", "secure": false &#125;&#125; 3 修改 package.json的Scripts的部分 1&quot;start&quot;: &quot;ng serve --proxy-config proxy.conf.json&quot;, 開發時期的執行方式 執行的方式. 前端如果要開始開發的話，下指令 npm start，開發時期網頁的網址要以Angular CLI的網址為主 而後端就靠Visual Studio來幫忙囉 部屬 透過 Angualr CLI的build指令，就可以將Angualr的專案，根據angular-cli.json的輸出路徑的設定，將所有的ts程式碼轉譯後bundle在一起，輸出到wwwroot的路徑下，由於一開始在Startup.cs裡面就有設定，如果路徑不是api開頭的，就全部轉址到index.html去，也是Angular App的開始頁面. ng build後，單獨執行MVC Core的網站，最後的呈現結果 參考資料 Angular2 CLI with ASP.NET Core application - tutorial]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>MVC Core</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Router Resolve]]></title>
    <url>%2F2016%2F12%2F11%2Fng2-router-resolve%2F</url>
    <content type="text"><![CDATA[Angular 2的Router Config的地方，可以設定data跟resolve. 這篇就簡單的紀錄一下怎麼寫resolve的部分跟怎麼在component裡取得資料 基本用法 Routes設定的部分 123456789&#123; path: 'posts', component: PostsComponent, data : &#123; someProp: propValue&#125;, resolve: &#123; posts: PostsResolver &#125; ...&#125; 這裡的可以直接設定data或是resolve的屬性，這兩個屬性都可以透過ActivatedRoute的data取得. PostsResolver是實作Resolve 123456789101112131415import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';import &#123; Resolve &#125; from '@angular/router';import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs';@Injectable()export class PostsResolver implements Resolve&lt;any&gt;&#123; constructor(private http: Http) &#123; &#125; resolve(): Observable&lt;any&gt; &#123; return this.http.get('https://jsonplaceholder.typicode.com/posts').map(res=&gt;res.json()); &#125;&#125; 當然在routing-module下必須把這個註冊在provider裡面 12345678@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], providers: [ PostsResolver ]&#125;)export class AppRoutingModule &#123; &#125; 以上就是基本的router resolve的做法 那Component裡面怎麼用呢 123456789101112131415...export class PostsComponent implements OnInit &#123; posts: any[] = []; constructor(private route: ActivatedRoute) &#123; &#125; ngOnInit() &#123; this.route.data.subscribe((data: any) =&gt; &#123; this.posts = data.posts; &#125;) // or this way this.posts = this.route.snapshot.data['posts']; &#125;&#125; 進階用法 resolve也可以把參數的部分帶入使用 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';import &#123; Resolve, ActivatedRouteSnapshot &#125; from '@angular/router';import &#123; Observable &#125; from 'rxjs/Observable';@Injectable()export class PostResolver implements Resolve&lt;any&gt;&#123; constructor(private http: Http) &#123; &#125; resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; &#123; let id = route.params['id']; return this.http.get(`https://jsonplaceholder.typicode.com/posts/$&#123;id&#125;`) .map(res =&gt; res.json()); &#125;&#125; 參考資料 ROUTING &amp; NAVIGATION 範例程式碼]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ViewChild & ContentChild]]></title>
    <url>%2F2016%2F11%2F19%2Fng2-viewchild-viewcontent%2F</url>
    <content type="text"><![CDATA[ViewChild(ren) &amp; ContenChild(ren) 可以讓Component取得template裡的其他Component，取得後就可以操作該component了，而這功能搭配使用，所產生出來的效果是非常強大的. 在之前的文章有提到View和Content的差異性，Angular2的ViewChild(ren)和ContentChild(ren)也是根據該原則搜尋取得Component(s) [View|Content]Child : 回傳單一物件 [View|Content]Children: 回傳QueryList&lt;型別&gt;, 是一個陣列 ViewChild &amp; ViewChildren 宣告 12345678910111213141516export interface ViewChildDecorator &#123; (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): any; new (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): ViewChild;&#125;export const ViewChild: ViewChildDecorator = makePropDecorator( 'ViewChild', [ ['selector', undefined], &#123; first: true, isViewQuery: true, descendants: true, read: undefined, &#125; ], Query); 12345678910111213141516export interface ViewChildrenDecorator &#123; (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): any; new (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): ViewChildren;&#125;export const ViewChildren: ViewChildrenDecorator = makePropDecorator( 'ViewChildren', [ ['selector', undefined], &#123; first: false, isViewQuery: true, descendants: true, read: undefined, &#125; ], Query); 使用方式 1@ViewChild(@selector) variable: typeOf Variable(can be any) 搜尋的@selector可以傳入的型別有 Type&lt;any&gt;|Function|string，可以直接搜尋ReferenceId或是Component Class. selector by string: 搜尋ReferenceId(eg. #id), 如果找到相對應的Element有對應的component, 會回傳該Component, 如果沒有找到對應的Component，則回傳 ElementRef型別，如果ReferenceId找不到時，就回傳Undefined selector by ComponentClass: 搜尋By Component Class, 如果有符合時，回傳Component Type, 否則回傳Undefined LifeHook ViewChild(ren) 會在 AfterViewInit 之後，才能取得到資料, 範例 Sample 1 (利用ReferenceId) 1234567891011121314151617181920212223242526272829303132333435363738@Component(&#123; selector: 'app-input', template: ` &lt;input type="text" /&gt; `&#125;)export class InputComponent &#123; name: string = 'this is inputComponent';&#125;@Component(&#123; selector: 'app-root', template: ` &lt;label&gt;by referebce id #input&lt;/label&gt; &lt;input type="text" #input1 /&gt; &lt;br/&gt; &lt;label&gt;by component&lt;/label&gt; &lt;app-input #input2&gt;&lt;/app-input&gt; &lt;br /&gt; &lt;button type="button" (click)="getValue()"&gt;getValue&lt;/button&gt; `, styles: []&#125;)export class AppComponent implements AfterViewInit &#123; @ViewChild('input1') input1: ElementRef; @ViewChild('input2') input2: InputComponent; constructor() &#123; &#125; ngAfterViewInit() &#123; console.log('#input afterViewInit:', this.input1); console.log('app-input afterViewInit:', this.input2); &#125; getValue() &#123; console.log(this.input1.nativeElement.value); &#125;&#125; Console log的結果 Sample2 (by ComponentClass) 1@ViewChild(InputComponent) input2: InputComponent; 結果如上 Sample3 (ViewChildren) 1234567891011121314151617@Component(&#123; selector: 'app-root', template: ` ... &lt;app-input #input2&gt;&lt;/app-input&gt; &lt;app-input&gt;&lt;/app-input&gt; &lt;app-input&gt;&lt;/app-input&gt; &lt;app-input&gt;&lt;/app-input&gt; ... `, styles: []&#125;)export class AppComponent implements AfterViewInit &#123; ... @ViewChildren(InputComponent) appInputs: QueryList&lt;InputComponent&gt;; ... &#125; 輸出結果 ContentChild &amp; ContentChildren 宣告 1234567export interface ContentChildDecorator &#123; /** * @docsNotRequired */ (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): any; new (selector: Type&lt;any&gt;|Function|string, &#123;read&#125;?: &#123;read?: any&#125;): ContentChild;&#125; 使用方式 1@ContentChild(@selector) variable: typeOf Variable(can be any) 搜尋的@selector可以傳入的型別有 Type&lt;any&gt;|Function|string，可以直接搜尋ReferenceId或是Component Class. selector by string: 搜尋ReferenceId(eg. #id), 如果找到相對應的Element有對應的component, 會回傳該Component, 如果沒有找到對應的Component，則回傳 ElementRef型別，如果ReferenceId找不到時，就回傳Undefined selector by ComponentClass: 搜尋By Component Class, 如果有符合時，回傳Component Type, 否則回傳Undefined 這裡所指的ReferenceId是指ParentControl在使用子Component時，於Content Area所指定的ReferenceId. 基於此理由，搜尋by ComponentClass會比較準確，也比較直覺 LifeHook ContentChild(ren) 會在 AfterContentInit 之後，才能取得到資料, 範例 sample (search By Component Class) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component(&#123; selector: 'app-input', template: ` &lt;input type="text" /&gt; &lt;ng-content select="app-label"&gt;&lt;/ng-content&gt; `&#125;)export class InputComponent implements AfterContentInit &#123; @ContentChild(LabelComponent) content: any; name: string = 'this is inputComponent'; constructor() &#123; &#125; ngAfterContentInit() &#123; console.log('ChildComponent AfterContentInit: ', this.content); &#125;&#125; @Component(&#123; selector: 'app-label', template: ` &lt;p&gt; label works! &lt;/p&gt; `&#125;)export class LabelComponent implements OnInit &#123; name: string = 'This is a label component'; constructor() &#123; &#125; ngOnInit() &#123; &#125; someFunction() &#123; &#125;&#125;// Parent Component template: ` ... &lt;app-input&gt; &lt;app-label&gt;&lt;/app-label&gt; &lt;/app-input&gt; ... 輸出結果 Sample 2(search by ReferenceId) 這裡所指的ReferenceId是指在parentComponent內所定義的Id 12345678910111213141516171819202122232425@Component(&#123; selector: 'app-input', template: ` &lt;input type="text" /&gt; &lt;ng-content select="app-label"&gt;&lt;/ng-content&gt; `&#125;)export class InputComponent implements AfterContentInit &#123; @ContentChild('label') content: any; name: string = 'this is inputComponent'; constructor() &#123; &#125; ngAfterContentInit() &#123; console.log('ChildComponent AfterContentInit: ', this.content); &#125;&#125; // ParentComponent &lt;app-input #input2&gt; &lt;app-label #label&gt;&lt;/app-label&gt; &lt;/app-input&gt; &lt;app-input&gt; &lt;app-label #label&gt;&lt;/app-label&gt; &lt;/app-input&gt; 輸出結果同上，這裡有另外一個需要注意的地方，#[id] 如果是在View階層時，是不能有重複的，但是如果是Content階層時，在不同的View Component是可以重複的，因為是生存不在不同的scope. 應用 一個Tbas套件的組成可以是一個tabs下面有多個tab, 大概會是長這樣 1234567891011&lt;tabs&gt; &lt;tab&gt; &lt;p&gt;This Tab Content 1&lt;/p&gt; &lt;/tab&gt; &lt;tab&gt; &lt;p&gt;This Tab Content 1&lt;/p&gt; &lt;/tab&gt; &lt;tab&gt; &lt;p&gt;This Tab Content 1&lt;/p&gt; &lt;/tab&gt;&lt;/tabs&gt; 所以我們至少需要兩個Components, tabs和tab 12345678910111213141516import &#123;Component,Input&#125; from 'angular2/core';@Component(&#123; selector: 'tab', template: ` &lt;p [hidden]="!show"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/p&gt; `&#125;)export class TabComponent &#123; @Input() tabTitle:string; show:boolean = false;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123;Component,ContentChildren,QueryList,AfterContentInit&#125; from 'angular2/core';import &#123;TabComponent&#125; from './tab';@Component(&#123; selector: 'tabs', template: ` &lt;ul class="tab-list"&gt; &lt;li *ngFor="#tab of tabs" [class.active]="selectedTab===tab" (click)="onSelect(tab)"&gt; &#123;&#123;tab.tabTitle&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ng-content&gt;&lt;/ng-content&gt; `, styles: [` .tab-list&#123; list-style:none; overflow:hidden; padding:0; &#125; .tab-list li&#123; cursor:pointer; float:left; width:60px; height:30px; line-height:30px; text-align:center; background-color:gray; &#125; .tab-list li.active&#123; background-color:red; &#125; `]&#125;)export class TabsComponent implements AfterContentInit &#123; @ContentChildren(TabComponent) tabs:QueryList&lt;TabComponent&gt;; selectedTab:TabComponent; ngAfterContentInit() &#123; this.select(this.tabs.first); &#125; onSelect(tab) &#123; this.select(tab); &#125; select(tab) &#123; this.tabs.forEach((item)=&gt;&#123; item.show = false; &#125;); this.selectedTab = tab; this.selectedTab.show = true; &#125;&#125; 1234567891011121314151617181920@Component(&#123; selector: 'my-app', template: ` &lt;h2&gt;App Component&lt;/h2&gt; &lt;tabs&gt; &lt;tab tabTitle="First"&gt; &lt;p&gt;This Tab Content 1&lt;/p&gt; &lt;/tab&gt; &lt;tab tabTitle="Second"&gt; &lt;p&gt;This Tab Content 2&lt;/p&gt; &lt;/tab&gt; &lt;tab tabTitle="third"&gt; &lt;p&gt;This Tab Content 3&lt;/p&gt; &lt;/tab&gt; &lt;/tabs&gt; `, directives: [TabsComponent,TabComponent]&#125;)export class AppComponent &#123;&#125; 顯示效果 延伸閱讀 metadata ViewChild/ContentChild]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] 3rd Library的安裝筆記]]></title>
    <url>%2F2016%2F11%2F17%2Fng2-3rdLibrary%2F</url>
    <content type="text"><![CDATA[Angular CLI要安裝第三方套件，看起來簡單，可是好像又有什麼地方需要設定，特此寫這篇方便以後查考 注意事項 如果是修正到angular-cli.json檔案時，需要重啟ng serve才會生效 套件 Lodash 12npm install lodash --savenpm install @types/lodash --save-dev 在需要使用到lodash的component裡，還需要做import的動作 1import * as _ from 'lodash'; Font Awesome 1npm install font-awesome --save 在Angular-cli.json下，將font-awesome的css及 font file都加進來 1234567"apps":[&#123; ... "styles": [ "../node_modules/font-awesome/css/font-awesome.css" ], ... &#125;] 123"addons": [ "../node_modules/font-awesome/fonts/*.+(otf|eot|svg|ttf|woff|woff2)" ] hammer.js angular materia 2 如果要使用 md-slide-toggle and md-slider, 需要額外再多安裝hammer.js 1npm install hammerjs --save 1234567"apps":[&#123; ... "scripts": [ "../node_modules/hammerjs/hammer.min.js" ] ... &#125;] AngularFire2 1npm install firebase angularfire2 --save]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Projection]]></title>
    <url>%2F2016%2F11%2F13%2Fng2-transclusion%2F</url>
    <content type="text"><![CDATA[Angular1有Transclusion, 那Angular2該怎麼做呢? View &amp; Content 在介紹Angular2的Projection之前，有兩個名詞要介紹，就是 View 和 Content 1234&lt;app-card&gt; &lt;!-- View --&gt; &lt;card-header&gt;&lt;/card-header&gt; &lt;!-- one of the Contents --&gt; &lt;div class="card-footer"&gt;&lt;/div&gt; &lt;!-- one of the Contents --&gt;&lt;/app-card&gt; 所以 View和 Content 的關係是 Content 是存在於 View 裡面，而 View 就是最外層的 element ngContent 而Angular2的Transclusion就是利用Contents來完成，先來看一段程式碼 123456789@Component(&#123; selector: 'app-card', template: ` &lt;ng-content select="card-header"&gt;&lt;/ng-content&gt; &lt;h2&gt;Card Info &lt;/h2&gt; &lt;ng-content select=".card-footer"&gt;&lt;/ng-content&gt; `&#125;)export class HeroParentComponent&#123;&#125; 介紹 &lt;ng-content select=&quot;&lt;selector&gt;&quot;&gt;&lt;/ng-content&gt;，Angular2透過偉大的selector，就可以將資料或是要顯示的內容放到對的位置 app-card這個component的template, 我們定義了兩個ng-content，分別是針對&lt;card-header&gt; tag element, 另外一個是針對claass含有card-footer的element. 而在外部使這app-card 就可以在content area來提供這部分的資料，使用範例 12345678&lt;app-card&gt; &lt;card-header&gt; &lt;h1&gt;This is Card Header&lt;/h1&gt; &lt;/card-header&gt; &lt;div class="card-footer"&gt; This is a card footer &lt;/div&gt;&lt;/app-card&gt; NO_ERRORS_SCHEMA 這時候到頁面上觀看結果時，在Console的地方會出現錯誤訊息 這裡的錯誤訊息是指，template parser不認識 &lt;card-header&gt; 這個標籤，所以丟出錯誤訊息。這裡需要再 ngModule的地方再多設定一個參數 123import &#123; NO_ERRORS_SCHEMA &#125; from '@angular/core';...schemas: [ NO_ERRORS_SCHEMA ] NO_ERRORS_SCHEMA 表示 Defines a schema that will allow any property on any element. 最終結果 延伸閱讀 Angular 2 Transclusion using ng-content ng_module metadata]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Template Tag]]></title>
    <url>%2F2016%2F11%2F12%2Fng2-template%2F</url>
    <content type="text"><![CDATA[Angular2裡面有提供一個 * 的語法糖, 這個語法糖是用來表示 &lt;template&gt; 標籤. 例如 *ngIf 、 *ngFor 等, 而這篇就來討論怎麼利用 &lt;template&gt; Template Tag 來先看一段Code吧 1234567891011121314151617181920212223242526272829303132import &#123; Component, ComponentFactoryResolver, ViewChild, ViewContainerRef &#125; from '@angular/core';@Component(&#123; selector: 'my-dynamic-component', template: `&lt;div&gt;Hello world&lt;/div&gt;`&#125;)export class MyDynamicComponent&#123; &#125;@Component(&#123; selector: 'app-root', template: ` &lt;div&gt; &lt;template #target&gt;&lt;/template&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;` &#125;)export class AppComponent &#123; @ViewChild('target', &#123;read: ViewContainerRef&#125;) target: ViewContainerRef; title = 'app works!'; constructor(private cfr: ComponentFactoryResolver)&#123; &#125; ngAfterViewInit()&#123; let myFactory = this.cfr.resolveComponentFactory(MyDynamicComponent); let compRef = this.target.createComponent(myFactory); &#125;&#125; 這段Code有幾個地方要解釋一下的是 &lt;template&gt;是一個placeholder, 像是註記符號，讓angular2知道說要將template注入到哪一個位置 ViewContainerRef 是代表容器的位置 ComponentFactoryResolver是動態產生Component的一個Factory Class 動態產生Component不會在此探討，會留在以後來做討論. 重點是 &lt;template&gt; 這個所產生出來的結果 紅色框起來的就是在上面 &lt;template&gt; 的所在位置，而所要產生的html會在下方被注入。同樣的運作原理適用於 Rotuer 以上就是介紹 『』 的基本用途，接下來就是進階的用法了 template tag dances with data 單純的顯示HTML多無聊啊，來個動態顯示資料吧 1234567891011121314151617181920import &#123; Component, ComponentFactoryResolver, ViewChild, ViewContainerRef &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;template #nametag let-y&gt; &lt;div&gt;Hello &#123;&#123; y.name &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;div [ngTemplateOutlet]="nametag" [ngOutletContext]="myContext"&gt;&lt;/div&gt; &lt;div [ngTemplateOutlet]="nametag" [ngOutletContext]="myContext2"&gt;&lt;/div&gt;`&#125;)export class AppComponent &#123; name = 'kevin'; myContext = &#123; '$implicit': &#123;name: 'kevin'&#125;&#125;; myContext2 = &#123; '$implicit': &#123;name: 'Jeff'&#125;&#125;;&#125; 名詞解釋 [ngTemplateOutlet] : Inserts an embedded view from a prepared TemplateRef [ngOutletContext]: should be an object, the object’s keys will be the local template variables available within the TemplateRef. Note: using the key $implicit in the context object will set it’s value as default. let-(alias): let- 是將ngOutletContext所傳進去的object中的$implicit給予一個別名，使 &lt;template&gt; 內可以使用該資料. 所以上面的程式就可以將不同的資料放到相同的 &lt;template&gt; 裡但又不用新增一個component來處理，工作就減少很多了，是不是很方便，而這個也是 *ngFor 等的基本寫法 自訂Directive 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Component, Directive, Input, TemplateRef, ViewContainerRef, EmbeddedViewRef, ChangeDetectorRef, ChangeDetectionStrategy&#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs/Rx';@Directive(&#123; selector: '[rxContext][rxContextOn]'&#125;)export class RxContext &#123; @Input() rxContextOn: Observable&lt;any&gt;; _viewRef: EmbeddedViewRef&lt;any&gt;; constructor(private templateRef: TemplateRef&lt;any&gt;, private vcr: ViewContainerRef) &#123; &#125; ngOnInit() &#123; // console.log(this.rxContextOn); this.rxContextOn.subscribe(state =&gt; &#123; console.log(state); if (!this._viewRef) &#123; this._viewRef = this.vcr.createEmbeddedView(this.templateRef, &#123; '$implicit': state &#125;); &#125; this._viewRef.context.$implicit = state; &#125;); &#125;&#125;@Component(&#123; selector: 'app-root', template: ` &lt;div *rxContext="let user on userStream"&gt; &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt;`&#125;)export class AppComponent &#123; userStream = Observable.of(&#123; name: 'kevin', age: 35 &#125;).concat(Observable.timer(3000).mapTo(&#123; name: 'Jeff', age: 30 &#125;));&#125; 一段一段的來解釋吧 123&lt;div *rxContext="let user on userStream"&gt; &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt;&lt;/div&gt; 我們知道 * 會被更換成 &lt;template&gt; ，所以上面的那段code會替換成 12345&lt;template rxContext let-user [rxContextOn]="userStream"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;template&gt; 所以我們需要一個叫 rxContext的directive，和 rxContextOn的屬性 1234567891011@Directive(&#123; selector: '[rxContext][rxContextOn]'&#125;)export class RxContext &#123; @Input() rxContextOn: Observable&lt;any&gt;; _viewRef: EmbeddedViewRef&lt;any&gt;; constructor(private templateRef: TemplateRef&lt;any&gt;, private vcr: ViewContainerRef) &#123; &#125;&#125; 這裡的rxContextOn型別設定為Observable是因為我們會傳入一個Observable的物件進去，這裡請依實際狀況調整 名詞解釋 TemplateRef : Represents an Embedded Template that can be used to instantiate Embedded Views. ViewContainerRef: Represents a container where one or more Views can be attached. createEmbeddedView(templateRef: TemplateRef, context?: C, index?: number) : EmbeddedViewRef 因為Directive本身是不會有任何的template的，所以這裡所要操作的template會是指使用到該directive的 html element. 12345678ngOnInit() &#123; this.rxContextOn.subscribe(state =&gt; &#123; if (!this._viewRef) &#123; this._viewRef = this.vcr.createEmbeddedView(this.templateRef, &#123; '$implicit': state &#125;); &#125; this._viewRef.context.$implicit = state; &#125;); &#125; 因為rxContextOn所傳入的資料是Observable型別的資料，所以必須透過subscribe才能將資料產生出來。當資料產生出來後，再把資料塞回到template中，這樣子就完成最基本的directive了 延伸閱讀 ngFor ngIf]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]Component Interaction]]></title>
    <url>%2F2016%2F11%2F11%2Fng2-component-interaction%2F</url>
    <content type="text"><![CDATA[Component在Angular2的世界裡是很多變也很重要的。在一個網站裡會存在很多Component，如何讓Component與Component之間做交流，當然也是一個很重要的課題 從父元件傳資料至子元件 Component可以對外定義可以接收資料的欄位. 利用@Input decorations 1234567891011@Component(&#123; selector: 'hero-child', template: ` &lt;h3&gt;&#123;&#123;hero.name&#125;&#125; says:&lt;/h3&gt; &lt;p&gt;I, &#123;&#123;hero.name&#125;&#125;, am at your service, &#123;&#123;masterName&#125;&#125;.&lt;/p&gt; `&#125;)export class HeroChildComponent &#123; @Input() hero: Hero; @Input('master') masterName: string;&#125; 從父元件使用這個子元件的方式 1&lt;hero-child [hero]="hero" [master]="master"&gt;&lt;/hero-child&gt; 細節說明 @Input @Input的Interface, @Input可以在小括號內指定對外的property name. 123456export interface Input &#123; /** * Name used when instantiating a component in the template. */ bindingPropertyName?: string;&#125; 而接續在@input() 後面的是在該Component內所使用的變數，也可以指定型別給他。當然也可以分成兩行寫 12@Input()private hero: Hero; 或是自訂Setter/Getter 123456private _name: string = '&lt;no name set&gt;';@Input()set name(name: string) &#123; this._name = (name &amp;&amp; name.trim()) || '&lt;no name set&gt;';&#125;get name() &#123; return this._name; &#125; @Output 如果想要從元件內的值往外傳的時候，可以使用 @Output decoration, 但是@Ouput只限定於Event 12345678 export class VoterComponent &#123; @Input() name: string; @Output() onVoted = new EventEmitter&lt;boolean&gt;(); vote(agreed: boolean) &#123; this.onVoted.emit(agreed); &#125;&#125; 父元件使用這個子元件的方式 1&lt;my-voter (onVoted)="onVoted($event)"&gt;&lt;/my-voter&gt; 1234567export class VoteTakerComponent &#123; agreed = 0; disagreed = 0; onVoted(agreed: boolean) &#123; agreed ? this.agreed++ : this.disagreed++; &#125;&#125; EventEmitter的emit([value])會將值讓註冊在該屬性欄位的方法知道。 ngOnChanges 當Input的值被改變時，會觸發ngOnChanges事件。更多關於 ngOnChanges ，請參閱 LifeCycle Hooks 12345678910ngOnChanges(changes: &#123;[propKey: string]: SimpleChange&#125;) &#123; let log: string[] = []; for (let propName in changes) &#123; let changedProp = changes[propName]; let from = JSON.stringify(changedProp.previousValue); let to = JSON.stringify(changedProp.currentValue); log.push( `$&#123;propName&#125; changed from $&#123;from&#125; to $&#123;to&#125;`); &#125; this.changeLog.push(log.join(', ')); &#125; read more 父元件操作子元件的屬性及方法 父元件可以透過給予子元件一個RefId後，直接使用子元件內的方法與屬性 1234567891011121314import &#123; Component &#125; from '@angular/core';import &#123; CountdownTimerComponent &#125; from './countdown-timer.component';@Component(&#123; selector: 'countdown-parent-lv', template: ` &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt; &lt;button (click)="timer.start()"&gt;Start&lt;/button&gt; &lt;button (click)="timer.stop()"&gt;Stop&lt;/button&gt; &lt;div class="seconds"&gt;&#123;&#123;timer.seconds&#125;&#125;&lt;/div&gt; &lt;countdown-timer #timer&gt;&lt;/countdown-timer&gt; ` &#125;)export class CountdownLocalVarParentComponent &#123;&#125; 或父元件可以透過@ViewChild來操作子元件的方法與屬性 1234567891011121314151617181920212223242526272829import &#123; Component &#125; from '@angular/core';import &#123; CountdownTimerComponent &#125; from './countdown-timer.component';@Component(&#123; selector: 'countdown-parent-lv', template: ` &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt; &lt;button (click)="start()"&gt;Start&lt;/button&gt; &lt;button (click)="stop()"&gt;Stop&lt;/button&gt; &lt;div class="seconds"&gt;&#123;&#123;timer.seconds&#125;&#125;&lt;/div&gt; &lt;countdown-timer #timer&gt;&lt;/countdown-timer&gt; `&#125;)export class CountdownLocalVarParentComponent &#123; // this @ViewChild('timer') private timer: CountdownTimerComponent; // or this @ViewChild(CountdownTimerComponent) private timer: CountdownTimerComponent; start()&#123; this.timer.start(); &#125; stop()&#123; this.timer.stop(); &#125;&#125; 透過Service的方式讓父與子元件互相溝通 這個需要使用到RxJS的Object來達成這個功能。 123456789101112131415161718import &#123; Injectable &#125; from '@angular/core';import &#123; Subject &#125; from 'rxjs/Subject';@Injectable()export class MissionService &#123; // Observable string sources private missionAnnouncedSource = new Subject&lt;string&gt;(); private missionConfirmedSource = new Subject&lt;string&gt;(); // Observable string streams missionAnnounced$ = this.missionAnnouncedSource.asObservable(); missionConfirmed$ = this.missionConfirmedSource.asObservable(); // Service message commands announceMission(mission: string) &#123; this.missionAnnouncedSource.next(mission); &#125; confirmMission(astronaut: string) &#123; this.missionConfirmedSource.next(astronaut); &#125;&#125; 利用subscribe和執行service的方法來達成訊息交換的功能 結語 Component與Component之間的溝通方式基本上並不困難，但是很多情形是有太多Component與資料間的相依關係讓事情變得很複雜，所以如何最好Component的規劃是一個需要經驗的課題，只好不斷的從實做中整理出規則。 Reference Angular2 Cookbook - Component Interaction RxJS - Subject]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] Subject]]></title>
    <url>%2F2016%2F10%2F06%2Frx-subject%2F</url>
    <content type="text"><![CDATA[A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners. 這表示Subject是 Observable，也是Observer。而這篇文章重點會放在每種類型的Subject的特性 RxJS 的 Subject類型除了基本型Subject, 還有以下幾種類型的Subject BehaviorSubject, ReplaySubject, and AsyncSubject Subject 程式碼 12345678910111213141516171819202122232425262728var source = Rx.Observable.interval(1000).take(5) .do(function(value)&#123; console.log('source' + value);&#125;)var subject = new Rx.Subject(); // 0 is the initial valuevar ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;source.subscribe(subject);subject.subscribe(ObserverA); console.log('ObserverA subscribed');setTimeout(function()&#123; subject.subscribe(ObserverB); console.log('ObserverB subscribed');&#125;,2000) 執行結果 BehaviorSubject BehaviorSubjects are useful for representing 「values over time」. For instance, an event stream of birthdays is a Subject, but the stream of a person’s age would be a BehaviorSubject. BehaviorSubject會記錄最後一次的值，當後來註冊進來的subscriber可以知道當下的值是什麼 所以BehaviorSubject在建立時，需要指定一個初始值 程式碼如下 1234567891011121314151617181920212223242526var source = Rx.Observable.interval(1000).take(5) .do(function(value)&#123; console.log('source ' + value);&#125;)var subject = new Rx.BehaviorSubject(0); // 0 is the initial valuevar ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;source.subscribe(subject);subject.subscribe(ObserverA); console.log('ObserverA subscribed');setTimeout(function()&#123; subject.subscribe(ObserverB); console.log('ObserverB subscribed');&#125;,2000) 執行結果 ReplaySubject A ReplaySubject records multiple values from the Observable execution and replays them to new subscribers. ReplaySubject有點類似於BehaviorSubject，可以取得subscribe之前的值，只是可以取不只一個。類似回播的功能 ReplaySubject在建立時有幾個參數可以設定， 1var subject = new Rx.ReplaySubject(bufferSize, windowTime); bufferSize: ReplaySubject可以儲存 x 數量的值 windowTime: ReplaySubject取最後 x milliseconds 期間的值 程式碼 (with no windowTime參數) 1234567891011121314151617181920212223242526var source = Rx.Observable.interval(500).take(7) .do(function(value)&#123; console.log('source ' + value);&#125;)var subject = new Rx.ReplaySubject(3); // 0 is the initial valuevar ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;source.subscribe(subject);subject.subscribe(ObserverA); console.log('ObserverA subscribed');setTimeout(function()&#123; subject.subscribe(ObserverB); console.log('ObserverB subscribed');&#125;,2000) 執行結果 程式碼 (with windowTime參數) 123456789101112131415161718192021222324252627282930var source = Rx.Observable.interval(500).take(7) .do(function(value)&#123; console.log('source ' + value);&#125;)// source: 0--1--2--3--4--5--6-----// A: 0--1--2--3--4--5--6-----// |---|: windowTime // B: 23--4--5--6-----var subject = new Rx.ReplaySubject(3, 700); // 0 is the initial valuevar ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;source.subscribe(subject);subject.subscribe(ObserverA); console.log('ObserverA subscribed');setTimeout(function()&#123; subject.subscribe(ObserverB); console.log('ObserverB subscribed');&#125;,2000) 執行結果 AsyncSubject AsyncSubject只會記錄 Observable 完成後的值。 程式碼 1234567891011121314151617181920212223242526var source = Rx.Observable.interval(500).take(7) .do(function(value)&#123; console.log(&apos;source &apos; + value);&#125;)var subject = new Rx.AsyncSubject(); // 0 is the initial valuevar ObserverA = &#123; next: function(value)&#123; console.log(&apos;A next &apos;+ value); &#125;, error: function(error)&#123; console.error(&apos;A error &apos;+ error); &#125;, complete: function()&#123; console.log(&apos;A Complete&apos;);&#125;&#125;var ObserverB = &#123; next: function(value)&#123; console.log(&apos;B next &apos;+ value); &#125;, error: function(error)&#123; console.error(&apos;B error &apos;+ error); &#125;, complete: function()&#123; console.log(&apos;B Complete&apos;);&#125;&#125;source.subscribe(subject);subject.subscribe(ObserverA); console.log(&apos;ObserverA subscribed&apos;);setTimeout(function()&#123; subject.subscribe(ObserverB); console.log(&apos;ObserverB subscribed&apos;);&#125;,2000) 執行結果 BehaviorSubject、ReplaySubject、AsyncSubject 與 Publish 的關係 在前一篇提到說 publish 是 multicast的變化型，而multicast裡可以建立各式的Subject，那publish相對應的又是什麼，對照表如下 Subject Type Multicasting Operator Rx.Subject publish() Rx.BehaviorSubject publishBehavior(initValue) Rx.ReplaySubject publishReplay(bufferSize, windowTime) Rx.AsyncSubject publishLast() 參考網址 BehaviorSubject ReplaySubject AsyncSubject]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[RxJS] MultiCasting]]></title>
    <url>%2F2016%2F10%2F06%2Frxjs-multicast%2F</url>
    <content type="text"><![CDATA[我們都知道RxJS的Observeable會在subscribe的時候才會執行，所以每一次的subscribe都會執行一次，但是，某些情況下我們並不想要那樣子做，而在RxJS裡面有一個MultiCasting的觀念，主要是用來處理一個Observeable多個Observer的情況時，而不重複執行Observable. 這篇會整理一下關於MultiCasting的相關觀念 假設情境 12345678910111213141516171819var source = Rx.Observable.interval(1000).take(5)var ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;source.subscribe(ObserverA);var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;setTimeout(function()&#123; source.subscribe(ObserverB);&#125;,2000); 這樣子跑出來的結果如下 Subject Observer A和Observer B都有各自己的結果, 如果，我們想要Observer A和Observer B共用同一個資料流的話，該怎麼處理? 這時候就要借用RxJS裡面的 Subject 這個類型的幫助了 官網是這樣子定義Subject的 A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners. 用法如下 12345678910111213141516171819202122var source = Rx.Observable.interval(1000).take(5)var subject = Rx.Subject.create();var ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;subject.subscribe(ObserverA);source.subscribe(subject);var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;setTimeout(function()&#123; subject.subscribe(ObserverB);&#125;,2000); 這樣Observer A與Observer B就共用同一個資料流的資料了, 但是每次都這樣子寫有點麻煩. multicast 可以使用multicast的方式將Object.create的方式包起來, 程式碼如下 123456789101112131415161718192021var source = Rx.Observable.interval(1000).take(5) .multicast(Rx.Subject.create())var ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;source.connect();source.subscribe(ObserverA);var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;setTimeout(function()&#123; source.subscribe(ObserverB);&#125;,2000); 使用multicast這個operator, 必須使用 .connect() 來執行 Observable了，因為，這裡的 source.subscribe 是針對Subject做subscribe而非Observable本身. publish publish為mulitcast的變化型, 在mulitcast裡面需要給予一個Rx.Subject, 例如 12345678.multicast(new Rx.Subject())// 可以替換成.publish()// 或是.multicast(new Rx.ReplaySubject())// 可以替換成.publishReplay() refCount 可是，這樣子寫又有點麻煩，有沒有自動開始結束的寫法. 其實是有的，那就是 refCount refCount: 啟動條件: subscriber數量大於0時。停止條件: subscriber數量等於0時 recCount makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves. 程式碼如下 123456789101112131415161718192021222324252627282930313233var source = Rx.Observable.interval(1000) .do(x =&gt; console.log('souce '+ x)) .publish() .refCount()var ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var subA = source.subscribe(ObserverA);var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;var subBsetTimeout(function()&#123; subB = source.subscribe(ObserverB);&#125;,2000);setTimeout(function()&#123; subA.unsubscribe(); console.log('unsubscribe A');&#125;,5000)setTimeout(function()&#123; subB.unsubscribe(); console.log('unsubscribe B');&#125;,7000) 執行結果如下 share RxJS有提供更簡便的寫法 share ，share是publish,refCount 這兩個operator的簡寫，程式碼如下 1234567891011121314151617181920212223242526272829303132var source = Rx.Observable.interval(1000) .do(x =&gt; console.log('souce '+ x)) .share()var ObserverA = &#123; next: function(value)&#123; console.log('A next '+ value); &#125;, error: function(error)&#123; console.error('A error '+ error); &#125;, complete: function()&#123; console.log('A Complete');&#125;&#125;var subA = source.subscribe(ObserverA);var ObserverB = &#123; next: function(value)&#123; console.log('B next '+ value); &#125;, error: function(error)&#123; console.error('B error '+ error); &#125;, complete: function()&#123; console.log('B Complete');&#125;&#125;var subBsetTimeout(function()&#123; subB = source.subscribe(ObserverB);&#125;,2000);setTimeout(function()&#123; subA.unsubscribe(); console.log('unsubscribe A');&#125;,5000)setTimeout(function()&#123; subB.unsubscribe(); console.log('unsubscribe B');&#125;,7000) 執行結果是一樣的 結論 以上為最基本的multicast的幾種用法，但是這都只是基本款而已，因為RxJS裡面的Subject有好幾種，每一種類型的Subject所呈現的結果又都不一樣，這就待下一篇再來討論]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Angular CLI (beta9) 手動加入Router]]></title>
    <url>%2F2016%2F07%2F06%2Fangular2-with-router%2F</url>
    <content type="text"><![CDATA[Angular2的Route的新版持續在開發中，目前已經到了beta階段了，可是Angular2的CLI只是單純的有更新@angular/router的版本而已，但是內建的樣版卻沒有更新，所以只好手動了。 基本新增步驟 新增一個app.routers.ts檔案 1234567891011121314import &#123; provideRouter, RouterConfig &#125; from '@angular/router';import &#123; ProfileComponent &#125; from './profile';export const routes: RouterConfig = [ &#123; path: 'profile', component: ProfileComponent &#125;, &#123; path: '', redirectTo: '/profile', &#125;];export const APP_ROUTER_PROVIDERS = [ provideRouter(routes)]; 手動更新 index.ts 檔案，將app.routers加入 1export * from './app.routers'; import APP_ROUTER_PROVIDERS 到 main.ts裡 123import &#123; AppComponent, environment, APP_ROUTER_PROVIDERS &#125; from './app/';...bootstrap(AppComponent,[APP_ROUTER_PROVIDERS]); 修改 app.component.html 檔案 1234&lt;nav&gt; &lt;a [routerLink]="['/profile']"&gt;profile&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 注意事項 因為Angular CLI(Beta9)的@Angular/Router版本目前是在alpha階段，所以文件裡面有些Router的設定有可能還不存在，例如說 pathMatch: 'full' 但基本的設定方式都是沒有問題的 實際跑起來的畫面如下 進一步的看@Angular/Router 新版的Router在讀取html/css檔案時，是採lazyLoading，表示除非到那個頁面，不然不會事先下載該檔案。(前提: 是使用systemjs的方式)請看下面的影片 如何將ROUTER_DIRECTIVES註冊成全域 為了要完成這個動作，我們需要兩個東西 『provide,PLATFORM_DIRECTIVES』 provide的功能是建立一個Proivder PLATFORM_DIRECTIVES的功能是一個Directives容器，可以供應在專案下所有的Components可以使用 PLATFORM_DIRECTIVES: A token that can be provided when bootstrapping an application to make an array of directives available in every component of the application. 利用上述的兩個東西，就可以在main.ts下，將ROUTER_DIRECTIVES給註冊到全域下 123456789import &#123; provide, PLATFORM_DIRECTIVES, enableProdMode &#125; from &apos;@angular/core&apos;;...bootstrap(AppComponent, [ provide(PLATFORM_DIRECTIVES, &#123; useValue: [ROUTER_DIRECTIVES], multi: true &#125;) ]); 完成後，以後再components裡面就不用在import { ROUTER_DIRECTIVES } from '@angular/router'了 相關連結 官方文件 CLI-package.json - beta9 @Agnular/Route - Changelog API DOC- provide API DOC- PLATFORM_DIRECTIVES github repo]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] MVC Core with SqlClient on MAC]]></title>
    <url>%2F2016%2F06%2F22%2Fmvc-core-with-sqlserver%2F</url>
    <content type="text"><![CDATA[.Net Core 終於支援使用SqlClien的物件了(但不確定是從什麼時候開始的), 那就來試試看怎麼在mac的環境上連到sql server撈資料了 使用Library 「System.Data.SqlClient」: 「4.1.0-rc2-24027」 「Dapper」: 「1.50.0-rc2b」 Yes. Dapper也支援CoreClr了，可喜可賀 使用方式 同原本在.Net4.x的用法 with Dapper 12345using (SqlConnection cn = new SqlConnection(_config.Default))&#123; var data = await cn.QueryAsync&lt;Supplier&gt;("select top 10 * from Suppliers"); return View(data);&#125; 所遇到的問題 無法連線到SqlServer 問題描述 : 發生連線字串正確，卻沒有辦法連線到sql server, 但是透過navicat卻可以正常的瀏覽該資料庫的內容 主機環境: SQL Server R2 2008 Express，沒有更新到最新的SP 解決方式: 將SQL Server R2 2008 更新到SP3即可修正問題，參考資料github issue]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] ChangeDetectionStrategy]]></title>
    <url>%2F2016%2F06%2F05%2Fangular2-ChangeDetectionStrategy%2F</url>
    <content type="text"><![CDATA[Angular2裡面偵測改變的方法有全新的方式，用來提升整體的效能，那針對Component對於偵測改變有一個屬性可以設定，那就是透過 ChangeDetectionStrategy 根據官方文件, ChangeDetectionStrategy有幾種方式 CheckOnce Checked CheckAlways Detached OnPush Default 這篇只專注於Default與OnPush這兩種 Change Detection Strategy Default Example Code 1&lt;movie [title]="title" [actor]="actor"&gt;&lt;/movie&gt; 12title: string = "Movie 1";actor: Actor =new Actor( 'Bruce', 'Willis'); 針對movie這個component, 它接收兩種值，一個是string型別的title, 另外一個是Actor型別的物件。 Movie Component會在什麼時機點更新要顯示的內容呢? 如果 ChangeDetectionStrategy是設定在Default的時候，那就是只要傳入的值有異動時，就更新顯示的內容。換句話說, 即使修改actor物件裡面的property, 也會觸發。 onPush 可是換到onPush的時候就有點不一樣了，他不會將修改actor屬性視為值的異動，只會當一個全新的Actor物件被建立時，才會觸發更新。 這樣的好處是，減少detect Dirty Change的次數. 就預設的方式，如果我的Actor物件裡面有很多屬性，那當每一次其中一個屬性的值被異動時，都會觸發畫面的更新，那就太累了。而onPush是會等一個全新物件被建立時，才會出發。所以只要用要更新的值去建立一個新的物件就好了，這樣子只會被觸發一次。當然效能就會大大的提升 Immutable Immuatable是另外一個議題。他的主要精神是。每一次的動作，都會產生一個新的物件，並不會直接修改原始物件內的值，或是使用參址的方式處理資料. 更詳細的內容可以參閱RxJS和Immutable 參考文件 ChangeDetectionStrategy Change Detection Strategy: OnPush ​]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]Service&EventEmitter]]></title>
    <url>%2F2016%2F06%2F04%2Fangular2-service-EventEmitter%2F</url>
    <content type="text"><![CDATA[在Angular2裡面如何做一個全域型的變數然後當其更新時，讓所有有用到的人都知道。這時候就要用EventEmitter了 EventEmitter是什麼? 官方文件裡尚未仔細描述他的用途，但是我覺得他有點類似Angular1的 $broadcast，以下是EventEmitter所提供的method 123456class EventEmitter &#123; constructor(isAsync?: boolean) emit(value: T) next(value: any) subscribe(generatorOrNext?: any, error?: any, complete?: any) : any&#125; 如何用呢? 123456789// 註冊方open: EventEmitter&lt;any&gt; = new EventEmitter();open.emit(&lt;value&gt;); // 使用方open.subscribe((value)=&gt;&#123; ....&#125;) 當emit被呼叫時，subscribe就會接收到通知，然後就會進行subscribe第一個function的動作。 利用這個特性，可以在service裡面寫全域變數。程式碼如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; Injectable, EventEmitter &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/Rx';import &#123; AngularFire, AuthMethods, FirebaseAuthState, AuthProviders &#125; from 'angularfire2';@Injectable()export class AuthService &#123; currentUser: FirebaseAuthState; checkLogin: EventEmitter&lt;any&gt; = new EventEmitter(); constructor(private af: AngularFire) &#123; &#125; /** 判斷使用者是否已經有登入 */ get isLogin(): boolean &#123; ... &#125; /** 用Email登入 */ login(cred): Observable&lt;FirebaseAuthState&gt; &#123; let ob = Observable.fromPromise(this.af.auth.login(cred, &#123; provider: AuthProviders.Password, method: AuthMethods.Password, &#125;)); return ob.do((data) =&gt; &#123; this.setUser(data); &#125;) &#125; /** 用Facebook登入 */ fbLogin() &#123; ... &#125; /** 登出 */ logout() &#123; localStorage.removeItem('objUser'); this.currentUser = undefined; this.af.auth.logout(); this.checkLogin.emit(this.isLogin); &#125; private setUser(user) &#123; localStorage.setItem('objUser', JSON.stringify(user)); this.currentUser = user; this.checkLogin.emit(this.isLogin); &#125;&#125; 但是，Provider Inject的位置要注意(請參考Angular 2 Components and Providers: Classes, Factories &amp; Values)，根據實驗，如果Component各自DI service as provider. 當其一的service值有改變而且有廣播時，另外一個service是收不到的，看起來應該是不同的Instance造成的現象，所以必須在往上一層注入服務. 參考文件 EventEmitter Angular 2 Components and Providers: Classes, Factories &amp; Values]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] AngularFire2]]></title>
    <url>%2F2016%2F06%2F02%2Fangular2-angularfire2%2F</url>
    <content type="text"><![CDATA[Angular2也有一個給Firebase使用的Library, 必計是自家的服務，有相對的AngularFire也是正常的， 目前AngularFire2只支援Firebase SDK V2版本，V3版本還在路上。所以在firebase所建立的專案必須要由舊介面建立後再轉至新Console介面，才可以使用。 AngularFire2現在支援Firebase SDK V3版本了，設定方式如下 前置 Demo的專案都是以Angular CLI所產生出來的架構 安裝 安裝文件 修正項目 開啟 angular-cli-build.js 檔案，這修正是為了build for production時會產生的錯誤 123'angularfire2/**/*.js', 修改成'angularfire2/**/*.+(js|js.map)', 使用方式 一些程式碼 main.js 12345678910bootstrap(KeepthingsAppComponent, [ FIREBASE_PROVIDERS, defaultFirebase(&#123; apiKey: "&lt;your-key&gt;", authDomain: "&lt;your-project-authdomain&gt;", databaseURL: "&lt;your-database-URL&gt;", storageBucket: "&lt;your-storage-bucket&gt;", &#125;), ]); 這段設定碼可以透過新版的console畫面裡取得 App.Component.js 1import &#123; AngularFire, FirebaseListObservable &#125; from 'angularfire2'; 123456class AppComponent&#123; items: FirebaseListObservable&lt;any[]&gt;; constructor(af: AngularFire) &#123; this.items = af.database.list('/items'); &#125;&#125; AngularFire所取回的list是Observable的物件，所以也可以套用RxJS的Operator. 基本上Firebase的運作方式是沒有改變的 由於this.items屬Obserable，在畫面上要顯示時，可以透過 async幫忙來簡化程式碼 1&lt;div *ngFor="let item in items | async"&gt;...&lt;/div&gt; 如果不想要用async的話，那在程式碼裡面就需要加上subscribe(....)將AngularFire所取回的資料放到變數裡 123456789this.sub = af.database.list('/items');this.sub.subscribe(data=&gt;&#123; this.items = data;&#125;,err=&gt;&#123; ... &#125;,()=&gt;&#123; //when complete ....&#125;) 1&lt;div *ngFor="let item in items"&gt;...&lt;/div&gt; API Method push(value:any) Creates a new record on the list, using the Realtime Database’s push-ids. update(key,value) remove(key) Deletes the item by key. If no parameter is provided, the entire list will be deleted. 上述的三種Method都會回傳Promise, 所以後續的接法為 then((data)=&gt;{…}).catch((err)=&gt;{…}) Authentication FireBase提供多種使用者認證的方式，從基本的Email/password, 到各個大型的OAuth 在程式裡面也可以同時間存在多種登入的方式，只要配合後台的設定 1234567891011121314151617181920212223// Anonymousaf.auth.login(&#123; provider: AuthProviders.Anonymous, method: AuthMethods.Anonymous,&#125;)// Email and passwordaf.auth.login(&#123; provider: AuthProviders.Password, method: AuthMethods.Password,&#125;)// Social provider redirectaf.auth.login(&#123; provider: AuthProviders.Twitter, method: AuthMethods.Redirect,&#125;)// Social provider popupaf.auth.login(&#123; provider: AuthProviders.Github, method: AuthMethods.Popup,&#125;) 注意 在測試Facebook的Login功能時，一直將新後台所提供的Redirect Url設定到 Facebook裡，但是一直都不能正常的運作，最後才想到，新後台所提供的網址是給SDK V3所使用的，所以我必須要去找SDK V2的版本，更新成V2版本的Url就可以正常的使用了。 可以直接使用新版Consolen所提供的Redirect Url即可 結語 AngularFire2在使用上非常的直覺，彈性也很大。先不論Firebase這個強大的後端服務，就前端可以搭配RxJS的操作，就讓人覺得很快樂。 參考文件 Angularfire2 Firebase RxJS]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]What's Structural Directives]]></title>
    <url>%2F2016%2F05%2F10%2Fangular2-structural-directives%2F</url>
    <content type="text"><![CDATA[Angular2 Directives - Structural Directives : 改變DOM element的Directive。常見的structural directives有 ngIf, ngSwitch, ngFor 用法如下. 1234567&lt;div *ngIf="hero"&gt;&#123;&#123; hero &#125;&#125;&lt;/div&gt;&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123; hero &#125;&#125;&lt;/div&gt;&lt;div [ngSwitch]="status"&gt; &lt;template [ngSwitchWhen]="'in-mission'"&gt;In Mission&lt;/template&gt; &lt;template [ngSwitchWhen]="'ready'"&gt;Ready&lt;/template&gt; &lt;template ngSwitchDefault&gt;Unknown&lt;/template&gt;&lt;/div&gt; Template Tag 在Angular2外，&lt;template&gt;預設CSS是設定為display: none. 其內容是不會顯示，在Angular2內是會被移除然後被該位置會被置換成&lt;script&gt;&lt;/script&gt; 在一開始的Code裡，ngIf和ngFor的前面有一個*, 而在ngSwitchWhen卻是用 &lt;template&gt;和[ngSwitchWhen]組合要顯示的文字。而這一個 * 的使用會帶來一些神奇的效果。下面繼續來研究 星號 (*) 的效果 常見的範例 123&lt;p *ngIf="condition"&gt; condition is true and ngIf is true.&lt;/p&gt; 在ngIf前面的 * 是一個很神奇的東西，他可以讓我們少寫&lt;template&gt; tag，如果不要寫 * 的話，那程式碼就要寫成這樣 12345&lt;template [ngIf]="condition"&gt; &lt;p&gt; condition is true and ngIf is true. &lt;/p&gt;&lt;/template&gt; 123456789&lt;!-- Examples (A) and (B) are the same --&gt;&lt;!-- (A) *ngFor div --&gt;&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123; hero &#125;&#125;&lt;/div&gt;&lt;!-- (B) ngFor with template --&gt;&lt;template ngFor let-hero [ngForOf]="heroes"&gt; &lt;div&gt;&#123;&#123; hero &#125;&#125;&lt;/div&gt;&lt;/template&gt; 所以 * 的確省去很多工作，來改寫一下 以下的程式碼 12345&lt;div [ngSwitch]="status"&gt; &lt;template [ngSwitchWhen]="'in-mission'"&gt;In Mission&lt;/template&gt; &lt;template [ngSwitchWhen]="'ready'"&gt;Ready&lt;/template&gt; &lt;template ngSwitchDefault&gt;Unknown&lt;/template&gt;&lt;/div&gt; 用 * 來修改一下程式碼 12345&lt;div [ngSwitch]="status"&gt; &lt;span *ngSwitchWhen="'in-mission'"&gt;In Mission&lt;/span&gt; &lt;span *ngSwitchWhen="'ready'"&gt;Ready&lt;/span&gt; &lt;span *ngSwitchDefault&gt;Unknown&lt;/span&gt;&lt;/div&gt; 參考 Angular2 Doc: Structural Directives]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]Rxjs的Observers]]></title>
    <url>%2F2016%2F05%2F10%2Fangular2-rxjs-observers%2F</url>
    <content type="text"><![CDATA[Angular2裡面有用到RxJS的Extensions. 那這個Extendsion會帶給Angular2怎樣的幫助，來研究一下Http的程式碼吧 Angular2 Http Code source code - http.ts 12345678910import &#123;Response&#125; from './static_response';import &#123;Observable&#125; from 'rxjs/Observable';@Injectable()export class Http &#123; constructor(protected _backend: ConnectionBackend, protected _defaultOptions: RequestOptions) &#123;&#125; get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt; &#123; .... &#125;&#125; 所以在執行Http.get(…)所回傳的結果是Observable&lt;Response&gt;，因為這樣子的關係，我們就可以使用RxJS Observers的方法 參考網址 Subscribe Method 1myObservable.subscribe(OnNext,onError,onCompleted); onNext An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable. onError An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to onNext or onCompleted. The onErrormethod takes as its parameter an indication of what caused the error. onCompleted An Observable calls this method after it has called onNext for the final time, if it has not encountered any errors. 應用方式 Http.call完之後，也可以加工response的結果。方法可以串聯起來, Demo Code如下 1234567this.http.get('xxx') .map(res =&gt; res.text()) .subscribe( data =&gt; this.randomQuote = data, err =&gt; this.logError(err), () =&gt; console.log('Random Quote Complete') ); 多個Http Request時的處理方式 如果想要同時間執行多個Http Request，但是又要等所有的Request都完成後再將資料對應到變數上，那要怎麼寫，這時候就需要使用 Observable.forkJoin，程式碼如下 12345678910Observable.forkJoin( this.http.get('/app/books.json').map((res:Response) =&gt; res.json()), this.http.get('/app/movies.json').map((res:Response) =&gt; res.json()) ).subscribe( data =&gt; &#123; this.books = data[0] this.movies = data[1] &#125;, err =&gt; console.error(err) );]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular]升級到RC]]></title>
    <url>%2F2016%2F05%2F04%2Fangular2-upgrade-to-rc0%2F</url>
    <content type="text"><![CDATA[Angular發佈RC了，來升級吧 Changelog 升級Angular2 RC NPM安裝命令 1npm install --save @angular/core @angular/compiler @angular/common @angular/platform-browser @angular/platform-browser-dynamic rxjs@5.0.0-beta.6 zone.js@0.6.12 RC版本，將各Module都拆開了，這表示，可以只安裝自己需要的部分，就不用全部都包進來了 如果出現下面的畫面，更新npm後就可以修正問題了 修改import namespace 例如 angular2/core -&gt; @angular/core angular2/compiler -&gt; @angular/compiler angular2/common -&gt; @angular/common angular2/platform/browser -&gt; @angular/platform-browser (applications with precompiled templates) + @angular/platform-browser-dynamic (applications that compile templates on the fly) angular2/platform/server -&gt; @angular/platform-server angular2/testing -&gt; @angular/core/testing (it/describe/…) + @angular/compiler/testing (TestComponentBuilder) + @angular/platform-browser/testing angular2/upgrade -&gt; @angular/upgrade angular2/http -&gt; @angular/http angular2/router -&gt; @angular/router-deprecated (snapshot of the component router from beta.17 for backwards compatibility) new package: @angular/router - component router with several breaking changes 但是有些東西還是有換位置 import { bootstrap } from 『@angular/platform-browser-dynamic』; --&gt;『angular2/platform/browser』; import { APP_BASE_HREF } from 『@angular/common』; --&gt; from 『angular2/http』 更新其他有用到ng2的Library 這部分可能會有些問題，因為RC是近期的發佈的，有可能部分的Library還沒有跟著更新，所以在使用上會出現問題。 更新Build tool config if need ex: Webpack 測試升級後的結果 語法調整 *ngFor (change in 2.0.0-beta.17) 1234// 原本的ngFor用法為*ngFor="#item of items"// 修正為*ngFor="let item of items" Pipe (change in 2.0.0-beta.16) 針對Argument的處理方式改變 12345678910//原本的 transform(todos, args) &#123; // 傳進來的args為array ... &#125;// 升級後transform(todos, args) &#123; // 傳進來的args變成傳給他什麼就是什麼 ...&#125;]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Coding4Fun] Build my own Markdown editor - Part I]]></title>
    <url>%2F2016%2F05%2F03%2Fcodemirror%2F</url>
    <content type="text"><![CDATA[因為找不到自己想要的Markdown編輯器，所以自己來寫一個. 想要的功能 Live preview like Typora Auto-upload image to Flickr Be able to work with Hexo 開發環境 JavaScript CodeMirror ExpressJS node-flickrapi Visual Studio Code 撞牆期 CodeMirror 設定CodeMirror 新增一頁html, 引用CodeMirror.js和CodeMirror.css. app.js 12345678910//================ var codeConfig = &#123; autofocus: true, lineNumbers: true, styleActiveLine: true, mode: "gfm", // Markdown Edit Mode, 需要另外引用gfm和markdown.js lineWrapping: true &#125;; var editor = CodeMirror(document.getElementById("editor"), codeConfig); index.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Markdown Editor&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="lib/codemirror/lib/codemirror.css"&gt; &lt;style&gt; .CodeMirror &#123; border: 1px solid #eee; width: 80%; height: auto; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;CodeMirror Markdown Editor&lt;/h1&gt; &lt;div id="editor"&gt; &lt;/div&gt; &lt;/body&gt;&lt;script src="lib/node_modules/jquery/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="lib/codemirror/lib/codemirror.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="lib/codemirror/mode/markdown/markdown.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="lib/codemirror/addon/mode/overlay.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="lib/codemirror/addon/selection/active-line.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="lib/codemirror/mode/gfm/gfm.js"&gt;&lt;/script&gt;&lt;!--highlight Javascript Syntax--&gt;&lt;script type="text/javascript" src="lib/codemirror/mode/javascript/javascript.js"&gt;&lt;/script&gt;&lt;script src="app.js"&gt;&lt;/script&gt;&lt;/html&gt; 顯示畫面 轉換Markdown 這裡所使用到的轉換Library是showdown index.html 123&lt;div id="preview" class="preview"&gt;&lt;/div&gt; &lt;script src="lib/node_modules/showdown/dist/showdown.min.js"&gt;&lt;/script&gt; app.js 12345678var converter = new showdown.Converter(&#123; literalMidWordUnderscores: true, &#125;);// livepreview editor.on('update', function (instance) &#123; $("#preview").html(converter.makeHtml(instance.getValue())); &#125;); 這樣子就會邊打字邊顯示結果，但是到這裡，還是跟大部分的Markdown Editor一樣，是分兩個視窗分別顯示Markdown及輸出結果，但如何表現得跟Typora一樣，仍在研究中 拖拉照片 CodeMirror支援Drag&amp;Drop, 也可以設定允許的檔案類別，設定方式如下 12345678var codeConfig = &#123; autofocus: true, lineNumbers: true, styleActiveLine: true, mode: "gfm", lineWrapping: true, allowDropFileTypes: ["image/png", "image/jpeg", "image/gif"] //允許上傳的圖片類型:png,jpg,gif &#125;; 可以利用editor.on(’’,function(){})來處理動作 123456editor.on("drop", function (editor, e) &#123; var files = e.dataTransfer.files; for (var i = 0; i &lt; files.length; ++i) &#123; ... &#125; &#125;); 這裡可以取得拖拉到editor裡的檔案有哪些 還有些額外的問題，如果將照片拖拉到非editor的地方，瀏覽器會直接顯示該照片，這不是我要的現象，所以我要將非editor的地方的drag&amp;drop給關掉 12345678910111213141516171819202122232425262728293031window.onload = function () &#123; var body = document; //target any DOM element here if (body.addEventListener) //(Mozilla) &#123; body.addEventListener('dragenter', preventDrag, true); //precursor for drop event body.addEventListener('dragover', preventDrag, true); //precursor for drop event body.addEventListener('drop', preventDrag, true); &#125; else if (body.attachEvent) //(IE) &#123; body.attachEvent('ondragenter', preventDrag); body.attachEvent('ondragover', preventDrag); body.attachEvent('ondrop', preventDrag); &#125; &#125; function preventDrag(event) &#123; if (event.type == 'dragenter' || event.type == 'dragover' || //if drag over event -- allows for drop event to be captured, in case default for this is to not allow drag over target event.type == 'drop') //prevent text dragging -- IE and new Mozilla (like Firefox 3.5+) &#123; if (event.target.className.trim() != "CodeMirror-line") &#123; if (event.stopPropagation) //(Mozilla) &#123; event.preventDefault(); event.stopPropagation(); //prevent drag operation from bubbling up and causing text to be modified on old Mozilla (before Firefox 3.5, which doesn't have drop event -- this avoids having to capture old dragdrop event) &#125; return false; //(IE) &#125; &#125; &#125; &lt;&lt; 待續 &gt;&gt; 程式碼 GitHub]]></content>
      <categories>
        <category>Coding4Fun</category>
      </categories>
      <tags>
        <tag>Coding4Fun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] css style]]></title>
    <url>%2F2016%2F04%2F25%2Fangular2-css-style%2F</url>
    <content type="text"><![CDATA[Angular Component 處理styles有三種模式 1. ViewEncapsulation.None: 適用於全部頁面(No Shadow DOM) 2. ViewEncapsulation.Native: 僅套用於Shadow DOM自己本身 3. ViewEncapsulation.Emulated: 預設行為。 會自動將每個component給予一個名稱，讓各compoent裡面的style會各自獨立 先來看第1,2種，看看style會被放在哪一個位置 ViewEncapsulation.None 1234567891011@Component(&#123; selector: 'ck-book', template: require('./book.html'), styles: [` h3 &#123; color: red &#125; `], encapsulation: ViewEncapsulation.None&#125;)export class CkBookPage &#123;&#125; 2.ViewEncapsulation.Native 1234567891011@Component(&#123; selector: 'ck-book', template: require('./book.html'), styles: [` h3 &#123; color: red &#125; `], encapsulation: ViewEncapsulation.Native&#125;)export class CkBookPage &#123;&#125; 注意到ViewEncapsulation.Native將ViewEncapsulation.None的和本身定義的Style都包含在Shadow DOM裡面，這表示該Componenet與外面已經分開了. 本身所定義的css樣式不會影響到別人了 ViewEncapsulation.Emulated為預設行為，會自動將每個Component給予一個名稱，然後在產生html時會將各Componet裡 定義的style加上該名稱，讓css不會互相影響 12345678910@Component(&#123; selector: 'ck-book', template: require('./book.html'), styles: [` h3 &#123; color: red &#125; `], encapsulation: ViewEncapsulation.Emulated&#125;) 123456&lt;style&gt;h3[_ngcontent-jfs-3] &#123; color: red &#125;&lt;/style&gt; &lt;div _ngcontent-jfs-3 class="clearfix mx-auto col-8"&gt; &lt;h3 _ngcontent-jfs-3&gt;Booking&lt;/h3&gt; .... 參考 shadow-dom-strategies-in-angular2 Controlling how Styles are Shared with View Encapsulation]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] How about Form?]]></title>
    <url>%2F2016%2F04%2F20%2Fangular2-how-about-form%2F</url>
    <content type="text"><![CDATA[在Angular2的Form, 可以使用[(ngModel)]的方式或是使用 ngFormModel的方式(如下)。 ngModel就不多描述，用法跟Angular1.x一樣 123456789101112131415161718192021222324&lt;form [ngFormModel]="form" (submit)="add($event)"&gt; &lt;div class="col col-4 mr2"&gt; &lt;label class="label"&gt;類別&lt;/label&gt; &lt;select class="select" ngControl="category"&gt; &lt;option value=""&gt;--選擇--&lt;/option&gt; &lt;option value="類別1"&gt;類別1&lt;/option&gt; &lt;option value="類別2"&gt;類別2&lt;/option&gt; &lt;/select&gt; &lt;div *ngIf="!category.valid" class="red"&gt; 類別 Required &lt;/div&gt; &lt;/div&gt; &lt;div class="col col-4 mr2"&gt; &lt;label class="label"&gt;金額&lt;/label&gt; &lt;input class="input" type="number" ngControl="amon" /&gt; &lt;div *ngIf="!amon.valid" class="red"&gt; 金額 Required &lt;/div&gt; &lt;/div&gt; &lt;div class="col col-3 mt3"&gt; &lt;button class="btn btn-primary" type="submit" [disabled]="!form.valid"&gt;新增&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; js的部分如下 12345678910111213141516171819202122232425262728293031323334import &#123; Component &#125; from 'angular2/core';import &#123;FORM_DIRECTIVES, FormBuilder, Validators, ControlGroup, Control&#125; from 'angular2/common';@Component(&#123; selector: 'ck-book', directives: [FORM_DIRECTIVES], template: require('./book.html')&#125;)export class CkBookPage &#123; private form: ControlGroup; private amon: Control; private category: Control; private books = []; constructor(private builder: FormBuilder) &#123; this.amon = new Control("", Validators.required); this.category = new Control("", Validators.required); this.form = builder.group(&#123; category: this.category, amon: this.amon &#125;); &#125; add(event) &#123; console.log(this.form.value); let _value = Object.assign(&#123;&#125;, this.form.value); _value.date = new Date(); this.books.push(_value); event.preventDefault(); &#125;&#125;; 有幾個新東西出現. ngFormModel, ngControl. 這些都包含在FORM_DIRECTIVES裡. FormBuilder是用來組合東西給ngFormModel用, 是把Control包在一起 builder.group({ … controls}) Control是配合ngControl使用. 初始是 new Control(『default value』, validator, asyncValidator) 這樣的設定方式，可以讓Form上的動作都在javascript裡面設定。單純html的程式碼 小問題(till Verstion Beta15) input[type=number]空白時，預設的值會變成NaN. 但是這個被判斷是有值得，所以Validator.required是真的. 這個問題在github上有被提出來也被解決了，但是就到目前為止，修正未包含在裡面. 所以必須手動修改程式碼, 修改方式如下 修改檔案 檔案位置: angular2\src\common\forms\directives\number_value_accessor.js 1234567NumberValueAccessor.prototype.registerOnChange = function (fn) &#123; this.onChange = function (value) &#123; fn(lang_1.NumberWrapper.parseFloat(value)); &#125;; &#125;;change to NumberValueAccessor.prototype.registerOnChange = function (fn) &#123; this.onChange = function (value) &#123; fn(value == &apos;&apos; ? null : lang_1.NumberWrapper.parseFloat(value)); &#125;; &#125;; Github commit log date format設定. 原本 book.date | date:&quot;yyyy-MM-dd&quot;這樣子的寫法輸出的結果會是 2016-04-20. 但是現在的版本locale是被寫死的(en-US), 所以也是要進程式碼手動修改. 檔案位置: angular2\src\common\pipes 12// var defaultLocale = &apos;en-US&apos;; 修改這裡。參數可以參考moment.js網站var defaultLocale = &apos;zh-TW&apos;; 參考文章 custom-validators template-driven-forms ngBook2- Form learnangular2]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Make asp.net mvc core always serve index.html]]></title>
    <url>%2F2016%2F04%2F19%2Fangular2-make-aspnet-mvc-core-always-serve-indexhtml%2F</url>
    <content type="text"><![CDATA[Angular2的預設route模式是html5，這個在跑到其他頁面後，在重新整理頁面後會出現空白頁面，這是因為找不到Index的入口了。所以解決方式就是要讓MVC Core可以每次都載入Index.html頁面(如果純靜態頁面的方式) 在startup.cs的Configure function, 加入以下程式碼 1234567891011app.Use(async (context, next) =&gt;&#123; // 判斷request如果不是api call時，則要讀取index.html if (!Path.HasExtension(context.Request.Path.Value) &amp;&amp; context.Request.HttpContext.Request.Headers["X-Custom-Header"] != "api" &amp;&amp; context.Request.HttpContext.Request.Headers["X-Requested-With"] != "XMLHttpRequest") &#123; await context.Response.WriteAsync(System.IO.File.ReadAllText("index.html")); &#125; await next();&#125;); 在Angular2的index.ts裡設定讓所有的request的header都新增 X-Custom-Header=api，讓server判斷是否為api call 1234567891011import &#123; HTTP_PROVIDERS, BaseRequestOptions, RequestOptions, Headers &#125; from 'angular2/http';class requestOption extends BaseRequestOptions &#123; headers: Headers = new Headers(&#123; 'X-Custom-Header': 'api' &#125;);&#125;bootstrap(CkDemoApp, [ ... provide(RequestOptions, &#123; useClass: requestOption &#125;)]); 這樣子就可以讓Angular2跑到不同頁面時，不會因為重新整理而出現空白的畫面 如果是用Controller/View的方式，設定方法比照舊的設定方式即可]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] play with Redux part 3 - middleware]]></title>
    <url>%2F2016%2F04%2F19%2Fangular2-play-with-redux-part-3-middleware%2F</url>
    <content type="text"><![CDATA[Redux2的middleware是介於action和reducer之間。例如: ReduxThunk. 設定方式是在建立store時，將middleware指定給store即可 寫自訂的middleware基本架構如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import isPromise from '../utils/is-promise';export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isPromise(action.payload)) &#123; return next(action); &#125; const &#123; types, payload, meta &#125; = action; const &#123; promise, data &#125; = payload; const [PENDING, FULFILLED, REJECTED] = types; /** * Dispatch the pending action */ let pendingAction = &#123; type: PENDING, payload: null, meta: null &#125;; if (_.isEmpty(data)) &#123; pendingAction.payload = data; &#125; if (_.isEmpty(meta)) &#123; pendingAction.meta = meta; &#125; dispatch(pendingAction); /** * If successful, dispatch the fulfilled action, otherwise dispatch * rejected action. */ return promise.then( result =&gt; &#123; dispatch(&#123; type: FULFILLED, payload: result, meta, &#125;); &#125;, error =&gt; &#123; dispatch(&#123; type: REJECTED, payload: error, meta, &#125;); &#125; ); &#125;;&#125; store的設定方式如下 123456789101112131415161718192021function configureStore(initialState) &#123; const store = compose( _getMiddleware() )(createStore)(rootReducer, initialState); return store;&#125;function _getMiddleware() &#123; // 這裡加入middleware let middleware = [ promiseMiddleware, ReduxThunk ]; if (__DEV__) &#123; middleware = [...middleware]; &#125; return applyMiddleware(...middleware);&#125; 參考文件: - middleware - redux-thunk]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] play with Redux part 2]]></title>
    <url>%2F2016%2F04%2F17%2Fangular2-redux-with-service%2F</url>
    <content type="text"><![CDATA[在Part 1提到在aciton裡面，如果有需要呼叫api的行為，都會發生這個階段 目前有發現有兩種方式可以處理api. angular的service(http call) fetch api 如果利用第二種方式處理api call時，可以直接寫在action裡面。但是如果想要利用angular的service方式時，就要繞一下路了 但是，還是先簡單的寫一下fetch的方式 1234567891011121314151617export function loadTodo() &#123; return dispatch =&gt; &#123; return fetch('api/Values') .then((response) =&gt; &#123; return response.json() &#125;) .then((data) =&gt; &#123; return (&#123; type: TODO_INIT, payload: data &#125;); &#125;) .then((action) =&gt; &#123; dispatch(action); &#125;) &#125;&#125; 利用service的code如下 1234567891011121314151617181920212223242526import &#123;Injectable, Inject &#125; from 'angular2/core';import &#123;Http, Response&#125; from 'angular2/http';import 'rxjs/Rx';import &#123;TODO_INIT&#125; from '../constants';@Injectable()export class TodoService &#123; constructor( @Inject('ngRedux') private store, private http: Http) &#123; &#125; loadTodo() &#123; return this.http.get('api/Values') .map((res) =&gt; &#123; return res.json() &#125;) .map((d) =&gt; (&#123; type: TODO_INIT, payload: d &#125;)) .subscribe((action) =&gt; &#123; this.store.dispatch(action); &#125;) &#125;&#125;]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] play with Redux part 1]]></title>
    <url>%2F2016%2F04%2F15%2Fangular2-play-with-redux%2F</url>
    <content type="text"><![CDATA[Redux是根據Facebook的flux所產出的一個架構. 簡單介紹請參考這裡 簡單的動作及資料流程如下 複雜一點的流程圖如下 每一個階段都有他應該要做的事情 - Action: 處理資料，呼叫API, 任何有可能產生副作用的行為都在這階段處理, 通常都是回傳JSON object. - Reducer: 根據Action傳來的動作和資料，來決定與原本的資料(In Store)的關係，例如、新增、更新、移除或過濾等,回傳要顯示在View上面的資料 ##程式碼 @Component程式的基本架構 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; Component, Inject, ApplicationRef&#125; from 'angular2/core';import * as TodoAction from '../../actions/ToDo';@Component(&#123; selector: 'ck-todo-app', template: require('./TodoPage.html')&#125;)export class CkTodoApp &#123; private disconnect: Function; private unsubscribe: Function; private items: any; private task: any; constructor( @Inject('ngRedux') private ngRedux, private applicationRef: ApplicationRef) &#123; &#125; ngOnInit() &#123; this.disconnect = this.ngRedux.connect( this.mapStateToThis, this.mapDispatchToThis)(this); this.unsubscribe = this.ngRedux.subscribe(() =&gt; &#123; this.applicationRef.tick(); &#125;); &#125; ngOnDestroy() &#123; this.unsubscribe(); this.disconnect(); &#125; // 註冊store到變數上 mapStateToThis(state) &#123; return &#123; items: state.todo, task: state.newtodo &#125;; &#125; // 註冊功能到這個Class裡 mapDispatchToThis(dispatch) &#123; return &#123; add: (task) =&gt; dispatch(TodoAction.add(Object.assign(&#123;&#125;, task))), remove: (task) =&gt; dispatch(TodoAction.remove(task)) &#125;; &#125;&#125;; TodoPage.html 123456789101112&lt;div class="clearfix mx-auto col-8"&gt; &lt;h3&gt;TODO App&lt;/h3&gt; &lt;div class="clearfix mxn2"&gt; &lt;input type="text" [(ngModel)]="task.content" class="input inline-block" /&gt; &lt;button class="btn btn-primary inline-block" (click)="add(task)"&gt;Add&lt;/button&gt; &lt;/div&gt; &lt;div class="clearfix mxn2"&gt; &lt;ul class="list-reset" *ngFor="#item of items"&gt; &lt;li&gt;&#123;&#123; item.content &#125;&#125; &lt;span (click)="remove(item)"&gt;x&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; ###註冊Store as provider in Angular2 application 123456789101112131415161718192021import &#123; enableProdMode, provide &#125; from 'angular2/core';import &#123; bootstrap&#125; from 'angular2/bootstrap';import &#123; ROUTER_PROVIDERS, APP_BASE_HREF &#125; from 'angular2/router';import &#123; CkDemoApp &#125; from './containers/main-app';// 註冊redux store用import configureStore from './store/configure-store';const provider = require('ng2-redux').provider;const store = configureStore(&#123;&#125;);declare let __PRODUCTION__: any;if (__PRODUCTION__) &#123; enableProdMode();&#125;bootstrap(CkDemoApp, [ provider(store), ROUTER_PROVIDERS, provide(APP_BASE_HREF, &#123; useValue: '/' &#125;)]); store/configureStore 1234567891011121314151617181920212223242526272829///&lt;reference path="./dev-types.d.ts"/&gt;import &#123;createStore, applyMiddleware, compose&#125; from 'redux';import &#123;fromJS&#125; from 'immutable';import ReduxThunk from 'redux-thunk';import rootReducer from '../reducers';const persistState = require('redux-localstorage');function configureStore(initialState) &#123; const store = compose( _getMiddleware() )(createStore)(rootReducer, initialState); return store;&#125;function _getMiddleware() &#123; let middleware = [ ReduxThunk ]; if (__DEV__) &#123; middleware = [...middleware]; &#125; return applyMiddleware(...middleware);&#125;export default configureStore; 設定ACTIONs actions/Todo 1234567891011121314import &#123; TODO_ADD, TODO_REMOVE &#125; from '../constants';export function add(task) &#123; return &#123; type: TODO_ADD, data: task &#125;&#125;export function remove(task) &#123; return &#123; type: TODO_REMOVE, data: task &#125;&#125; 設定可以使用的Reducers reducers/index 12345678910import &#123; combineReducers &#125; from 'redux';// reducer functionsimport &#123;todo, newtodo&#125; from './todo';// 下面的名稱是要存取store資料時的名稱// ex. state.todoexport default combineReducers(&#123; todo, newtodo&#125;); reducers/todo.ts 1234567891011121314151617181920212223242526import &#123; fromJS, List &#125; from 'immutable';import &#123; TODO_ADD, TODO_REMOVE &#125; from '../constants';const INITIAL_STATE = List&lt;any&gt;();// todo Reducerexport function todo(state = INITIAL_STATE, action: any = &#123; type: '' &#125;) &#123; switch (action.type) &#123; case TODO_ADD: return state.push(action.data); case TODO_REMOVE: return state.remove(state.indexOf(action.data)); default: return state; &#125;&#125;// newtodo Reducerexport function newtodo(state = &#123; content: '' &#125;, action: any = &#123; type: '' &#125;) &#123; switch (action.type) &#123; case TODO_ADD: return &#123; content: '' &#125;; default: return state; &#125;&#125; CODE 參考資料: - Angular 2 — Introduction to Redux - Angular 2 and Redux - redux - ng2-redux - immutable.js - work with service]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VS2015] 使用全域的NPM]]></title>
    <url>%2F2016%2F04%2F14%2Fvs2015-uses-global-npm-version%2F</url>
    <content type="text"><![CDATA[今天透過Visual studio 2015 執行webpack時，竟然返回錯誤訊息。 我確定該webpack.config.js是可以跑的，但是為什麼在Visual studio 2015裡面執行卻是不行的，結果發現理由是node跟npm的版本有關係 我的webpack.config.js裡面有下’use strict’; 然後有使用到const, 所以VS就不開心了. 因為所使用的node版本不認識ES2015的東西. 解決方式是讓visual studio執行npm command時，使用本機電腦所使用的版本而不是Visual studio本身所用的版本, 將 ** $(PATH)**移到最上面 這樣子的設定就可以讓VS在執行npm時，就會按照上圖的順序去找執行]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>VS2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Bot] FormFlow]]></title>
    <url>%2F2016%2F04%2F06%2Fbot-formflow%2F</url>
    <content type="text"><![CDATA[基本版 根據官方文件的作法，當一個formflow完成後，那個Converstaion就會結束，不管之後再傳給bot什麼文字，Bot都不會有任何反應, 除非一個新的ConverstaionID重新建立 但是，在某些訊息環境，是沒有辦法更新ConverstaionID的. 這時候就需要自訂一個Dialog來處理FormComplete及其他的情形 就像官方文件所提到的Dialog是非常強大的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[Serializable] public class SandwichDialog : IDialog &#123; private readonly BuildForm&lt;SandwichOrder&gt; SandwichOrderForm; internal SandwichDialog(BuildForm&lt;SandwichOrder&gt; SandwichOrderForm) &#123; this.SandwichOrderForm = SandwichOrderForm; &#125; public async Task StartAsync(IDialogContext context) &#123; context.Wait(MessageReceivedAsync); &#125; public async Task MessageReceivedAsync(IDialogContext context, IAwaitable&lt;Message&gt; argument) &#123; var message = await argument; var pizzaForm = new FormDialog&lt;SandwichOrder&gt;(new SandwichOrder(), this.SandwichOrderForm, FormOptions.PromptInStart); context.Call&lt;SandwichOrder&gt;(pizzaForm, FormComplete); &#125; private async Task FormComplete(IDialogContext context, IAwaitable&lt;SandwichOrder&gt; result) &#123; SandwichOrder order = null; try &#123; order = await result; &#125; catch (OperationCanceledException) &#123; await context.PostAsync(&quot;You canceled the form!&quot;); return; &#125; catch (Exception ex) &#123; await context.PostAsync(ex.Message); return; &#125; if (order != null) &#123; await context.PostAsync(order.ToString()); &#125; else &#123; await context.PostAsync(&quot;Form returned empty response!&quot;); &#125; context.Wait(MessageReceivedAsync); &#125; &#125; 這個是當pizzaForm完成後，則執行FormComplete. 1context.Call&lt;T&gt;(pizzaForm, FormComplete); 在 FormComplete 裡面，可以取得使用者所輸入的選項，所以後續要處理的動作會寫在此處 Gist]]></content>
      <categories>
        <category>BOT</category>
      </categories>
      <tags>
        <tag>botframework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Bot] 來寫Bot吧...讓我想起 MSN Bot了]]></title>
    <url>%2F2016%2F04%2F01%2Fbot-to-write-a-bot-makes-me-think-of-msn-bot%2F</url>
    <content type="text"><![CDATA[先從基本的開始，跟著下面的文章做，就可以完成基本的Bot功能了 http://docs.botframework.com/connector/getstarted/#navtitle 注意事項 當在新增【My Bot】時，Endpoint的網址一定要用https, 不然之後在測試Bot Connector時會出現403, 無法授權等奇怪的狀況. 如果使用web chat embed code時，要把他們所提供網址裡的s=[secret] 改成 t=[secret] ###程式基本的運作方式 Bot在與Bot Connector之間的溝通是透過傳遞Message. 這個Message裡面會包含很多資訊，也可以保留狀態(所以可以建立一連串的問題，就像在執行npm init時會問一堆問題一樣) 網站參考 總結: 一切都是在玩弄Message這個物件阿.]]></content>
      <categories>
        <category>BOT</category>
      </categories>
      <tags>
        <tag>botframework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MVC Core] Run with Docker]]></title>
    <url>%2F2016%2F03%2F27%2Fmvc-core-run-with-docker%2F</url>
    <content type="text"><![CDATA[基於Docker安裝步驟變簡單了，所以是時候來玩Docker了. 在MVC Core的目錄下，新增一個檔案Dockfile, 內容如下 12345678FROM microsoft/aspnet:1.0.0-rc1-update1COPY . /appWORKDIR /appRUN [&quot;dnu&quot;, &quot;restore&quot;]EXPOSE 5000/tcpENTRYPOINT [&quot;dnx&quot;, &quot;-p&quot;, &quot;project.json&quot;, &quot;web&quot;,&quot;--server.urls&quot;, &quot;http://0.0.0.0:5000&quot;] **server.urls 需要指定到0.0.0.0:port, 不然在docker run起來的時候，網頁會說Refused to Connect server.urls的設定方式可以參考這裡 開啟命令視窗，到有Dockerfile檔案的資料夾並執行下列指令 1docker build -t &lt;imageName&gt; . 上列指令這會建立一個docker image file 接下來就要讓所建立出來的Image執行起來, 執行下列指令 1docker run -t -d -p 5000:5000 &lt;imageName&gt; 詳細的Docker指令用法，請參閱官方網站]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC Core</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Docker] Installing Docker on Windows 問題集]]></title>
    <url>%2F2016%2F03%2F27%2F685100%2F</url>
    <content type="text"><![CDATA[###今天下載了docker Toolbox for windows ，根據安裝指示安裝後，在執行時出現了一個錯誤訊息 1hyper-v is installed. virtualbox won&apos;t boot a 64 bits vm in hyper-v is activated .... 排除方式為:修改 Program Files\Docker Toolbox\start.sh 在start.sh檔裡面，尋找 1&quot;$&#123;DOCKER_MACHINE&#125;&quot; create -d virtualbox &quot;$&#123;VM&#125;&quot; 更改成 1&quot;$&#123;DOCKER_MACHINE&#125;&quot; create --virtualbox-no-vtx-check -d virtualbox &quot;$&#123;VM&#125;&quot; 即可排除此錯誤訊息 ###當在command下docker command時，出現以下錯誤訊息 1An error occurred trying to connect: Get http://127.0.0.1:2375/v1.22/containers/json: dial tcp 127.0.0.1:2375: connectex: No connection could be made because the target machine actively refused it. 排除方式為 docker-machine start default or create new one docker-machine ls will show you your machine running docker-machine env --shell cmd default and you’ll see something like SET DOCKER_TLS_VERIFY=1 SET DOCKER_HOST=tcp://xxx.xxx.xxx.xxx:2376 SET DOCKER_CERT_PATH=C:\Users\Arseny.docker\machine\machines\default SET DOCKER_MACHINE_NAME=default REM Run this command to configure your shell: REM FOR /f 「tokens=*」 %i IN (『docker-machine env --shell cmd default』) DO %i 4.Run 1FOR /f &quot;tokens=*&quot; %i IN (&apos;docker-machine env --shell cmd default&apos;) DO %i 5.Enjoy. 就可以正常的下docker指令了]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Note] Gulpfile.js]]></title>
    <url>%2F2016%2F01%2F21%2Fnote-gulpfilejs%2F</url>
    <content type="text"><![CDATA[目前開發所需的gulpfile.js版本 工作流程 for angular 1.x開發 [typescript]-&gt;[javascript]-&gt;[webpack]-&gt;bundle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;), tsc = require(&apos;gulp-typescript&apos;), inject = require(&apos;gulp-inject&apos;), tsProject = tsc.createProject(&apos;tsconfig.json&apos;), webpack = require(&apos;webpack&apos;), gulpWebpack = require(&apos;webpack-stream&apos;), ngAnnotatePlugin = require(&apos;ng-annotate-webpack-plugin&apos;), path = require(&apos;path&apos;);gulp.task(&apos;compile-ts&apos;, function () &#123; var sourceTsFiles = [&apos;./app/src/**/*.ts&apos;, //path to typescript files &apos;./app/typings/**/*.ts&apos;]; //reference to library .d.ts files var tsResult = gulp.src(sourceTsFiles) .pipe(tsc(tsProject)); tsResult.dts.pipe(gulp.dest(&apos;./app/dist&apos;)); return tsResult.js.pipe(gulp.dest(&apos;./app/dist&apos;));&#125;); gulp.task(&apos;gen-ts-refs&apos;, function () &#123; var target = gulp.src(&apos;./app/src/app.d.ts&apos;); var sources = gulp.src([&apos;./app/src/**/*.ts&apos;], &#123; read: false &#125;); return target.pipe(inject(sources, &#123; starttag: &apos;//&#123;&apos;, endtag: &apos;//&#125;&apos;, transform: function (filepath) &#123; if (filepath.indexOf(&apos;index&apos;) &gt; -1) &#123; return; &#125; if (filepath.indexOf(&apos;app.d.ts&apos;) &gt; -1) &#123; return; &#125; return &apos;/// &lt;reference path=&quot;../..&apos; + filepath + &apos;&quot; /&gt;&apos;; &#125; &#125;)).pipe(gulp.dest(&apos;./app/src/&apos;)); &#125;);gulp.task(&apos;watch&apos;, function () &#123; gulp.watch([&apos;./app/src/**/*.ts&apos;], [&apos;webpack&apos;]);&#125;);gulp.task(&apos;webpack&apos;, [&apos;compile-ts&apos;], function () &#123; return gulp.src(&apos;./app/dist/app.js&apos;) .pipe(gulpWebpack(&#123; entry: &#123; bundled: &apos;./app/dist/app.js&apos;, commands: &apos;./app/dist/libs.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, &#125;, resolve: &#123; // this tells Webpack where actually to find lodash because you&apos;ll need it in the ProvidePlugin alias: &#123; lodash: path.resolve(__dirname, &apos;./node_modules/lodash&apos;), angular: path.resolve(__dirname, &apos;./node_modules/angular&apos;) &#125;, extensions: [&apos;&apos;, &apos;.js&apos;] &#125;, module: &#123; loaders: [ &#123; test: /[\/]angular\.js$/, loader: &quot;exports?angular&quot; &#125; ] &#125;, plugins: [ new webpack.ContextReplacementPlugin(/moment[\/\\]locale$/, /en/), // this tells Webpack to provide the &quot;_&quot; variable globally in all your app files as lodash. new webpack.ProvidePlugin(&#123; _: &quot;lodash&quot;, &#125;), new ngAnnotatePlugin(&#123; add: true &#125;) // new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), //new webpack.optimize.UglifyJsPlugin(&#123; // compress: &#123; // warnings: false // &#125;, // output: &#123; comments: false &#125; //&#125;) ] &#125;)) .pipe(gulp.dest(&apos;./Scripts&apos;));&#125;)gulp.task(&apos;default&apos;, [&apos;watch&apos;]); package.json 1234567891011121314151617...&quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.0&quot;, &quot;gulp-inject&quot;: &quot;^3.0.0&quot;, &quot;gulp-typescript&quot;: &quot;^2.10.0&quot;, &quot;gulp-tsd&quot;: &quot;^0.0.4&quot;, &quot;tsd&quot;: &quot;^0.6.5&quot;, &quot;typescript&quot;: &quot;^1.7.5&quot;, &quot;ng-annotate-webpack-plugin&quot;: &quot;^0.1.2&quot;, &quot;path&quot;: &quot;^0.11.14&quot;, &quot;webpack&quot;: &quot;^1.11.0&quot;, &quot;webpack-stream&quot;: &quot;^2.1.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;angular&quot;: &quot;^1.4.8&quot;, &quot;lodash&quot;: &quot;^4.0.0&quot; &#125; 需要disable visual studio裡面對於typescript的compile，編輯csproj的第一個 12加入這個讓vs不要在Build的時候編譯Typescript&lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt; 另外需要 123&lt;PropertyGroup Condition=&quot; &apos;$(Configuration)|$(Platform)&apos; == &apos;Debug|AnyCPU&apos; &quot;&gt;在這個項目下，增加&lt;TypeScriptModuleKind&gt;commonjs&lt;/TypeScriptModuleKind&gt;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Angular] Outputs & Inputs]]></title>
    <url>%2F2016%2F01%2F14%2Fangular2-outputs%2F</url>
    <content type="text"><![CDATA[Angular 在 Components之間的值得傳遞方式分割成Inputs和Outputs. 寫法如下 123456789101112131415161718@Components(&#123; ...., inputs:[&apos;init&apos;], outputs:[&apos;finish&apos;] &#125;)export class xxx()&#123; okEvent: EventEmitter&lt;any&gt; = new EventEmitter(); ok()&#123; // this should match the type define in EventEmitter this.okEvent.emit(&apos;the value want to pass&apos;); &#125;&#125;// in another components&lt;ddd (finish)=&quot;finish($event)&quot; [init]=&quot;value pass in&quot;&gt;&lt;/ddd&gt;$event =&gt; will catch the return value 另外一種寫法 123456789101112131415161718192021import &#123; Component, View, Input, Output, EventEmitter &#125; from &apos;angular2/angular2&apos;;@Components(&#123; ....&#125;)export class xxx()&#123; @Input() init; // @Output(alias name) @Output(&apos;finish&apos;) okEvent:EventEmitter&lt;Any&gt; = new EventEmitter(); ok()&#123; // this should match the type define in EventEmitter if use typescript this.okEvent.emit(&apos;the value want to pass&apos;); &#125;&#125;// in another components&lt;ddd (finish)=&quot;finish($event)&quot; [init]=&quot;value pass in&quot;&gt;&lt;/ddd&gt;$event =&gt; will catch the return value]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF] Entity Framework Core 1.0 - Migration with Exist Database]]></title>
    <url>%2F2016%2F01%2F12%2Fef-entity-framework-7-migration-with-exist-database%2F</url>
    <content type="text"><![CDATA[After Scaffold from existing datbase, and then add migration at first time. EF will create something like above. But in first migration will have everything that already existed in database. therefore, delete that file and add migration again. Now this time. you will get an empty migration file. WHy? because ContextModelSnapShot. It seems EF will compare all model files with snapshot file. and find the differences to create migration content file. And Now it switch to Code first mode. ^^ EF 7 Doc]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>EF Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MVC 6] Authorize Redirect to Login Page]]></title>
    <url>%2F2015%2F12%2F16%2Fmvc-6-authorize-redirect-to-login-page%2F</url>
    <content type="text"><![CDATA[http://docs.asp.net/en/latest/security/authorization/simple.html 這裡描述怎麼設定頁面授權的方式，可是卻都沒有提到如果說沒授權的人要頁面轉至登入畫面的方式 經過網頁上的查詢及測試後. 在1.0.0-rc1-update1的版本裡，設定方式如下 startup.cs 12345678910111213141516public void ConfigureServices(IServiceCollection services)&#123; services.AddAuthentication(); .....&#125; public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; app.UseCookieAuthentication(options =&gt; &#123; options.LoginPath = &quot;/Home/Login&quot;; options.AutomaticAuthenticate = true; options.AutomaticChallenge = true; &#125;); ....&#125; 到這裡為止就可以做出跟以前一樣遇到沒有授權的頁面就轉到登入畫面了 ###參數說明 重點在於AutomaticAuthenticate 及 AutomaticChallenge 這兩個參數 他的說明如下: AutomaticAuthenticate: If true the authentication middlleware alter the request user coming in. If false the authentication middleware will only provide identity when explicitly indicated by the AuthenticationScheme. AutomaticChallenge: If true the authentication middleware should handle automatic challenge. If false the authentication middleware will only alter responses when explicitly indicated by the AuthenticationScheme. 這裡出現另外一個參數 AuthenticationScheme AuthenticationScheme: The AuthenticationScheme in the options corresponds to the logical name for a particular authentication scheme. A different value may be assigned in order to use the same authentication middleware type more than once in a pipepline. 這表示在Controller裡的[Authorize]可以指定AuthenticationScheme, 就可以做出很有彈性的權限設定轉址或是其他後續動作了 12[Authorize(ActiveAuthenticationSchemes =&quot;abc&quot;)]public IActionResult Index()&#123;&#125; ##update 設定頁面授權的方式在這裡 http://docs.asp.net/en/latest/security/authentication/cookie.html Reference ASP.NET 5/MVC 6 自訂使用Claim驗証]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] ngOptions in 1.4]]></title>
    <url>%2F2015%2F11%2F08%2Fangular-ngoptions-in-14%2F</url>
    <content type="text"><![CDATA[之前沒有特別留意ngOptions在1.4版裡面修正了一些東西，包含track by的用法 先簡單的描述一下狀況 12345678910111213$scope.options = [ &#123;id:1,display:&quot;1&quot;&#125;, &#123;id:2,display:&quot;2&quot;&#125;, &#123;id:3,display:&quot;3&quot;&#125;, &#123;id:4,display:&quot;4&quot;&#125;, &#123;id:5,display:&quot;5&quot;&#125; ] ; $scope.selected = 3;// html&lt;select ng-options=&quot;m.id as m.display for m in options&quot; ng-model=&quot;selected&quot;&gt;&lt;/select&gt; 這種寫法應該算是很常見的用法 但是這樣子的寫法經過1.4版處理後, 仔細去看他的html會變成 1234567&lt;select ng-options=&quot;m.id as m.display for m in options&quot; ng-model=&quot;selected&quot;&gt; &lt;option label=&quot;1&quot; value=&quot;number:1&quot;&gt;1&lt;/option&gt; &lt;option label=&quot;2&quot; value=&quot;number:2&quot;&gt;2&lt;/option&gt; &lt;option label=&quot;3&quot; value=&quot;number:3&quot; selected=&quot;selected&quot;&gt;3&lt;/option&gt; &lt;option label=&quot;4&quot; value=&quot;number:4&quot;&gt;4&lt;/option&gt; &lt;option label=&quot;5&quot; value=&quot;number:5&quot;&gt;5&lt;/option&gt;&lt;/select&gt; 竟然多了型別…&gt;&quot;&lt;, 這表示如果我的$scope.selected = '3’時，就會選不到東西了 好吧，那如果用track by呢 12&lt;select ng-options=&quot;m.id as m.display for m in options track by m.id&quot; ng-model=&quot;selected&quot;&gt;&lt;/select&gt; DOM 12345678&lt;select ng-options=&quot;m.id as m.display for m in options track by m.id&quot; ng-model=&quot;selected&quot;&gt; &lt;option value=&quot;?&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt; &lt;option label=&quot;1&quot; value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option label=&quot;2&quot; value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option label=&quot;3&quot; value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option label=&quot;4&quot; value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;option label=&quot;5&quot; value=&quot;5&quot;&gt;5&lt;/option&gt;&lt;/select&gt; 這樣子看起來正常多了，但是$scope.selected的值不管是使用 3 or 「3」 都選不到東西. 只有給他options裡面的某一個object他才會被選定。 所以看起來track by是用 for m的m當作選定的值，那 select as label不就沒用了，沒用就拿掉他 12&lt;select ng-options=&quot;m.display for m in options track by m.id&quot; ng-model=&quot;selected&quot;&gt;&lt;/select&gt; DOM 12345678&lt;select ng-options=&quot;m.id as m.display for m in options track by m.id&quot; ng-model=&quot;selected&quot;&gt; &lt;option value=&quot;?&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt; &lt;option label=&quot;1&quot; value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option label=&quot;2&quot; value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option label=&quot;3&quot; value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option label=&quot;4&quot; value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;option label=&quot;5&quot; value=&quot;5&quot;&gt;5&lt;/option&gt;&lt;/select&gt; 看起來都一樣了 結論 用track by: select裡的ng-model會是以object的型態呈現, 不需要再寫select as xxxx了. 不用track by: 就看所表示的select是怎樣的型態，ng-model就是怎樣的型態，但是多了型別的判斷]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javascript] ES2015 - Classes, Class inheritance]]></title>
    <url>%2F2015%2F10%2F26%2Fjavascript-es2015-class%2F</url>
    <content type="text"><![CDATA[Classes Class的組成元素: Constructor Prototype methods: Static methods: 不需要New class就可以使用, 類似C#的Static 12345678910111213141516171819202122class Polygon &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; get area() &#123; return this.calcArea() &#125; calcArea() &#123; return this.height * this.width; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); &#125; &#125; Hoisting: Class並沒有Hoisting特性，所以需要先定義才可以使用，這點須注意 Class inheritance Class也可以有繼承的性質 範例 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + &apos; makes a noise.&apos;); &#125;&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + &apos; barks.&apos;); &#125;&#125; Super的用法 Super用來呼叫Parent的function 12345678910111213141516class Cat &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + &apos; makes a noise.&apos;); &#125;&#125;class Lion extends Cat &#123; speak() &#123; super.speak(); // &lt;= this call Cat&apos;s speak function console.log(this.name + &apos; roars.&apos;); &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javascript] ES2015 - Default args, Spread operator]]></title>
    <url>%2F2015%2F10%2F24%2Fjavascript-es2015%2F</url>
    <content type="text"><![CDATA[Default args 可以將在function的參數給予預設值 123function fnWithDefaultArg(a,b=[])&#123; // some codes&#125; Spread operator The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) are expected. 12345function fn(a,b,c)&#123; // some codes&#125;var args = [1,2,3];fn(...args); &lt;= spread operator A more powerful array literal 12var parts = [&apos;shoulders&apos;, &apos;knees&apos;];var lyrics = [&apos;head&apos;, ...parts, &apos;and&apos;, &apos;toes&apos;]; // [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;] A better push 123var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET] 透過ajax的方式向webapi下載檔案]]></title>
    <url>%2F2015%2F10%2F20%2Faspnet-download-files-use-ajax-to-the-webapi%2F</url>
    <content type="text"><![CDATA[現在SPA的網站越來越盛行，下載檔案的功能在ajax下是有點麻煩，但是感謝HTML5下的Blob功能。網路上就有相對應的js功能出來 所以，引用這位大大的程式 (https://github.com/eligrey/FileSaver.js)，其相關限制都有在該專案上描述 所以使用方法如下 (Client端) 12345678910$http.post(&apos;api url&apos;, query, &#123; responseType: &apos;arraybuffer&apos; &#125;).then(function (response) &#123; var filename = (filename); var expectedMediaType = (file-Content-Type); openSaveAsDialog(filename, response.data, expectedMediaType);&#125;); function openSaveAsDialog(filename, content, mediaType) &#123; var blob = new Blob([content], &#123; type: mediaType &#125;); saveAs(blob, filename);&#125; 重點 : responseType 要設定為 arraybuffer (Server端) Webapi要回傳的httpresponseMessage內容如下, 不好意思程式碼是VB, 因為這個專案是用VB開發的，但是基本觀念的一樣的 12345678910Dim response As HttpResponseMessage = New HttpResponseMessage() &apos; _ms 是 MemoryStream, 這裡是因為要將NPOI所產生的excel檔做下載, 然而我將NPOI所產生出來的東西 &apos; 存入到 MemoryStream裡, 重點是ByteArrayContent Dim _filename as string = (filename) If _ms IsNot Nothing Then response.Content = New ByteArrayContent(_ms.ToArray()) End If response.Content.Headers.ContentType = New Headers.MediaTypeHeaderValue(&quot;application/octet-stream&quot;) response.Content.Headers.ContentDisposition = New Headers.ContentDispositionHeaderValue(&quot;attachment&quot;) With &#123;.FileName = HttpUtility.UrlPathEncode(_filename)&#125; Return Task.FromResult(response) 以上的動作就可以讓ajax的call直接做下載檔案的動作，就不用另外產生一個form然後做post到新視窗後再下載了 ^^]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javascript] ES2015 - Destructuring]]></title>
    <url>%2F2015%2F10%2F18%2Fjavascript-es2015-let%2F</url>
    <content type="text"><![CDATA[Destructuring 可以將值從陣列或是物件裡取出並設定到變數上 syntax 123[a, b] = [1, 2][a, b, ...rest] = [1, 2, 3, 4, 5]&#123;a, b&#125; = &#123;a:1, b:2&#125; Destructuring arrays 123456789var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];// without destructuringvar one = foo[0];var two = foo[1];var three = foo[2];// with destructuringvar [one, two, three] = foo; 其他用法 1.Multiple-value returns 123456function f() &#123; return [1, 2];&#125;var a, b;[a, b] = f();console.log(&quot;A is &quot; + a + &quot; B is &quot; + b); 2.Ignoring some returned values 1234567function f() &#123; return [1, 2, 3];&#125;var a, b;[a, ,b] = f();console.log(&quot;A is &quot; + a + &quot; B is &quot; + b);// A is 1 B is 3 3.衍伸用法: Pulling values from a regular expression match 123456var url = &quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;;var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);var [, protocol, fullhost, fullpath] = parsedURL;console.log(protocol); // logs &quot;https&quot; Destructuring objects 12345var o = &#123;p: 42, q: true&#125;;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // true 另外一種用法, 將物件裡的值設定到新的變數名稱上 123456789// syntax// &#123;object.propertyName: VariableName&#125; = object// Assign new variable namesvar o = &#123;p: 42, q: true&#125;;var &#123;p: foo, q: bar&#125; = o;console.log(foo); // 42console.log(bar); // true 衍生用法: Function argument defaults 123456789101112131415var [missing = true] = [];console.log(missing);// truevar &#123; message: msg = &quot;Something went wrong&quot; &#125; = &#123;&#125;;console.log(msg);// &quot;Something went wrong&quot;var &#123; x = 3 &#125; = &#123;&#125;;console.log(x);// 3function removeBreakpoint(&#123; url, line, column &#125;=&#123;&#125;) &#123; // ...&#125; 12345678910function drawES6Chart(&#123;size = &apos;big&apos;, cords = &#123; x: 0, y: 0 &#125;, radius = 25&#125; = &#123;&#125;) &#123; console.log(size, cords, radius); // do some chart drawing&#125;drawES6Chart(&#123; cords: &#123; x: 18, y: 30 &#125;, radius: 30&#125;); 另外一種情境 Module (non-ES6) loading 1const &#123; Loader, main &#125; = require(&apos;toolkit/loader&apos;); REF: Several demos and usages for ES6 destructuring.]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Windows 10] 郵件APP的熱鍵們]]></title>
    <url>%2F2015%2F10%2F18%2Fwindows-10-hot-key-mail-app%2F</url>
    <content type="text"><![CDATA[懶得再去微軟的網站找了，所以在此備註 CTRL+SHIFT+G 在交談中切換重要屬性 CTRL+D, DEL 刪除交談 退格鍵 封存交談 CTRL+Q 標示為已讀取 CTRL+U 標示為未讀取 CTRL+R 回覆目前郵件 CTRL+SHIFT+R 全部回覆 CTRL+F 轉寄目前郵件 CTRL+E,F3 搜尋 Alt+C 接受會議邀請 Alt+D 拒絕會議邀請 Alt+N 暫訂會議邀請 CTRL+N 建立新的電子郵件 CTRL+SHIFT+M 建立新的電子郵件 CTRL+SHIFT+V 移到檢視 CTRL+1 切換至 [郵件] CTRL+2 切換至 [行事曆] CTRL+SHIFT+I 切換至 [收件匣] CTRL+SHIFT+O 切換至 [寄件匣] ALT+I 新增附件 CTRL+M 手動同步帳戶 F9 手動同步帳戶 CTRL+ + 放大 CTRL+ - 縮小 ALT+S 傳送郵件 Ctrl + Enter 傳送郵件 F6 在區域間移動 F7 切換鍵盤瀏覽]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javascript] ES2015 - Arrow function, String templates, let, const]]></title>
    <url>%2F2015%2F10%2F18%2Fjavascript-es2015-arror-function-string-templates-let%2F</url>
    <content type="text"><![CDATA[在ES2015裡面，幾個比較大的改變Part1 Arrow Function 人真的可以在懶惰一點，為了不要寫__function__這幾個字，就有 ()=&gt;{} 的出現。這就是Arror Function 跟Lambda的表示法很像, 真的用法也是跟那個一樣 123456789101112// Oldvar old = function(n) &#123; return n * n;&#125;;// with Arror Functions express 1let new_1 = (n) =&gt; n * n;// with arror function express 2let new_2 = (n) =&gt; &#123; return n * n;&#125;; 另外一個要注意的是Arrow Scope的問題, 123456789101112var hendrik = &#123; this.name = &quot;Hendrik&quot;; sayHello: (names) =&gt; &#123; names.forEach((name)=&gt;&#123; console.log(`$&#123;this.name&#125; greets $&#123;name&#125;`); &#125;); &#125;&#125;hendrik.sayHello([&apos;frikkie&apos;]);// output // hendrik greets frikkie String templates 最快樂的事情非屬這個, 文字串的組合可以用 ` (鍵盤左上角流水符號的那個鍵), 可以讓你多行編輯文字字串 在配合 ${變數} 來將變數顯示在文字裡面。 這樣子就不用一堆的 『加號』 來串文字了，超快樂的 12345678910// oldfunction sayHello(name, surname)&#123; console.log(&apos;hello there &apos; + name + &apos; &apos; + surname + &apos;, the time is now &apos; + new Date());&#125;// new way function sayHello_new(name, surname)&#123; console.log(`hello there $&#123;name&#125; $&#123;surname&#125;, the time is now $&#123;new Date()&#125;`);&#125; FYI: 新版的C#/VB.net也有將此功能加入，已經可以不用string.format + 無數的{流水號}了 Let 非常重要 要將使用var來定義變數的改用let來定義變數, 這樣子就可以避免同樣名稱的變數在不同的scope被覆蓋的情形發生 1234567891011121314151617181920212223242526272829303132333435363738394041//=== old === var name = &apos;Fido&apos;, breed = &apos;schnauzer&apos;, owners = [&apos;Hendrik&apos;, &apos;Alice&apos;] ; console.log(name + &apos;(&apos; + breed + &apos;):&apos;); for(var i = 0; i &lt; owners.length; i++)&#123; var name = owners[i]; console.log(&apos;Owner &apos; + name);&#125;console.log(name);//output// Fido(schnauzer):// Owner Hendrik// Owner Alice// Alice (被改變掉了)//=== new ===let fname = &apos;Fido&apos;, breed = &apos;schnauzer&apos;, owners = [&apos;Hendrik&apos;, &apos;Alice&apos;];console.log(`$&#123;fname&#125; ($&#123;breed&#125;):`);for(let i = 0; i &lt; owners.length; i++)&#123; let fname = owners[i]; console.log(`Owner $&#123;fname&#125;`);&#125;console.log(fname);// output:// Fido (schnauzer):// Owner Hendrik// Owner Alice// Fido const 常數，當變數一旦被指定為const時，就不可以被改變了 1234const pi = Math.PI;pi = 123;// this will cause error message]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javascript] 學ES2015(ES6) & Typescript - 環境準備]]></title>
    <url>%2F2015%2F10%2F17%2Fjavascript-es6%2F</url>
    <content type="text"><![CDATA[準備練習環境 VSCode Gulp browersync Typescript 設定項目 tsconfig.json 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES5&quot;, &quot;module&quot;: &quot;amd&quot;, &quot;sourceMap&quot;: false, &quot;watch&quot;: true, &quot;outDir&quot;: &quot;public/&quot; &#125;&#125; tasks.json 12345678910111213&#123; &quot;version&quot;: &quot;0.1.0&quot;, &quot;command&quot;: &quot;gulp&quot;, &quot;isShellCommand&quot;: true, &quot;tasks&quot;: [ &#123; &quot;taskName&quot;: &quot;watch&quot;, &quot;isBuildCommand&quot;: true, &quot;showOutput&quot;: &quot;silent&quot;, &quot;problemMatcher&quot;: &quot;$tsc&quot; &#125; ]&#125; gulpfile.js 123456789101112131415161718192021222324var gulp = require(&apos;gulp&apos;), browserSync = require(&apos;browser-sync&apos;).create(), typescript = require(&apos;gulp-tsc&apos;); gulp.task(&apos;browser-sync&apos;,function()&#123; browserSync.init(&#123; server:&#123; baseDir:&quot;./&quot; &#125; &#125;) &#125;)gulp.task(&apos;compile&apos;,function()&#123; gulp.src([&apos;src/**/*.ts&apos;]) .pipe(typescript()) .pipe(gulp.dest(&apos;public/&apos;)) .pipe(browserSync.reload(&#123;stream:true&#125;));&#125;);gulp.task(&apos;watch&apos;,[&apos;browser-sync&apos;],function()&#123; gulp.watch([&apos;src/**/*.ts&apos;],[&apos;compile&apos;]);&#125;);gulp.task(&apos;default&apos;,[&apos;watch&apos;]); gulpfile會做兩件事情 當ts檔案有異動的時候做Compile並輸出到public的資料夾下 透過browsersync更新瀏覽器 這樣子就可以專心來練習javascript了]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET] ReportViewer的遠端報表路徑設定]]></title>
    <url>%2F2015%2F10%2F12%2Faspnet-reportviewer-remote-report-path-setting%2F</url>
    <content type="text"><![CDATA[###ReportViewer的遠端報表的設定方式 如果需要設定登入使用者的權限時, 需要實作IReportServerCredentials, 但是如果需要就抄下面的Code 用法: 1ReportViewer1.ServerReport.ReportServerCredentials = New CustomReportCredentials(username, password, domain) 1234567891011121314151617181920212223242526272829303132Imports System.NetPublic Class CustomReportCredentials Implements Microsoft.Reporting.WebForms.IReportServerCredentials &apos; local variable for network credential Private strUserName As String Private strPassWord As String Private strDomainName As String Public Sub New(ByVal UserName As String, ByVal PassWord As String, ByVal DomainName As String) strUserName = UserName strPassWord = PassWord strDomainName = DomainName End Sub Public ReadOnly Property ImpersonationUser() As System.Security.Principal.WindowsIdentity Implements Microsoft.Reporting.WebForms.IReportServerCredentials.ImpersonationUser Get &apos; not use ImpersonationUser Return Nothing End Get End Property Public ReadOnly Property NetworkCredentials() As System.Net.ICredentials Implements Microsoft.Reporting.WebForms.IReportServerCredentials.NetworkCredentials Get &apos; use NetworkCredentials Return New NetworkCredential(strUserName, strPassWord, strDomainName) End Get End Property Public Function GetFormsCredentials(ByRef authCookie As System.Net.Cookie, ByRef userName As String, ByRef password As String, ByRef authority As String) As Boolean Implements Microsoft.Reporting.WebForms.IReportServerCredentials.GetFormsCredentials &apos; not use FormsCredentials unless you have implements a custom autentication. authCookie = Nothing password = authority = Nothing Return False End FunctionEnd Class ServerReportUrl要指定SSRS的Report Server URL, 而不是Report Manager URL。因為這個URL的錯誤，讓我一直遇到404的錯誤. ex: http://serverIP/ReportServer ReportPath就是根據Root的相對應位置而設定，不需要.rdlc(localReport就需要搭配附檔名) 如果有參數要設定, 使用方式如下 123Dim objParms As New System.Collections.ObjectModel.Collection(Of ReportParameter)objParms.Add(New ReportParameter(&quot;param1&quot;, &quot;param1 value&quot;))ReportViewer1.ServerReport.SetParameters(objParms)]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET 5] 學習筆記]]></title>
    <url>%2F2015%2F08%2F07%2Faspnet-5-study-notes%2F</url>
    <content type="text"><![CDATA[##需求 Visual Studio 2015 ##Note 所有的參考都需要手動加入, 所以新功課會是了解每一個參考裡面有的功能是什麼 1. Microsoft.AspNet.Diagnostics =&gt; MiddleWare to handle request(ex: welcomepage, errorpage) 2. Microsoft.AspNet.StaticFiles =&gt; 顯示靜態網頁 Microsoft.AspNet.Diagnostics Example 123// app.useXXXXX app.UseWelcomePage(); app.UseErrorPage(); project.json 網站所有的設定都會在這個檔案裏面做設定, 包含dependencies, webroot, exclude, frameworks, etc. Commands 新增MVC功能 project.json add 「Microsoft.AspNet.Mvc」 to dependencies startup.cs 12345678910public void ConfigureServices(IServiceCollection services)&#123; services.AddMvc(); services.Configure&lt;MvcOptions&gt;(options =&gt; &#123; &#125;);&#125;public void Configure(IApplicationBuilder app)&#123; app.UseMvc();&#125; 如果要設定mvc route時, 在startup.cs的configure裡(in c# 6 syntax) 123456app.UseMvc(routes=&gt; &#123; routes.MapRoute( name: "Default", template: "&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"); &#125;); 建立Configuration dependence: 「Microsoft.Framework.Configuration.UserSecrets」 Useage: 1234567891011public Startup(IHostingEnvironment env, IApplicationEnvironment appEnv)&#123; // 設定ConfiurationBuilder var configurationBuilder = new ConfigurationBuilder(appEnv.ApplicationBasePath); configurationBuilder.AddJsonFile("config.json"); configurationBuilder.AddEnvironmentVariables(); // 必須執行Build才能建立Configuration物件 var config = configurationBuilder.Build(); // Build後 var value = config.get("key"); &#125; 使用TagHelpers 如果想要使用MVC內建的TagHelper, 幾個需要加入的dependencies 12&quot;Microsoft.AspNet.Mvc.TagHelpers&quot;: &quot;6.0.0-rc1-final&quot;,&quot;Microsoft.AspNet.Tooling.Razor&quot;: &quot;1.0.0-rc1-final&quot; &lt;= 在vs編輯時會將tag的部分顯示成不同的顏色及其他功能 然後在_ViewImports.cshtml加入 1@addTagHelper &quot;*, Microsoft.AspNet.Mvc.TagHelpers&quot;]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC CORE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MVC] 當MVC遇上exe檔(需要讀取網路磁碟機時)]]></title>
    <url>%2F2015%2F07%2F13%2Fmvc-when-the-mvc-in-exe-file-need-to-read-when-a-network-drive%2F</url>
    <content type="text"><![CDATA[最近要寫一個api，其功能需要呼叫一個exe執行檔然後取得該檔回傳的dbf檔案 但是該執行檔又需要讀取網路磁碟機的檔案。這IIS就會卡住了。不管權限怎麼設定都過不去。 所以只好繞路解決了. 解法是: 建立另外一個selfhost的webapi (console mode), 在該api下執行該執行檔就可以正常運作了，因為不是透過IIS. 然後網站去呼叫那個自行運作的webapi取回結果. 雖然有點麻煩，但是至少解決問題了。(浪費我兩天的生命) 關於selft的webapi建立方式，請參考webapi selfhost]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Devexpress] How to bind a objec to bindingsource in WEB xtrareport]]></title>
    <url>%2F2015%2F07%2F01%2Fdevexpress-how-to-bind-a-objec-to-bindingsource-in-web-xtrareport%2F</url>
    <content type="text"><![CDATA[Bindingsource物件是屬於winform的，所以在web環境下的design time是沒有辦法直接設定物件到datasource的屬性裡 所以這部分需要手動加進去，作法是進入 xxx.Designer.cs的InitializeComponent()加入 1this.bindingSource1.DataSource = typeof(Object); // replace with the object you want 這樣子回到設計模式就會出現可以設定的binding物件了 ^^]]></content>
      <categories>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Devexpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VFP] 讀ini檔案]]></title>
    <url>%2F2015%2F06%2F25%2Fvfp-read-ini-files%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021************************讀取ini file************************function getinit(mfilename,msection,mentry) local lcinifile,lcvalue,lcbuffer,luentryvalue,lnnumbytes*-- DECLARE DLL statements for reading/writing to private INI files declare integer GetPrivateProfileString in Win32API ; string cSection, string cKey, string cDefault, string @cBuffer, ; integer nBufferSize, string cINIFile local minivalue, mresult, mbuffersize mbuffersize = 255 minivalue = spac(mbuffersize) mresult=getprivateprofilestring(msection,mentry,&quot;*NULL*&quot;,@minivalue,mbuffersize,mfilename) minivalue=substr(minivalue,1,mresult) if minivalue=&quot;*NULL*&quot; minivalue=.null. endif return minivalueendfun demo config ini file 12[section]entryName=return value]]></content>
      <categories>
        <category>VFP</category>
      </categories>
      <tags>
        <tag>VFP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF] Connection resiliency]]></title>
    <url>%2F2015%2F06%2F12%2Fef-connection-resiliency%2F</url>
    <content type="text"><![CDATA[- connection retry policy - works great with async - four modes - DefaultExcutionStrategy - DefaultSqlExecutionStrategy - DbExecutionStrategy - SqlAzureExecutionStrategy - throws RetryLimitExceededException ##Configuration 12345678public class MyConfiguration : DbConfiguration &#123; public MyConfiguration() &#123; SetExecutionStrategy(&quot;System.Data.SqlClient&quot;, () =&gt; new SqlAzureExecutionStrategy(1, TimeSpan.FromSeconds(30))); &#125; &#125; MSDB 參考網址]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>Entity Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[WebDeploy] Microsoft.Web.Deployment.BuiltinTypesCache Throws an Exception on Deployment]]></title>
    <url>%2F2015%2F05%2F29%2Fwebdeploy-microsoftwebdeploymentbuiltintypescache-throws-an-exception-on-deployment%2F</url>
    <content type="text"><![CDATA[when use vs2013 deploy website to azure. error message 1The type initializer for &apos;Microsoft.Web.Microsoft.Web.Deployment.DeploymentManager&apos; threw an exception. The type initializer for &apos;Microsoft.Web.Microsoft.Web.Deployment.BuiltinTypesCache&apos; threw an exception. fix: uninstall dbsqlpackage provider . this packages no longer support.]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] OAuth]]></title>
    <url>%2F2015%2F05%2F24%2Faspnet-mvc-oauth%2F</url>
    <content type="text"><![CDATA[reference url - Thinktecture.IdentityModel Sample Owin]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Mono] Install Mono]]></title>
    <url>%2F2015%2F04%2F30%2Fmono-install-mono-40%2F</url>
    <content type="text"><![CDATA[取得最新的Mono http://www.mono-project.com/download/ Building Mono From a Git Source Code Checkout To build Mono in 64 bit mode instead use: 123456PATH=$PREFIX/bin:$PATHgit clone https://github.com/mono/mono.gitcd mono./autogen.sh --prefix=$PREFIX --disable-nlsmakemake install]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Mono</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] ASP.NET MVC with angular Html5Mode]]></title>
    <url>%2F2015%2F03%2F29%2Fangular-aspnet-mvc-with-angular-html5mode%2F</url>
    <content type="text"><![CDATA[經過一段時間的實驗. 在別的framework找到可以讓backend的route支援angular html5mode了. 基本方式是如果我路由規則沒有定義的，全部指向index頁面(有ng-view的) 所以基於這個原則. mvc的路由規則就要稍微調整一下. 將原本的DefaultApp修改一下 123456789101112// 舊 routes.MapRoute( name: &quot;DefaultApp&quot;, url: &quot;&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;, defaults: new &#123; controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional &#125; );// 新 routes.MapRoute( name: &quot;DefaultApp&quot;, url: &quot;app/&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;, defaults: new &#123; controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional &#125; ); 然後新增 1routes.Add(new SingleRoute()); SingleRoute Class 123456789101112131415public class SingleRoute : RouteBase &#123; public override RouteData GetRouteData(HttpContextBase httpContext) &#123; var data = new RouteData(this, new MvcRouteHandler()); data.Values.Add(&quot;controller&quot;, &quot;Home&quot;); data.Values.Add(&quot;action&quot;, &quot;Index&quot;); return data; &#125; public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) &#123; return null; &#125; &#125; Client angular side: 123456$stateProvider .state(&apos;state1&apos;, &#123; url: &quot;/state1&quot;, templateUrl: &quot;app/Home/state1&quot; &lt;= mvc route rule &#125;)$locationProvider.html5Mode(true).hashPrefix(&apos;!&apos;) 以上]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HTML] 讓span可以focus]]></title>
    <url>%2F2015%2F03%2F26%2Fhtml-span-to-focus%2F</url>
    <content type="text"><![CDATA[HTML裡有也Element是沒有辦法focus, 原因是因為它們預設的tabindex是-1 所以要讓他們能focus, 只要改變tabindex=0. 就可以了 1&lt;span tabindex=0&gt;something&lt;/span&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ngCordova] socialSharing - to Line]]></title>
    <url>%2F2015%2F03%2F19%2Fngcordova-socialsharing-to-line%2F</url>
    <content type="text"><![CDATA[when use ngCordova socialSharing plugin. there is a method 『canShareVia』 which can share to specific social application by it’s appPackageName. To Line(http://line.me) the packageName is jp.naver.line.android 1234var lineAppPackageName = &apos;jp.naver.line.android&apos;;$cordovaSocialSharing .shareVia(lineAppPackageName, content, subject, null, &apos;&apos;) ...]]></content>
      <categories>
        <category>Library</category>
      </categories>
      <tags>
        <tag>ngCordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Download file, but server doenst have php_fileinfo]]></title>
    <url>%2F2015%2F03%2F12%2Flaravel-download-file-but-server-doenst-have-php-fileinfo%2F</url>
    <content type="text"><![CDATA[Response::Download() in Laravel 4.x needs php_fileinfo extension. Sometimes web hosting server doesn’t have that extension on, althought it’s default for php 5.4. so the way to work around is make a response, and add header to it. See code below 12345$file = File::get($filepath);$response = Response::make($file, 200);$response-&gt;header(&apos;Content-Type&apos;, $item-&gt;mime);$response-&gt;header(&apos;Content-Disposition&apos;,&apos;attachment;filename=&quot;&apos;.$filename.&apos;&quot;&apos;);return $response;]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Laravel 5.0 with Angular]]></title>
    <url>%2F2015%2F02%2F24%2Flaravel-laravel-50-with-angular%2F</url>
    <content type="text"><![CDATA[之前有寫過一篇有關[Laravel] Laravel with Angular, 但是這個方法在Laravel 5.0裡面是不合用的 所以laravel 5.0的作法如下 在 app/Exceptions/Handler.php 裡修改render function 123456public function render($request, Exception $e) &#123; if ($e instanceof \Symfony\Component\HttpKernel\Exception\NotFoundHttpException) return response()-&gt;view(&apos;index&apos;)-&gt;header(&apos;Content-Type&apos;, &apos;text/html&apos;); return parent::render($request, $e); &#125; 這個效果等於laravel 4.x的app::missing]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>laravel 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React] 文章Memo]]></title>
    <url>%2F2015%2F02%2F11%2Freact-article-memo%2F</url>
    <content type="text"><![CDATA[Realtime Voting App with ASP.NET SignalR, React.js and D3.js]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] Directive筆記一下]]></title>
    <url>%2F2015%2F02%2F03%2Fangular-directive-notes%2F</url>
    <content type="text"><![CDATA[Scope Text Binding : @ Two-way Binding: = Method binding (One-way Binding): &amp; Ref website http://blog.johnsonlu.org/angularjs-directive/ https://umur.io/angularjs-directives-using-isolated-scope-with-attributes/]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Kinect] Day 1 - 讓程式碼先能動]]></title>
    <url>%2F2015%2F01%2F29%2Fkinect-day-1%2F</url>
    <content type="text"><![CDATA[Kinect Data Source - Color - Infrared - Depth - Body - BodyIndex For Windows 8.1 App - 開啟microphone, webcam權限 - 加入WindowsPreview.Kinect - 建置CPU設定為x86 取得kinectSensor的方式 123this.sensor = KinectSensor.GetDefault();this.sensor.Open();this.sensor.Close(); Readers 12InfraredFrameReader reader = this.sensor.InfraredFrameSource.OpenReader();reader.FrameArrived += InfraredReaderFrameArrvied; Frame references - Send in frame event args - AcquireFrame : access to the actual frame - RelativeTime : allow to templorally correlate frames 1234567891011private void InfraredReaderFrameArrvied(InfraredFrameReader sender, InfraredFrameArrivedEventArgs args)&#123; using (InfraredFrame frame = args.FrameReference.AcquireFrame()) &#123; if (frame != null) &#123; // Get What you need from the frame &#125; &#125; &#125; Frame - Gives access to the frame data - Make a local copy of access the underlying buffer directly - Contains metadata for the frame - Color, Format, width, height,etc. - Important: Not Disposing frames will cause you to not receive more frames Demo Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;using WindowsPreview.Kinect;using Windows.UI.Xaml.Media.Imaging;namespace KinectStudy_01&#123; public sealed partial class MainPage : Page &#123; public MainPage() &#123; this.InitializeComponent(); this.Loaded += MainPage_Loaded; &#125; KinectSensor sensor; InfraredFrameReader reader; ushort[] irData; byte[] irDateConverted; WriteableBitmap irBitmap; private void MainPage_Loaded(object sender, RoutedEventArgs e) &#123; sensor = KinectSensor.GetDefault(); reader = sensor.InfraredFrameSource.OpenReader(); FrameDescription fd = sensor.InfraredFrameSource.FrameDescription; irData = new ushort[fd.LengthInPixels]; irDateConverted = new byte[fd.LengthInPixels * 4]; irBitmap = new WriteableBitmap(fd.Width, fd.Height); image.Source = irBitmap; sensor.Open(); reader.FrameArrived += InfraredReaderFrameArrvied; &#125; private void InfraredReaderFrameArrvied(InfraredFrameReader sender, InfraredFrameArrivedEventArgs args) &#123; using (InfraredFrame frame = args.FrameReference.AcquireFrame()) &#123; if (frame != null) &#123; // Get What you need from the frame frame.CopyFrameDataToArray(irData); for (int i = 0; i &lt; irData.Length; i++) &#123; byte intensity = (byte)(irData[i] &gt;&gt; 8); irDateConverted[i * 4] = intensity; irDateConverted[i * 4 + 1] = intensity; irDateConverted[i * 4 + 2] = intensity; irDateConverted[i * 4 + 3] = 255; &#125; irDateConverted.CopyTo(irBitmap.PixelBuffer); irBitmap.Invalidate(); &#125; &#125; &#125; &#125;&#125; Demo2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;using WindowsPreview.Kinect;using Windows.UI.Xaml.Media.Imaging;using Windows.UI.Xaml.Shapes;using Windows.UI;namespace KinectStudy_01&#123; public sealed partial class MainPage : Page &#123; KinectSensor sensor; InfraredFrameReader reader; ushort[] irData; byte[] irDateConverted; WriteableBitmap irBitmap; Body[] bodies; MultiSourceFrameReader msfr; public MainPage() &#123; this.InitializeComponent(); this.Loaded += MainPage_Loaded; &#125; private void MainPage_Loaded(object sender, RoutedEventArgs e) &#123; sensor = KinectSensor.GetDefault(); reader = sensor.InfraredFrameSource.OpenReader(); FrameDescription fd = sensor.InfraredFrameSource.FrameDescription; irData = new ushort[fd.LengthInPixels]; irDateConverted = new byte[fd.LengthInPixels * 4]; irBitmap = new WriteableBitmap(fd.Width, fd.Height); image.Source = irBitmap; bodies = new Body[6]; msfr = sensor.OpenMultiSourceFrameReader(FrameSourceTypes.Body | FrameSourceTypes.Infrared); msfr.MultiSourceFrameArrived += msfr_MultiSourceFrameArrived; sensor.Open(); &#125; void msfr_MultiSourceFrameArrived(MultiSourceFrameReader sender, MultiSourceFrameArrivedEventArgs args) &#123; using (MultiSourceFrame frame = args.FrameReference.AcquireFrame()) &#123; if (frame != null) &#123; using (BodyFrame bodyframe = frame.BodyFrameReference.AcquireFrame()) &#123; using (InfraredFrame ifFrame = frame.InfraredFrameReference.AcquireFrame()) &#123; if (bodyframe != null &amp;&amp; ifFrame != null) &#123; // Get What you need from the frame ifFrame.CopyFrameDataToArray(irData); for (int i = 0; i &lt; irData.Length; i++) &#123; byte intensity = (byte)(irData[i] &gt;&gt; 8); irDateConverted[i * 4] = intensity; irDateConverted[i * 4 + 1] = intensity; irDateConverted[i * 4 + 2] = intensity; irDateConverted[i * 4 + 3] = 255; &#125; irDateConverted.CopyTo(irBitmap.PixelBuffer); irBitmap.Invalidate(); // 取得身體的相關資料 bodyframe.GetAndRefreshBodyData(bodies); bodyCanvas.Children.Clear(); foreach (Body body in bodies) &#123; if (body.IsTracked) &#123; // 取得頭的關節位置 Joint headJoint = body.Joints[JointType.Head]; if (headJoint.TrackingState == TrackingState.Tracked) &#123; // 轉換成DepthSpacePoint DepthSpacePoint dsp = sensor.CoordinateMapper.MapCameraPointToDepthSpace(headJoint.Position); // 在該位置上畫圓圈 Ellipse headCircle = new Ellipse() &#123; Width = 50, Height = 50, Fill = new SolidColorBrush(Color.FromArgb(255, 255, 0, 0)) &#125;; bodyCanvas.Children.Add(headCircle); Canvas.SetLeft(headCircle, dsp.X - 25); Canvas.SetTop(headCircle, dsp.Y - 25); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Kinect] 開始學習寫Kinect App ( 零 )]]></title>
    <url>%2F2015%2F01%2F22%2Fkinect-began-to-learn-to-write-a-kinect-app%2F</url>
    <content type="text"><![CDATA[Xbox One 同時推出Kinect v2，提供更強大的硬體功能及軟體功能, 剛好手上的案子也差不多到一個段落了。 所以決定來學習Kinect的開發 前置準備 Kinect for windows 如果已經有了xbox one, 可以只買kinect adapter轉接器就可以了 巴哈 Kinect sdk 2 硬體需求 CPU: i7(建議) RAM: 4GB(建議) GPU: DirectX11 (必須) USB 3.0（必須) OS: Windows 8.0/8.1(必須) 詳細細節請參考官方網站 已經買了adapter, 等東西寄到後就可以開始學習了]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Laravel with Angular]]></title>
    <url>%2F2015%2F01%2F05%2Flaravel-laravel-with-angular%2F</url>
    <content type="text"><![CDATA[當laravel想要好好的跟angular在一起時，Route都是他們之間的第三者。 前一陣子有發現一個還不錯的方式可以讓Laravel的Route失效。那就是利用 1234App::missing(function($exception)&#123; return View::make(&apos;index&apos;);&#125;); 這樣子的設定，就可以不用讓Laravel一直回傳index頁面. 如果需要其他路由設定時，就直接在上面新增即可. 當這樣子設定時，html頁面就可以放在public folder下面，不用使用blade template. 好處是，不用再多學習blade的語法。angular的操作也比較直覺。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] Website Always On]]></title>
    <url>%2F2014%2F11%2F25%2Fazure-website-always-on%2F</url>
    <content type="text"><![CDATA[當mvc website第一次讀取的速度都會很慢，這個原因是因為要做complie的動作， 那如何避免這個現象發生呢, 將azure website的規格升級到basic以上的規格並開啟alowasy on. 寫webjob(請參考這篇文章http://wp.sjkp.dk/windows-azure-websites-and-cloud-services-slow-on-first-request/) 利用http://www.thecloudup.com/, 幫你做第二點事情(免費)]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] 混亂的html5mode]]></title>
    <url>%2F2014%2F11%2F12%2Fangular-chaos-html5mode%2F</url>
    <content type="text"><![CDATA[Angular裡面有一個方法可以把# (hash tag) 給拿掉，那就是將html5mode開啟 123$locationProvider.html5Mode(true).hashPrefix(&apos;!&apos;)// 這應該會要求設定&lt;base href=&quot;/&quot;&gt; 但是如果angular route是架構在asp.net mvc上面，那就會有route打架的情形發生, 或著reload page會出現頁面錯誤的訊息 網路上面的資訊也有很多種版本，以下我也提供一下我的版本 主要重點, asp.net的routeConfig裡面也要同時間定義angular route的部份，但是controller/action是指到index page 1234routes.MapRoute(&quot;member_edit&quot;, &quot;member/edit/&#123;.Catchall&#125;&quot;, new &#123; controller = &quot;Home&quot;, action = &quot;Index&quot; &#125;, namespaces: new[] &#123; &quot;Demo.Areas.member.Controllers&quot; &#125;); 12345678910.state(&apos;main.edit&apos;, &#123; url: &apos;edit/:id&apos;, views: &#123; &apos;list@main&apos;: &#123; controller: &apos;editFavorController&apos;, controllerAs: &apos;vm&apos;, templateUrl: &apos;Home/EditFavor&apos; &#125; &#125; &#125;) 這樣子的設定, 可以讓其他頁面直接用網址的方式開啟那個頁面(請搜尋 deep link angualr) 當設定完成後，卻又發現另外一個問題，問題是, 我在選單連結的部份，有一些是要跑mvc本身的actionlink的動作, 但是angular會先處理 &lt; a &gt; 的動作，所以要跳過這個動作，可以利用 window.location.replace 來處理]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Javsscript] for loop VS forEach when there is async function]]></title>
    <url>%2F2014%2F11%2F11%2Fjavsscript-for-loop-vs-foreach-when-there-is-async-function%2F</url>
    <content type="text"><![CDATA[今天在檢查一段程式的時候，再跑一段根據array的資料新增或更新到資料庫中，卻發現都是更新同一筆紀錄 原本的寫法 123456for(var i=0; i &lt; arr.length; i++)&#123; db.insert(xxx).then(function()&#123; ... all insert the same record &#125;)&#125; 這是因為javascript async non-blocking的關係，所以資料庫新增自己跑自己的，for迴圈跑自己的，當新增時要取資料庫裡面資料時，會取到不對的值 解法：用array.forEach來替代for loop 12345arr.forEach(function(item,idx)&#123; db.insert(xxx).then(function()&#123; ... &#125;)&#125;); 當我改寫成這樣子後，就正常了]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] Azure Storage 2.0 – Some blob changes to be aware of -Ref]]></title>
    <url>%2F2014%2F11%2F06%2Fazure-ref-azure-storage-20-some-blob-changes-to-be-aware-of%2F</url>
    <content type="text"><![CDATA[Reference Website Url http://happyfunpartytime.com/2012/11/azure-storage-2-0-some-blob-changes-to-be-aware-of/ 大綱: 如果從官網上面抄下來的範例如果直接貼在vs裡面，會出現錯誤，那根據原本字面上的意思來找相類似的method來用 1CloudBlob thumbnailBlob = objContainer.GetBlobReference(filename); 換成 1var thumbnailBlob = objContainer.GetBlobReferenceFromServer(filename); 結果，一直給我跑404. 這GetBlobReserenceFromServer的用意是去server上面找filename的blob reference回來. 所以當我們要建立新的blob, 這就文不對題了。 所以要改用 1CloudBlockBlob blob = objContainer).GetBlockBlobReference(filename); 這樣子就okey了. 1blob.UploadFile(fileData.LocalFileName); 這個也改掉了, 要改成 1CloudBlockBlob.UploadFromFile(filenameWithPath, FileMode) CloudBlockBlob也有提供不同的上傳方式，請參閱MSDN]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] DocumentDB]]></title>
    <url>%2F2014%2F11%2F03%2Fazure-documentdb%2F</url>
    <content type="text"><![CDATA[使用Azure新的NoSQL – DocumentDB(還在preview版本中) 怎們建立網頁上面有說. 這裡只記錄一些操作上的動作 DocumentDB裡面有分幾個元素 Database, DocumentCollection, document 元素之間的關係 12345Database -&gt; DocumentCollection(with id name=xxxx) -&gt; document(s) -&gt; DocumentCollection(with id name=xxxx) -&gt; document(s)``` * 檢查database是否已存在 string dataBaseName = 「testDB」; var client = new DocumentClient(new Uri(EndpointUrl), AuthorizationKey); var database = client.CreateDatabaseQuery().FirstOrDefault(db =&gt; db.Id == dataBaseName); if (database == null) { database = await client.CreateDatabaseAsync( new Database { Id = dataBaseName }); } 1## 這個寫法如果用在webapi上面，會有出現等不到回應的情形發生，所以解決方法是變成同步, 寫法會變成 database = client.CreateDatabaseAsync(new Database{Id = dataBaseName}).Result; 12345678910111213* 檢查DocumentCollection是否已經建立從上面知道如果要檢查Database是否已經建立, 要利用CreateDatabaseQuery(), 同樣的， 如果要檢查Document是否已經建立, 就要用 CreateDocumentCollectionQuery(database.CollectionsLink)[MSDN -- DocumentServiceQueryable.CreateDatabaseQuery](http://msdn.microsoft.com/en-us/library/azure/microsoft.azure.documents.linq.documentservicequeryable.createdatabasequery.aspx)[MSDN -- DocumentServiceQueryable.CreateDocumentCollectionQuery Method](http://msdn.microsoft.com/en-us/library/azure/microsoft.azure.documents.linq.documentservicequeryable.createdocumentcollectionquery.aspx)* 建立Documentnew a class object and save into DocumentCollection User _user = new User(){name=『abc』}; var document1 = await client.CreateDocumentAsync(documentCollectionLink, _user); 這裡的documentCollectionLink是指 DocumentCollection collection = client.CreateDocumentCollectionQuery(database.SelfLink).FirstOrDefault(db =&gt; db.Id == dataBaseName); 或者是剛新增出來的collection DocumentCollection collection = client.CreateDocumentCollectionAsync(database.SelfLink, new DocumentCollection { Id = 「some name」 }); documentCollectionLink = collection.SelfLink; 12* 更新Document var doc = Client.CreateDocumentQuery(Favorscollection.DocumentsLink) .Where(d =&gt; d.Id == id) .AsEnumerable() .FirstOrDefault(); return Client.ReplaceDocumentAsync(doc.SelfLink, item); 12* 刪除Document var doc = Client.CreateDocumentQuery(Favorscollection.DocumentsLink) .Where(d =&gt; d.Id == id) .AsEnumerable() .FirstOrDefault(); return Client.DeleteDocumentAsync(doc.SelfLink); 123456* 查詢Document可以用Linq的語法來做查詢或是用sql的語法也可以[[DOC] Query DocumentDB](http://azure.microsoft.com/zh-tw/documentation/articles/documentdb-sql-query/) Client.CreateDocumentQuery(Favorscollection.DocumentsLink) .Where(m =&gt; m.lastName == 「xxxx」) .ToList()]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ngCordova] Move File]]></title>
    <url>%2F2014%2F10%2F16%2Fcordova-file%2F</url>
    <content type="text"><![CDATA[When move file in ngCordova or Cordova, it will need 2 plugins. cordova plugin add org.apache.cordova.file cordova plugin add org.apache.cordova.file-transfer basic usage. 1234567$cordovaFile.downloadFile(source, filepath, true, &#123;&#125;).then(function(result) &#123; // Success! &#125;, function(err) &#123; // Error &#125;, function(progress) &#123; // constant progress updates &#125;); it’s same as 12345678910var fileTransfer = new FileTransfer();var uri = encodeURI(source);fileTransfer.download(uri,filePath,function (entry) &#123;// success&#125;,function (error) &#123;// error&#125;,trustAllHosts, options); if you want to use it with $cordovaCamera.getPicture(), you will need to resolve FILE_URI first, and use it as source. 123456789function getImageFileName(image) &#123; window.resolveLocalFileSystemURL(image, function(entry) &#123; var uri = entry.toURL(); entry.file(function(file) &#123; var fileName = file.name; &#125;); &#125;); &#125; API Document#File Entry another problem is filepath. basePath can find it by below code. and filepath need a filename at the end. 123456$cordovaFile.createDir(directory, false).then(function(entry) &#123; // Success! alert(entry.toURL()); &#125;, function(err) &#123; // An error occured. Show a message to the user &#125;);]]></content>
      <categories>
        <category>Library</category>
      </categories>
      <tags>
        <tag>ngCordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Azure] SQL Azure 規格調整比較]]></title>
    <url>%2F2014%2F10%2F09%2Fazure-sql-azure-specs-adjusted%2F</url>
    <content type="text"><![CDATA[今天在將資料庫搬到Azure的環境上面，然後遇到了一個選擇的困擾. 原本SQL Azure的規格有兩種. Web和Business 新的規格有三種Basic, Standard, Premium. 相關的規格說明請參閱http://azure.microsoft.com/zh-tw/pricing/details/sql-database/ 所以我就先試試看Basic方案，結果：速度一個慢, 但是比Web規格便宜 （真的不建議使用，用這個不如用S0) Web的速度只有Premium 2可以跟的上, 價錢就是一個不可思議 那S0呢? 我嘗試後的結果是在可以接受的範圍內。但是價錢比Web貴了一點. 之後的規格，基本上就是價錢決定效能。 那我又想說如果自己用VM架設sql server呢…哈, 更貴. Orz. 直接放棄不考慮 最後只好還是繼續用要被淘汰的Web規格。然後抱著希望說等明年Web規格退休後，Azure可以提供更優價錢可以接受的選項。]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] 粗心的錯誤 Error: error:infdig]]></title>
    <url>%2F2014%2F10%2F09%2Fangular-careless-mistakes-errorerrorinfdig%2F</url>
    <content type="text"><![CDATA[angular在寫ng-repeat的時後, 因為想要利用 filter的功能將過濾後的資料集拿到不同區塊使用, 把function 寫到ng-repeat裡面。 像是 1ng-repeat=&quot;item in processData((items | filter: someCondition))&quot; 這一個粗心的錯誤會讓angular產生Error: error:infdig,Infinite $digest Loop的錯誤訊息 這個訊息的產生原因是當ng-repeat每跑一次, 會觸發processData fuction =&gt; 因為值改變，所以又會觸發$digest. 然後當$digest的次數太多之後，就會發生錯誤訊息, 執行效率也會變得非常的不好。 所以回到angularjs的頁面裡找到這個https://docs.angularjs.org/error/$rootScope/infdig 下面的說明就有提到這個現象. Since getUsers() returns a new array, Angular determines that the model is different on each $digest cycle, resulting in the error. The solution is to return the same array object if the elements have not changed: 解決的方式就是不要在ng-repeat裡面寫function. 但如果要達到相同的效果, 可以先將過濾後的結果存到一個變數中, 然後在去操作那個變數就不會產生這個錯誤了 1ng-repeat=&quot;item in (someVar = items | filter: someCondition)&quot;]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VS2013] Introducing Gulp, Grunt, Bower, and npm support for Visual Studio [REF]]]></title>
    <url>%2F2014%2F09%2F04%2Fvs2013-introducing-gulp-grunt-bower-and-npm-support-for-visual-studio-ref%2F</url>
    <content type="text"><![CDATA[文章參考: http://www.hanselman.com/blog/IntroducingGulpGruntBowerAndNpmSupportForVisualStudio.aspx 需要條件 VS2013 update 3 installed Visual Studio Extension [TRX - Task Runner Explorer](TRX - Task Runner Explorer) NPM/NBower Package Intellisense : Search for online NPM and Bower packages directly with Intellisense Grunt Launcher 操作方式: 請參考 http://www.hanselman.com/blog/IntroducingGulpGruntBowerAndNpmSupportForVisualStudio.aspx 好處: 不用再開一個command window 來跑grunt or gulp command, 所有的動作可以在VS裡面完成了 VS2013對於前端網頁的開發支援程度愈來越好了]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>VS2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC]OData PageResult v4]]></title>
    <url>%2F2014%2F07%2F31%2Faspnet-mvc-odata-pageresult-v4%2F</url>
    <content type="text"><![CDATA[12ODataHttpRequestMessageExtensions.GetNextPageLink 和 ODataHttpRequestMessageExtensions.GetInlineCount 都過時了.. 要改用 12Request.ODataProperties().NextLink,Request.ODataProperties().TotalCount ODataProperties 需要使用 System.Web.Http.OData.Extensions 或 System.Web.OData.Extensions 命名空間]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC]WebApi回傳值得表示]]></title>
    <url>%2F2014%2F07%2F31%2Faspnet-mvc-webapi-return-worth%2F</url>
    <content type="text"><![CDATA[asp.net mvc webapi 2 提供了 IHttpActionResult 這個界面 這個界面的效果基本上是跟HttpResponseMessage是一樣的 但是在回傳值的表示有些微的不一樣,以下是整理表 IHttpActionResult HttpResponseMessage Request.CreateResponse(HttpStatusCode) Ok() HttpStatusCode.OK InternalServerError() HttpStatusCode.InternalServerError NotFound() HttpStatusCode.NotFound more on http://msdn.microsoft.com/zh-tw/library/system.web.http.apicontroller_methods(v=vs.118).aspx 這樣子寫起來就乾淨很多了]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Web] Local Storage]]></title>
    <url>%2F2014%2F07%2F18%2Fweb-local-storage%2F</url>
    <content type="text"><![CDATA[javascript基本操作html5的 local storage方法 12345// set item valwindow.localstorage.setItem(key,value);window.localstorage.getItem(key);window.localstorage.removeItem(key);window.localstorage.clear(); 如果要把array object存入到localstorage裡面，需要把object轉換成文字.所以可透過json的方法來處理 12JSON.stringify(object);JSON.parse(value); ref: http://www.w3schools.com/html/html5_webstorage.asp http://blog.roodo.com/rocksaying/archives/15967715.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[參考] OData 101: Using the [NotMapped] attribute to exclude Enum properties]]></title>
    <url>%2F2014%2F07%2F08%2Freference-odata-101-using-the-notmapped-attribute-to-exclude-enum-properties%2F</url>
    <content type="text"><![CDATA[使用OData時如果遇到model裡面有自訂欄位是資料庫不存在時，就會出現錯誤 解決方案請參閱此篇文章 OData 101: Using the [NotMapped] attribute to exclude Enum properties]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF6] BulkInsert]]></title>
    <url>%2F2014%2F05%2F13%2Fef6-bulkinsert%2F</url>
    <content type="text"><![CDATA[處理狀況 當要同一時間新增大量資料時，如果單純用EF的新增方式，速度會讓人吐血。 所以需要透過BulkInsert的方式處理，但是又不想自己另外寫ado的方式處理，所以就要透過extenstion的方式， 讓EF的功能加強一下 ##安裝 EntityFramework.BulkInsert-ef6 Nuget ##參考文件 http://efbulkinsert.codeplex.com/ ##(用法)Demo Code 12345678using(context db = new context())&#123; // 原本會用 // db.tables.AddRange(entities); // 改用 db.BulkInsert(entities); db.SaveChanges();&#125; ##執行結果 非常快速]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>EF6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EF6] Entity Framework 6 Code First Migrations with Multiple Data Contexts (轉)]]></title>
    <url>%2F2014%2F05%2F05%2Fef6-entity-framework-6-code-first-migrations-with-multiple-data-contexts-change%2F</url>
    <content type="text"><![CDATA[Ref: http://www.dotnet-tricks.com/Tutorial/entityframework/2VOa140214-Entity-Framework-6-Code-First-Migrations-with-Multiple-Data-Contexts.html 如何動態產生Database 如果利用Code first的方式，搭配DbMigration即可完成工作 DBContext.cs 1234567891011public class DemoContext : DbContext &#123; public DemoContext() &#123; &#125; public DemoContext(string ConnectionString) : base(ConnectionString) &#123; Database.SetInitializer(new CustomInitializer()); Database.Initialize(true); &#125; public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125; &#125; CustomInitializer.cs 12345678910111213141516171819202122232425262728293031323334using System;using System.Data.Entity;using System.Data.Entity.Infrastructure;using System.Data.Entity.Migrations;using System.Data.Entity.Migrations.Infrastructure;using System.Linq;internal sealed class Configuration : DbMigrationsConfiguration&lt;DemoContext&gt;&#123; public Configuration() &#123; AutomaticMigrationsEnabled = true; MigrationsDirectory = @&quot;Migration&quot;; &#125; protected override void Seed(DemoContext context) &#123; &#125;&#125;class CustomInitializer : IDatabaseInitializer&lt;DemoContext&gt;&#123; public void InitializeDatabase(DemoContext context) &#123; if (!context.Database.Exists() || !context.Database.CompatibleWithModel(false)) &#123; var configuration = new Configuration(); configuration.TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, &quot;System.Data.SqlClient&quot;); var migrator = new DbMigrator(configuration); migrator.Update(); &#125; &#125;&#125; client端 12using (var db = new AtaBookContext(connection1))&#123;&#125;using (var db = new AtaBookContext(connection2))&#123;&#125; connection1和connection2分別指到不同的資料庫，EF就會根據連線字串的設定產生相對應的資料庫]]></content>
      <categories>
        <category>Entity Framework</category>
      </categories>
      <tags>
        <tag>EF6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC]HTMLHelper work with AngularJs]]></title>
    <url>%2F2014%2F05%2F01%2Faspnet-mvc-htmlhelper-work-with-angularjs%2F</url>
    <content type="text"><![CDATA[當要在htmlHelper裡面使用angularjs的屬性時, 原本的ng-model變成ng_model, 將 - 變成 _ 即可 例如: 123456@Html.DropDownList(&quot;dropdown&quot;, (IEnumerable&lt;SelectListItem&gt;)ViewBag.items, new &#123; ng_model = &quot;currentSelect&quot;, ng_change = &quot;selectChanges()&quot; &#125;)會產生&lt;select id=&quot;dropdown&quot; name=&quot;dropdown&quot; ng-change=&quot;selectChanges()&quot; ng-model=&quot;currentSelect&quot;&gt; &lt;options&gt;something&lt;/options&gt;*n&lt;/select&gt;]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#]Design Pattern for .NET Programmers]]></title>
    <url>%2F2014%2F04%2F29%2Fc-what-is-lambda-expressions-action-func-and-predicate%2F</url>
    <content type="text"><![CDATA[#NOTE: Youtube link: http://youtu.be/S8XL1L_1Lyw Abstract Factory 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; public static Object Create(string className, Dictionary&lt;String, Object&gt; values) &#123; Type type = Type.GetType(className); Object instance = Activator.CreateInstance(type); foreach (var entry in values) &#123; type.GetProperty(entry.Key).SetValue(instance, entry.Value, null); &#125; return instance; &#125; static void Main(string[] args) &#123; Console.WriteLine(Create(&quot;Patterns.Book&quot;, new Dictionary&lt;string, object&gt;() &#123; &#123;&quot;Title&quot;, &quot;Some titles&quot;&#125;, &#123;&quot;Pages&quot;, 100&#125; &#125;)); Console.WriteLine(Create(&quot;Patterns.CD&quot;, new Dictionary&lt;string, object&gt;() &#123; &#123;&quot;Title&quot;, &quot;Some CD&quot;&#125;, &#123;&quot;Volume&quot;, 12&#125; &#125;)); &#125; &#125; class Book &#123; public string Title &#123; get; set; &#125; public int Pages &#123; get; set; &#125; public override string ToString() &#123; return string.Format(&quot;Book &#123;0&#125; &#123;1&#125;&quot;, Title, Pages); &#125; &#125; class CD &#123; public string Title &#123; get; set; &#125; public int Volume &#123; get; set; &#125; public override string ToString() &#123; return string.Format(&quot;CD &#123;0&#125; &#123;1&#125;&quot;, Title, Volume); &#125; &#125;&#125; Cascade Pattern 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; static void Main(string[] args) &#123; // Sect I //Mailer mailer = new Mailer(); //mailer.from(&quot;abc@mail.com&quot;); //mailer.to(&quot;ddd@outlook.com&quot;); //mailer.subject(&quot;subjeccccttt&quot;); //mailer.message(&quot;contents blah blah&quot;); //mailer.send(); // Sect II- Cascade way new Mailer().from(&quot;abc@mail.com&quot;) .to(&quot;ddd@outlook.com&quot;) .subject(&quot;subjeccccttt&quot;) .message(&quot;contents blah blah&quot;) .send(); &#125; &#125; // Sect I //class Mailer //&#123; // public void to(string toAdrr) &#123; &#125; // public void from(string fromAddr) &#123; &#125; // public void subject(string sub)&#123;&#125; // public void message(string msg) &#123; &#125; // public void send() &#123; &#125; //&#125; // Sect II class Mailer &#123; public Mailer to(string toAdrr) &#123; return this; &#125; public Mailer from(string fromAddr) &#123; return this; &#125; public Mailer subject(string sub) &#123; return this; &#125; public Mailer message(string msg) &#123; return this; &#125; public void send() &#123; &#125; &#125; &#125; Pluggable Behavior 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; static int totalValues(int[] values) &#123; int total = 0; foreach (var value in values) &#123; total += value; &#125; return total; &#125; static int totalEvenValues(int[] values) &#123; int total = 0; foreach (var value in values) &#123; if (value % 2 == 0) total += value; &#125; return total; &#125; static int totalOddValues(int[] values) &#123; int total = 0; foreach (var value in values) &#123; if (value % 2 != 0) total += value; &#125; return total; &#125; static int totalSelectValues(int[] values, Func&lt;int, bool&gt; selector) &#123; int total = 0; foreach (var value in values) &#123; // pass value(first param) into function and return second param value if (selector(value)) total += value; &#125; return total; &#125; // static void Main(string[] args) &#123; int[] values = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; Console.WriteLine(totalValues(values)); Console.WriteLine(totalEvenValues(values)); Console.WriteLine(totalOddValues(values)); Console.WriteLine(&quot;==================&quot;); // re-write // define functioin in lambda format // ref: http://msdn.microsoft.com/zh-tw/library/bb397687(v=vs.110).aspx Console.WriteLine(totalSelectValues(values, (value) =&gt; true)); Console.WriteLine(totalSelectValues(values, (value) =&gt; value % 2 == 0)); Console.WriteLine(totalSelectValues(values, (value) =&gt; value % 2 != 0)); &#125; &#125;&#125; Execute Around Method Pattern part1 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; class Resource &#123; public Resource() &#123; Console.WriteLine(&quot;Creating...&quot;); &#125; public void op1() &#123; Console.WriteLine(&quot;op1...&quot;); &#125; public void op2() &#123; Console.WriteLine(&quot;op2...&quot;); &#125; ~Resource() &#123; Console.WriteLine(&quot;cleanup exensive resource&quot;); &#125; &#125; public static void Main(string[] args) &#123; &#123; Resource resource = new Resource(); resource.op1(); resource.op2(); &#125; Console.WriteLine(&quot;out of the block&quot;); &#125; &#125;&#125; 執行結果: part2 (with using()) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; class Resource : IDisposable &#123; public Resource() &#123; Console.WriteLine(&quot;Creating...&quot;); &#125; public void op1() &#123; Console.WriteLine(&quot;op1...&quot;); &#125; public void op2() &#123; Console.WriteLine(&quot;op2...&quot;); &#125; ~Resource() &#123; Clearnup(); &#125; public void Dispose() &#123; Clearnup(); GC.SuppressFinalize(this); &#125; private void Clearnup() &#123; Console.WriteLine(&quot;cleanup exensive resource&quot;); &#125; &#125; public static void Main(string[] args) &#123; // this require class that implement IDisposable using (Resource resource = new Resource()) &#123; resource.op1(); resource.op2(); &#125; Console.WriteLine(&quot;out of the block&quot;); &#125; &#125;&#125; 執行結果 part3 with Execute Around Method Pattern 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Patterns&#123; class Program &#123; class Resource &#123; //Call Resource class from here public static void Use(Action&lt;Resource&gt; block) &#123; Resource resouce = new Resource(); try &#123; block(resouce); &#125; finally &#123; resouce.Clearnup(); &#125; &#125; //change public to protected // can&apos;t new class in normal way : class _class = new class() protected Resource() &#123; Console.WriteLine(&quot;Creating...&quot;); &#125; public void op1() &#123; Console.WriteLine(&quot;op1...&quot;); &#125; public void op2() &#123; Console.WriteLine(&quot;op2...&quot;); &#125; private void Clearnup() &#123; Console.WriteLine(&quot;cleanup exensive resource&quot;); &#125; &#125; public static void Main(string[] args) &#123; &#123; Resource.Use( (resource) =&gt; &#123; resource.op1(); resource.op2(); &#125;); &#125; Console.WriteLine(&quot;out of the block&quot;); &#125; &#125;&#125; 執行結果]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Android Studio]platform not found]]></title>
    <url>%2F2014%2F04%2F07%2Fandroid-studio-platform-not-found%2F</url>
    <content type="text"><![CDATA[Ref from G+ Ater upgrading to AS 0.5.4 I am getting this error 「Failed to set up SDK Error:Module 『AndroinoTerm』: platform 『android-18』 not found」 while I already have android-18 installed. My sdk path is correctly setup and I am also able to run my project successfully. Does Anybody else having this issue ? Solution: 1. Change sdk folder location 2. update sdk path in android studio 3. change back to original location 4. update sdk path setting in android studio again 5. problem solved]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] 利用OData+EF做分頁]]></title>
    <url>%2F2014%2F03%2F19%2Fweb-use-odata-ef-page%2F</url>
    <content type="text"><![CDATA[當網頁要讀取一個很大量的資料時，通常都會透過分頁的方式來顯示資料。 如果透過WebApi+OData的特性來做分頁，作法很單純 設定 WebApiConfig.cs 12//加入config.EnableQuerySupport(); 假設原本的API寫法如下 12345[Route(&quot;api/Customer&quot;)]public IEnumerable&lt;customers&gt; Getcustomers()&#123; return db.customers.AsEnumerable();&#125; 改成 12345[Route(&quot;api/Customer&quot;)] public IQueryable&lt;customers&gt; Getcustomers()&#123; return db.customers.AsQueryable();&#125; 那在client端要呼叫api的url中，在加上OData的查詢語法來取得所要的資料區段，來達成分頁的效果 指令 說明 範例 top 結果挑出最前面的幾筆 ?$top=3 skip 略過幾筆。可用於分頁顯示 ?$skip=10 orderby 排序 ?$orderby=SupplierID,ProductID filter 篩選 gt : &gt; , 大於 $filter=ProductID gt 10 lt : &lt; , 小於 $filter=ProductID lt 10 ge : &gt;=, 大於等於 $filter=ProductID ge 10 le : &lt;=, 小於等於 $filter=ProductID le 10 eq : =, 等於 $filter=ProductID eq 10 ne : &lt;&gt;, 不等於 $filter=ProductID ne 10 參考資料: http://msdn.microsoft.com/en-us/library/windowsazure/gg312156.aspx 如果要利用OData取得所有的資料筆數時，上述的寫法沒有辦法做到，所以要稍微改寫一下原本的寫法 123456789[Route(&quot;api/Customer&quot;)] public PageResult&lt;customers&gt; Getcustomers(ODataQueryOptions&lt;customers&gt; options) &#123; var results = options.ApplyTo(db.customers.AsQueryable()); return new PageResult&lt;customers&gt;( results as IEnumerable&lt;customers&gt;, // Items Request.GetNextPageLink(), // NextPageLink Request.GetInlineCount()); // Count &#125; 要傳入的東西是一樣的，但是回傳的結果會變成 12345&#123; &quot;Items&quot;:[data....], &quot;NextPageLink&quot;: null, &quot;Count&quot;: 12345&#125; 所以在接收時要再調整 當$filter的查詢欄位是guid時 所送出的值前面要加上 guid 的關鍵字 1?$filter=field eq guid&apos;&lt;value&gt;&apos;]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS_Parallels_Win8_Mac.txt]]></title>
    <url>%2F2014%2F03%2F01%2Fiis-parallels-win8-mactxt%2F</url>
    <content type="text"><![CDATA[In your Windows 8 VM, go to Control Panel &gt; System &gt; Advanced system settings &gt; Computer Name and click Change. Name this whatever you like, e.g. 「windows」. Restart your VM. Open CMD or Powershell as administrator. Add a URL ACL entry for your new name on the port of your choice, e.g. netsh http add urlacl url=http://windows:8080/ user=everyone Open CMD or Powershell as administrator. Add an inbound firewall rule for this new port. In Windows 8, the syntax is: netsh advfirewall firewall add rule name=「IISExpressWeb」 dir=in action=allow protocol=TCP localport=8080 In Windows 7, the syntax is: netsh firewall add portopening TCP 8080 IISExpressWeb enable ALL Edit your IISExpress applicationhost.config file, typically found at your Documents\IISExpress\config\applicationhost.config. Find your site under sites, and add a binding to the port using your machine name, e.g. Startup IISExpress with Visual Studio, hit your URL from a browser on your Mac/VM Host, e.g. http://windows:8080 Revel in your magnificence. More info here: http://stackoverflow.com/questions/3313616/iis-express-enable-external-request http://stackoverflow.com/questions/5442551/iisexpress-returns-a-503-error-from-remote-machines http://www.hanselman.com/blog/WorkingWithSSLAtDevelopmentTimeIsEasierWithIISExpress.aspx Ref: https://gist.github.com/justingarrick/6322779]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#] work with xml and xsd]]></title>
    <url>%2F2014%2F02%2F27%2Fc-work-with-xml-and-xsd%2F</url>
    <content type="text"><![CDATA[1.在xsd裡描述minOccurs=&quot;0&quot;時 , 所建立的xml裡面要手動控制是否輸出value c#可以用class轉換成xml, 但是在class裡面的property並不是每一個都需要輸出，有些事非必要性的欄位。 這需要在property欄位另外加上一個欄位來做設定 12345678class demo&#123; public string field1; public string field2; public customEnum field3; // 以下這行是關鍵 [XmlIgnore] public bool field3Specified;&#125; 語法是 propertyNameSpecified [XmlIgnore] : 功用是在輸出xml時，忽略此欄位 依上列的案例來說，如果 field3Specified=true, 則輸出field3欄位, 如果設定成false, 則不輸出field3 2.使用xsd.exe將.xsd檔案轉換成class 在visual studio tools下-&gt; 命令視窗 -&gt; xsd ref: http://msdn.microsoft.com/en-us/library/x6c1kb0s(v=vs.110).aspx 將.xsd檔案轉換成class的方式為 1xsd file.xsd /c]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[工作筆記] 資本公積]]></title>
    <url>%2F2014%2F02%2F21%2Fnote-capital-surplus%2F</url>
    <content type="text"><![CDATA[資本公積 資本公積是指由股東投入、但不能構成股本或實收資本的資金部分，主要包括股本溢價、接受捐贈實物資產、投入資本匯兌損益、法定財產重估增值以及投資準備金等。 資本公積的來源，按其用途主要包括兩類： 一、超過票面金額發行股票所得之溢額。 以超過面額發行普通股或特別股溢價：無。 公司因企業合併而發行股票取得他公司股權或資產淨值所產生股本溢價：無。惟，合併基準日在97.12.31前案件，合併股本溢價來源屬消滅公司帳載未分配盈餘部分，如用以配發股票或現金給股東，仍屬股東股利所得。 庫藏股票交易溢價：有。 轉換公司債相關應付利息補償金於約定賣回期間屆滿日可換得普通股市價高於約定賣回價格時轉列金額：無。 因認股權證行使所得股本發行價格超過面額部分：無。 特別股或公司債轉換為普通股，原發行價格或帳面價值大於所轉換普通股面額差額：無。 附認股權公司債行使普通股認股權證分攤價值：無。 特別股收回價格低於發行價格差額：可能有。惟廣義而言，特別股的發行價格高於收回價格部分，也是股東的出資額，可否不視為股東有所得？ 認股權證逾期未行使而將其帳面餘額轉列者：有。 因股東逾期未繳足股款而沒收已繳股款：可能有。惟廣義而言，沒收股款也是股東的出資額，可否不視為股東有所得？ 公司因企業分割而發行股票取得他公司營業或資產淨值所產生股本溢價：無。 公司因股份轉換而發行股票取得他公司股份或股權所產生股本溢價：可能有。依財政部91.8.19台財稅第0910454466號涵意旨，股本溢價來源屬他公司轉換前帳載未分配餘者，如用以分配股票或現金給股東，屬股東股利所得，惟此函釋合理性，有待斟酌。 二、受領贈與之所得。 受領股東贈與本公司已發行股票：可能有。但廣義而言，此部分也是股東的出資額，可否不視為股東有所得？ 股東依股權比例放棄債權或依股權比例捐贈資產：可能無。 資本公積的主要用途有兩個， 轉增資本 彌補虧損。 盈餘公積(公司法:237條) 公司於完納一切稅捐後，分派盈餘時，應先提出百分之十為法定盈餘公積。但法定盈餘公積，已達資本總額時，不在此限。 除前項法定盈餘公積外，公司得以章程訂定或股東會議決，另提特別盈餘公積。 公司負責人違反第一項規定，不提法定盈餘公積時，各科新臺幣六萬元以下罰金。 惟依據銀行法第50條規定，銀行於完納一切稅捐後分派盈餘時，應先提30％為法定盈餘公積，另證券金融公司亦比照銀行提列30％法定盈餘公積，此為較特殊處。 種類 法定盈餘公積: 指依公司法或其他相關法令規定自盈餘中指撥之公積 特別盈餘公積: 因特定目的（如平衡盈餘分派、擴充改良設備或作為償債準備）依公司章程或股東會決議提存之公積。 用途 (公司法239條第1項暨232條第2項、241條第3項規定) 彌補虧損 分配(僅限法定盈餘公積) 為於公司無盈餘時，以法定盈餘公積超過實收資本額50％之部分派充股息及紅利 為法定盈餘公積已達實收資本50％者，得保留法定盈餘公積達實收資本50％之半數，其餘部分得以撥充資本，而股東依原有股份比例發給新股。 ###其他備註 補累積虧損之順序，宜先動用法定盈餘公積，次為特別盈餘公積，最後為資本公積。 特別盈餘公積得用於彌補虧損，惟於原提列特別盈餘公積之原因消除前，如曾以特別盈餘公積彌補虧損者，於未來有盈餘之年度，應先就特別盈餘公積不足數額補足提列，始得分派盈餘]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>會計</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] ng-repeat 結束時觸發其他動作]]></title>
    <url>%2F2014%2F02%2F20%2Fangular-at-the-end-of-ng-repeat-trigger-other-actions%2F</url>
    <content type="text"><![CDATA[如果想要知道ng-repeat什麼時候結束，可以透過$last的值知道最後的值是什麼，但是如果要觸發另外一個method…就…需要另外寫directive來處理這類的事情 參閱網路上的資料整理成以下的code 因為是用typescript寫的，如果要轉換，就自行在轉換吧 directive: 123456789101112directives.directive(&apos;onFinishRender&apos;, function ($timeout) &#123; return &#123; restrict: &apos;A&apos;, link: function (scope, element, attr) &#123; if (scope.$last === true) &#123; $timeout(function () &#123; scope.$emit(attr.onFinishRender); &#125;); &#125; &#125; &#125;&#125;); controller: 1234// 監控 attr.onFinishRender(傳進去的值)=&gt;這裡用scrollToEndthis.$scope.$on(&apos;scrollToEnd&apos;, () =&gt; &#123; // do whatever you want &#125;); html 123&lt;div ng-repeat=&quot;item in items&quot; on-finish-render=&quot;scrollToEnd&quot;&gt;blah blah balh&lt;/div&gt; 同場加映 忘了從那一版開始 ng-repeat有 ng-repeat-start and ng-repeat-end 用法是, 可以更漂亮的處理要repeat的樣板 123456789&lt;header ng-repeat-start=&quot;item in items&quot;&gt; Header &#123;&#123; item &#125;&#125;&lt;/header&gt;&lt;div class=&quot;body&quot;&gt; Body &#123;&#123; item &#125;&#125;&lt;/div&gt;&lt;footer ng-repeat-end&gt; Footer &#123;&#123; item &#125;&#125;&lt;/footer&gt; 可上官網上面參閱用法 http://code.angularjs.org/1.2.10/docs/api/ng.directive:ngRepeat]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C#] 編碼慣例]]></title>
    <url>%2F2014%2F02%2F19%2Fc-coding-conventions%2F</url>
    <content type="text"><![CDATA[節錄於MSDN 使用預設的程式碼編輯器設定 (智慧型縮排、四個字元縮排、將定位點儲存為空格)。 每行只撰寫一個陳述式。 每行只撰寫一個宣告。 如果連續行沒有自動縮排，則會將它們縮排一個定位停駐點 (四個空格)。 在方法定義與屬性定義之間加入至少一個空白行。 使用括號在運算式中撰寫子句，如下列程式碼所示。 1234if ((val1 &gt; val2) &amp;&amp; (val1 &gt; val3))&#123; // Take appropriate action.&#125; #註解慣例 將註解放到另一行，不放在程式碼行的結尾。 以大寫字母做為註解文字開頭。 以句號結束註解文字。 在註解分隔符號 (//) 與註解文字之間插入一個空格，如下列範例所示。 12// The following declaration creates a query. It does not run// the query. 不在註解周圍建立格式化的星號區塊。 #語言方針 當指派右邊的變數型別很明顯，或是不需要精確的型別時，使用隱含型別的區域變數。 指派右邊的型別不明顯時，不要使用 var。 不要倚賴變數名稱來指定變數的型別。 它可能是不正確的。 避免使用 var 取代 dynamic。 使用隱含型別判斷 for 和 foreach 迴圈中迴圈變數的型別。 進行比較時，若要略過不必要的比較以避免例外狀況並提升效能，請使用 &amp;&amp; 取代 &amp;，以及使用 || 取代 |。 使用簡潔的物件執行個體化形式搭配隱含型別，如以下宣告中所示。 使用物件初始設定式簡化物件建立。 12345var instance1 = new ExampleClass();// Object initializer.var instance3 = new ExampleClass &#123; Name = &quot;Desktop&quot;, ID = 37414, Location = &quot;Redmond&quot;, Age = 2.3 &#125;; #＃ LINQ查詢 使用有意義的名稱做為查詢變數的名稱。 下列範例會使用 seattleCustomers 代表位於西雅圖的客戶。 使用多個 from 子句，而不要使用 join 子句來存取內部集合。 例如，Student 物件集合中，每一個物件都可能包含考試分數集合。 執行下列查詢時，會傳回每一個高於 90 分的分數，以及得到該分數的學生名字。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VFP]Vartype()]]></title>
    <url>%2F2014%2F02%2F12%2Fvfp-vartype%2F</url>
    <content type="text"><![CDATA[Return value Data Type C Character, Memo, Varchar, Varchar (Binary) D Date G General L Logical N Numeric, Float, Double, or Integer O Object Q Blob,Varbinary T DateTime U Unknown or variable does not exist X Null Y Currency]]></content>
      <categories>
        <category>VFP</category>
      </categories>
      <tags>
        <tag>VFP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[WEB]Zen Coding style筆記]]></title>
    <url>%2F2014%2F01%2F31%2Fzen-coding-style-notes%2F</url>
    <content type="text"><![CDATA[符號 說明 # id屬性 . class屬性 [] 自訂屬性 &gt; 子元素 + 兄弟元素 ^ 升層 * 複製數量 $ 增量變數 $$ 增量變數(2位數) {} 文字節點]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS]AngularJs-20140129]]></title>
    <url>%2F2014%2F01%2F29%2Fnote-angularjs-20140129%2F</url>
    <content type="text"><![CDATA[$location Service (window.location) 用途: redirect action path() 使用者可以使用『上一頁』的功能 123$location.path(); // 取得目前的路徑$location.path(&apos;path&apos;);//改變路徑 replace() 使用者沒有辦法使用『上一頁』 123456$location.path(&apos;path&apos;);$locaton.replace(); // or $location.path(&apos;path&apos;).replace() absUrl() 取得完整的路徑 hash() 取得 # 之後的內容 search() get/set search part of the current URL url() get the URL of the current page]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[工作筆記] Linq筆記 - 取得最後一筆的聊天紀錄]]></title>
    <url>%2F2014%2F01%2F22%2Fnote-linq-notes%2F</url>
    <content type="text"><![CDATA[目的： 取得最後一筆的聊天紀錄 12345678910111213141516var result = (from o in db.messages let msgFrom = o.fromUid == uid let msgTo = o.toUid == uid where msgFrom || msgTo group o by msgTo ? o.fromUid : o.toUid into grp let lastDate = grp.Max(m =&gt; m.createDate) from p in grp where p.createDate == lastDate select new viewMessage &#123; uid = p.fromUid == uid ? p.toUid : p.fromUid, name = p.fromUid == uid ? p.toemployees.name : p.fromemployees.name, msg = p.msg, lastdate = p.createDate, unread = p.unread &#125;).AsEnumerable();]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Phalcon] Complie Phalcon.so for php 5.4.2]]></title>
    <url>%2F2013%2F12%2F07%2Fphalcon-complie-phalconso-for-php-542%2F</url>
    <content type="text"><![CDATA[緣由：Bluhost決定將所有的php版本升級到5.4.20, 那這樣子的行為會讓phalcon.so（php 5.3.27版本) 失效，然後問Bluehost, 他們不會提供降級的服務，也不會幫忙complie phalcon.so…所以，自己做。 作法：設定一個跟網頁空間一樣的環境, same os and php version, 然後在編譯phalcon, 成功編譯後上傳phalcon.so到主機上面。 步驟： 我是選擇centos6版，下載與主機服務商一樣作業位元的作業系統. (64bit or 32bit) http://isoredirect.centos.org/centos/6/isos/x86_64/ &lt;= 64位元的版本 用Vmware將centos裝起來. 安裝完成後，用root的帳號登入，開啟terminal window 由於第一次安裝，所以先執行 update``` 讓系統先將所有的套件更新到最新的狀態1235. ```yum groupinstall &quot;Development Tools&quot;``` 安裝一些跟開發有關係的元件，例如 git (必須安裝)6. 安裝rpm yum repository information, 因為php5.4是在不同的repository. 安裝方式如下 ```rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm 可以用 list | grep php``` 顯示跟php有關的套件。php54w就是我們要安裝的套件18. 要安裝以下套件 ```yum install php54w php54w-mysql php54w-devel 利用git取得phalcon clone --depth110. ```cd cphalcon/build ./install 如果complie成功, 會出現下面的畫面 complie完後的檔案可以在build/modules/紅色框起來的資料夾下面看到 將phalcon.so複製到網頁空間主機php放extensions的資料夾下，並編輯php.ini啟動phalcon.so 打完收工]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>Phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[python] small script -- 讀電子報，擷取文章，轉錄]]></title>
    <url>%2F2013%2F11%2F29%2Fpythonsmall-script-read-electronic-newspapers-ripping-the-article-transcription%2F</url>
    <content type="text"><![CDATA[#流程 從gmail裡面讀取電子報(特定的寄件者) 取得郵件內容 分析html 取得所要的部份(s) 將要轉錄的文章發布到wordpress上 將已處理的信件從收件夾中移到另一個資料夾中 結束作業 #開發環境 python 3.3 #有用到的package imaplib --&gt; 用來處理imap type email email --&gt; email結構 re BeautifulSoup4 --&gt; work with python 3.3 --&gt; from bs4 import BeautifulSoup wordpress_xmlrpc --&gt; 透過xmlrpc的方式新增文章 所遇到的問題 編碼 a. 信件 b. 信件內容 html形式的email裡面藏有\xa0 , 還是因為編碼的關係 其實在使用bs4的過程中，也是花最多時間的地方是如何讓中文正常的顯示出來。其實在第一段要取得信件裡的內容時，就遇到中文編碼的問題。 demo code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import imaplib,email,refrom email.header import decode_headerfrom bs4 import BeautifulSoupfrom wordpress_xmlrpc import Client,WordPressPost,WordPressPost,WordPressTermfrom wordpress_xmlrpc.methods import postsfrom wordpress_xmlrpc.methods.posts import NewPost,EditPostfrom wordpress_xmlrpc.methods.users import GetUserInfo# 這樣子可以傳回中文字def decode_subject(subject,encoding): if encoding == None: return subject else: return subject.decode(encoding) # 用意跟上面的一樣, 只是為了處理編碼的問題def showmessage(mail): if mail.is_multipart(): for part in mail.get_payload(): showmessage(part) else: type = mail.get_content_charset() if type == None: return mail.get_payload() else: try: return mail.get_payload(decode=1).decode(type) except UnicodeDecodeError: return mail conn = imaplib.IMAP4_SSL(&quot;imap.gmail.com&quot;, 993)conn.login(&apos;account&apos;,&apos;password)conn.select(&quot;inbox&quot;) # connect to inbox.typ, data = conn.search(None, &apos;ALL&apos;)try: for num in data[0].split()[-1:]: #從最新的信件開始讀起 typ, msg_data = conn.fetch(num, &apos;(RFC822)&apos;) for response_part in msg_data: if isinstance(response_part, tuple): msg = email.message_from_string(response_part[1].decode()) subject,encoding = decode_header(msg[&apos;subject&apos;])[0] mailsubject = decode_subject(subject,encoding) #_from = msg[&apos;from&apos;] body = showmessage(msg) # 編碼轉換 # 分析並將轉錄到wordpress上 for link in soup.find_all(&quot;table&quot;)[8:]:#start with 8th table element content = link.encode(&apos;big5&apos;).decode(&apos;cp950&apos;) if content.find(&apos;class=&quot;contentword&quot;&apos;) &gt; -1: news = BeautifulSoup(content) for part in news.find_all(&apos;tr&apos;): td = part.find_all(&quot;td&quot;) title = td[0].get_text() puretext = re.sub(&apos;(\xa0)+&apos;,&apos; &apos;,td[1].get_text()) if title == &apos;公布日期&apos;: publishdate = puretext elif title==&apos;標題&apos;: posttitle = puretext elif title==&apos;詳細內容&apos;: postcontent = puretext postToWP.post(posttitle,postcontent,&quot;post tag&quot;) move_mail(conn,num,&apos;Archive.Today&apos;)finally: try: conn.close() except: pass conn.logout() 在3.3裡, email.message_from_string 傳進去的文字如果不加decode，會傳錯誤訊息出來。 1email.message_from_string(response_part[1].decode()) 發布文章到wordpress 參考網址: http://python-wordpress-xmlrpc.readthedocs.org/en/latest/index.html class postToWP: def post(title,content,tag): client = Client('http://blog url//xmlrpc.php', 'username', 'password') post = WordPressPost() post.title = title post.content = content post.terms_names = { 'post_tag': [tag], # 標籤(Tag) 'category': [tag], # 分類(Categories) } post.post_status = 'publish' # 如果沒有這一個，就會是草稿狀態 post.id = client.call(NewPost(post))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] Play with Grunt (typescript ...)]]></title>
    <url>%2F2013%2F11%2F27%2Faspnet-mvc-play-with-grunt%2F</url>
    <content type="text"><![CDATA[#Grunt Need: Node.js installed Install Steps Installing the CLI run command 1npm install -g grunt-cli edit package.json and Gruntfile.js 123456&#123; &quot;devDependencies&quot;: &#123; &quot;grunt&quot; : &quot;0.4.1&quot;, &quot;grunt-ts&quot; : &quot;latest&quot; &#125;&#125; run npm install in command 1234567891011121314151617181920module.exports = function (grunt) &#123; // load the task grunt.loadNpmTasks(&quot;grunt-ts&quot;); // Configure grunt here grunt.initConfig(&#123; ts: &#123; dev: &#123; // a particular target src: [&quot;app/**/*.ts&quot;], // The source typescript files, http://gruntjs.com/configuring-tasks#files html: [&quot;app/**/*.html&quot;], // The source html files, https://github.com/basarat/grunt-ts#html-2-typescript-support reference: &quot;./reference.ts&quot;, // If specified, generate this file that you can use for your reference management out: &apos;app/app.js&apos;, // If specified, generate an out.js file which is the merged js file watch: &apos;app&apos; &#125; &#125; &#125;); grunt.registerTask(&quot;default&quot;, [&quot;ts:dev&quot;]);&#125; run grunt in command 這樣子grunt就會監控 在app資料夾下的ts檔案異動，並同時做complie的動作，如果有錯誤，會產生complie error的訊息。]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] ADD TYPESCRIPT Complier]]></title>
    <url>%2F2013%2F11%2F27%2Faspnet-mvc-add-typescript-complier%2F</url>
    <content type="text"><![CDATA[In projectname.csproj 新增 &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'Debug'&quot;&gt; &lt;TypeScriptTarget&gt;ES3&lt;/TypeScriptTarget&gt; &lt;TypeScriptIncludeComments&gt;true&lt;/TypeScriptIncludeComments&gt; &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt; &lt;TypeScriptModuleKind&gt;AMD&lt;/TypeScriptModuleKind&gt; &lt;/PropertyGroup&gt; &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'Release'&quot;&gt; &lt;TypeScriptTarget&gt;ES3&lt;/TypeScriptTarget&gt; &lt;TypeScriptIncludeComments&gt;false&lt;/TypeScriptIncludeComments&gt; &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt; &lt;TypeScriptModuleKind&gt;AMD&lt;/TypeScriptModuleKind&gt; &lt;/PropertyGroup&gt; &lt;Import Project=&quot;$(VSToolsPath)\TypeScript\Microsoft.TypeScript.targets&quot; /&gt; 在重新載入專案]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AngularJS] Validation]]></title>
    <url>%2F2013%2F11%2F25%2Fangularjs-validation%2F</url>
    <content type="text"><![CDATA[#Form Validation with angularJs Basic: in .js $scope.form = {} $scope.form.$valid ==&gt; 判斷form(name=「form」)內的物件是否有驗證有錯誤的物件存在 用法: formName.inputFieldName.property Unmodified form A boolean property that tells us if the user has modified the form. This is true if the user hasn’t touched the form, and false if they have: 1formName.inputFieldName.$pristine; Modified form A boolean property if and only if the user has actually modified the form. This is set regardless of validations on the form: 1formName.inputFieldName.$dirty Valid form A boolean property that tells us that the form is valid or not. If the form is currently valid, then this will be true: 1formName.inputFieldName.$valid Invalid form A boolean property that tells us that the form is invalid. If the form is currently invalid, then this will be true: 1formName.inputFieldName.$invalid The last two properties are particularly useful for showing or hiding DOM elements. They are also very useful when setting a class on a particular form. Errors Another useful property that AngularJS makes available to us is the $error object. This object contains all of the validations on a particular form and if they are valid or invalid. To get access to this property, use the following syntax: 1formName.inputfieldName.$error ###Addtional CSS classes ng-valid Is set if the form is valid. ng-invalid Is set if the form is invalid. ng-pristine Is set if the form is pristine. ng-dirty Is set if the form is dirty. ##Input Validation 12345678910&lt;input ng-model=&quot;&#123;string&#125;&quot; [name=&quot;&#123;string&#125;&quot;] [required] [ng-required=&quot;&#123;boolean&#125;&quot;] [ng-minlength=&quot;&#123;number&#125;&quot;] [ng-maxlength=&quot;&#123;number&#125;&quot;] [ng-pattern=&quot;&#123;string&#125;&quot;] [ng-change=&quot;&#123;string&#125;&quot;]&gt;&lt;/input&gt; ####可驗證項目(內建) requried ng-minlength ng-maxlength ####$error所對應的項目 formName.inputfieldName.$error.requried formName.inputfieldName.$error.minlength formName.inputfieldName.$error.maxlength]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[工作筆記]網際網路電子發票開立流程]]></title>
    <url>%2F2013%2F11%2F15%2Felectronic-invoices-via-the-internet-opening-process%2F</url>
    <content type="text"><![CDATA[民國103年1月1日起，網際網路電子發票開始限制發票字軌只能使用丁種字軌，然後又推說如果利用網際網路電子發票開立B2B交易情形，只能接受丁種字軌，這表示，另外一方也必須用網際網路電子發票…看來國稅局在103年度要強推B2B的電子發票了。 不管怎樣，這個也是一個趨勢，雖然現在開立的方法或是平台（還得獎…這好笑了吧, 請個F2E處理一下你的頁面吧。還是說設計者都沒有自己操作過)都還很鳥，如果要利用媒體檔上傳的方式，這個門檻又很高，因為那個該死的規格書又寫的很艱澀。（只是要罵一下)… 帳號申請網址：電子發票整合服務平台 還是稍微整理一下開立流程： 一般開立 賣方開立發票 買方收到開立通知 買方接收開立發票 賣方收到接收通知 完成開立動作 退回發票 賣方開立發票 買方收到通知 買方退回發票 賣方確認發票退回 完成動作 作廢發要 賣方作廢發票 買方收到通知 買方確認發票作廢 完成動作 B2B交換資料，發票狀態有幾種，其意義為何？ 銷項發票狀態 開立 ：已新增發票，尚未憑證寄送 已寄送：已憑證寄送，資料傳送中 已讀取：買方已讀取 尚未完成進項發票寄送確認 已確認：買方已完成進項發票寄送確認 進項發票狀態 開立 ：賣方已憑證寄送發票，買方尚未讀取 已讀取 ：買方已讀取發票，尚未完成進項發票寄送確認 確認寄送中：進項發票寄送確認，資料傳送中 已確認 ：買方已完成進項發票寄送確認 買方營業人若無工商憑證是否可接收發票？ 請賣方營業人至基本資料／交易對象資料維護建立買方資料並設定交易暗語，買方即可以交易暗語寄送發票。 惟作廢發票及發票退回確認僅能使用憑證接收，不得使用交易暗語接收。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>電子發票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[python] 20131114]]></title>
    <url>%2F2013%2F11%2F14%2Fpython-20131114%2F</url>
    <content type="text"><![CDATA[Tuples 很像list,但是一旦建立後值就沒有辦法被更改 (ex. list[1]= 『b』 &lt;=會出錯) 用途: 用來儲存一些常用(const)變數 Set set會將重複得值給排除掉(有distinct的味道) 建立set的方式有set() 或 a= {『something』,『something』} 如果要建立空的set，只能透過set()的方式 1234567891011121314&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)&gt;&gt;&gt; b = set(&apos;alacazam&apos;)&gt;&gt;&gt; a&#123;&apos;d&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;&#125;&gt;&gt;&gt; b&#123;&apos;m&apos;, &apos;l&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;&#125;&gt;&gt;&gt; a^b # value in a or b not in both, 不含兩邊都有值&#123;&apos;r&apos;, &apos;z&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;l&apos;&#125;&gt;&gt;&gt; a-b # value in a not b&#123;&apos;d&apos;, &apos;b&apos;, &apos;r&apos;&#125;&gt;&gt;&gt; a|b # value in a or b&#123;&apos;r&apos;, &apos;z&apos;, &apos;d&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;m&apos;, &apos;l&apos;&#125;&gt;&gt;&gt; a&amp;b # value in a and b&#123;&apos;a&apos;, &apos;c&apos;&#125; #Dictionaries as c# Dictionary&lt;string, string&gt; 操作方式 指定: dict[key]= value 刪除: del dict[key] 列表: list(dict.key()) 排序: sorted(dict.key()) 建立的方式 1234&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)])&#123;&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127&#125;&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)&#123;&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127&#125; ##looping 123456&gt;&gt;&gt; knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;&gt;&gt;&gt; for k, v in knights.items():... print(k, v)...gallahad the purerobin the brave #More on Conditions 比較的方法: in, not in is, is not and, or : 當遇到第一個成立條件時，就跳出了 比較可以連續串接: eg: a&lt;b==c tests whether a is thess then b and moreover b equals c 比較的順序: 左到右]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[python]20131113]]></title>
    <url>%2F2013%2F11%2F13%2Fpython20131113%2F</url>
    <content type="text"><![CDATA[#Data Structures List的控制 x=value i=index position L=list list.append(x) : 在結尾的地方新增一筆資料 list.extend(L) : 新增資料by list list.insert(i,x) : 插入資料 list.remove(x) : 移除所輸入的x值 list.pop([i]) : 移除所指定index position的值;如果沒有指定[i]時，則傳回並移除最後一筆紀錄(後進先出) list.clear() : 清除list list.index(x) : x值的位置, 如果沒有找到則傳回錯誤 list.count(x) : x值的數量 list.sort() : 排序 list.reverse() : 反轉 list.copy() : 複製list 後進先出 : list.pop() 先進先出 : deque deque([list])後，在操作pop或append時，多出了popleft(), appendleft(), extendleft()的方法 用法如下 123456789101112&gt;&gt;&gt;from collections import deque&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])&gt;&gt;&gt; queuedeque([&apos;Eric&apos;, &apos;John&apos;, &apos;Michael&apos;])&gt;&gt;&gt; queue.append(&quot;Kevin&quot;)deque([&apos;Eric&apos;, &apos;John&apos;, &apos;Michael&apos;, &apos;Kevin&apos;])&gt;&gt;&gt; queue.appendleft(&quot;Steve&quot;)deque([&apos;Steve&apos;, &apos;Eric&apos;, &apos;John&apos;, &apos;Michael&apos;, &apos;Kevin&apos;])&gt;&gt;&gt; queue.popleft()&apos;Steve&apos;&gt;&gt;&gt; queuedeque([&apos;Eric&apos;, &apos;John&apos;, &apos;Michael&apos;, &apos;Kevin&apos;]) #List Comprehensions ##(計算x) for x in list if condition 1234567891011121314151617181920&gt;&gt;&gt; [x**2 for x in range(10)][0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; [x**2 for x in range(10) if x%2==0][0, 4, 16, 36, 64]&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]&gt;&gt;&gt; matrix = [... [1, 2, 3, 4],... [5, 6, 7, 8],... [9, 10, 11, 12],... ]&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]&gt;&gt;&gt; list(zip(*matrix))[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)] #del 移除list中的值by Index 12345678910&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[] del can also be used to delete entire variables: 變數消滅 123456&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;a&apos; is not defined]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[python] 20131112]]></title>
    <url>%2F2013%2F11%2F12%2Fpython-20131112%2F</url>
    <content type="text"><![CDATA[#demo program 123456a,b=0,1 # 指定值至變數中while b&lt;10: # 迴圈... print(b, end=&apos;,&apos;) # 顯示文字，結尾加上,... a,b=b,a+b # 指定值至變數中1,1,2,3,5,8, # 輸出結果 #Control Flow Tools if 123456if x&lt;0: something somethingelif condition: something somethingelse: something something for 1234567words=[&apos;cat&apos;,&apos;window&apos;,&apos;defenestrate&apos;]for w in words: print(w,len(w))cat 3window 6defenestrate 12 123456&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w) # 將值插入至list中...&gt;&gt;&gt; words[&apos;defenestrate&apos;, &apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;] range() range()主要的目的是要創造一個連續值的list, 例如 range(10)=[0,1,2,3,4,5,6,8,9] 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt; for i in range(5): # range(5) = range(0,5)... print(i)... 01234&gt;&gt;&gt; for i in range(5,9):... print(i)... 5678&gt;&gt;&gt; for i in range(0,10,2): # = for(i=0;i&lt;10;i=i+2) step 2... print(i)... 02468# 使用在文字陣列上&gt;&gt;&gt; a = [&apos;Mary&apos;, &apos;had&apos;, &apos;a&apos;, &apos;little&apos;, &apos;lamb&apos;]&gt;&gt;&gt; for i in range(len(a)):... print(i,a[i])... 0 Mary1 had2 a3 little4 lamb break, continue, else in Loops 1234567for n in range(2,10): for x in range(2,n): if n%x ==0: print(n, &apos;equals&apos;, x, &apos;*&apos;, n//x) break else: print(n, &apos;is a prime number&apos;) else: 是對應到 for x in range(2,n): 意義: a try statement’s else clause runs when no exception occurs #python coding style Use 4-space indentation, and no tabs. 4 spaces are a good compromise between small indentation (allows greater nesting depth) and large indentation (easier to read). Tabs introduce confusion, and are best left out. Wrap lines so that they don’t exceed 79 characters. This helps users with small displays and makes it possible to have several code files side-by-side on larger displays. Use blank lines to separate functions and classes, and larger blocks of code inside functions. When possible, put comments on a line of their own. Use docstrings. &quot;&quot;&quot; something something something 「」&quot; 可以被呼叫by function.doc Use spaces around operators and after commas, but not directly inside bracketing constructs: a = f(1, 2) + g(3, 4). Name your classes and functions consistently; the convention is to use CamelCase for classes and lower_case_with_underscores for functions and methods. Always use self as the name for the first method argument (see A First Look at Classes for more on classes and methods). Don’t use fancy encodings if your code is meant to be used in international environments. Python’s default, UTF-8, or even plain ASCII work best in any case. Likewise, don’t use non-ASCII characters in identifiers if there is only the slightest chance people speaking a different language will read or maintain the code.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[python]筆記1]]></title>
    <url>%2F2013%2F11%2F11%2Fpython-note-1%2F</url>
    <content type="text"><![CDATA[#String string可以用 『』 or 「」 在 '『裡面可以用&quot;, 在&quot;&quot; 裡面可以用』 string連結的方式 + or 空白 但是如果是要連結變數和文字，則需要使用 +。數字和文字不可以做連接。 string[x] 可以直接將文字轉成陣列, 然後直接讀取 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0] # character in position 0'P'&gt;&gt;&gt; word[5] # character in position 5'n'&gt;&gt;&gt; word[-1] # last character'n'&gt;&gt;&gt; word[-2] # second-last character'o'&gt;&gt;&gt; word[-6]'P'&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho'&gt;&gt;&gt; word[:2] + word[2:]'Python'&gt;&gt;&gt; word[:4] + word[4:]'Python'&gt;&gt;&gt; word[:2] # character from the beginning to position 2 (excluded)'Py'&gt;&gt;&gt; word[4:] # characters from position 4 (included) to the end'on'&gt;&gt;&gt; word[-2:] # characters from the second-last (included) to the end'on'&gt;&gt;&gt; word[::-1] # reverse a string'nohtyp'&gt;&gt;&gt; len(word) # length of a string6+---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 6-6 -5 -4 -3 -2 -1 輸出文字: v2.7 : print 『xxxxx』 v3.3 : print(『xxxx』) 文字重複顯示 12&gt;&gt;&gt; &apos;something&apos;*3&apos;somethingsomethingsomething&apos; #Number 計算方式: 先乘除後加減，有內算到外，有左到右 number分interger and float, 區分方法是有沒有使用小數點 + - * : 加，減，乘 除有兩個方法: / : 傳回 float //: 傳回 integer % : 傳回餘數 ** : 次方 12345678&gt;&gt;&gt; 7/41.75&gt;&gt;&gt; 7//41&gt;&gt;&gt; 7%43&gt;&gt;&gt; 2**101024 a = b: 將b值指定給a 在interactive mode，可以利用 _ 取得上次的值 1234&gt;&gt;&gt; 1+23&gt;&gt;&gt; 1+_4 Lists 1234567&gt;&gt;&gt; squares = [1, 2, 4, 9, 16, 25]&gt;&gt;&gt; squares[1, 2, 4, 9, 16, 25]&gt;&gt;&gt; squares[1]2&gt;&gt;&gt; squares[-1]25 基本操作可以參考string的部分，一樣可以使用 + 做lists的連結 1list.append(value) # add value to the list 二維陣列 123456789&gt;&gt;&gt; a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; n = [1, 2, 3]&gt;&gt;&gt; x = [a, n]&gt;&gt;&gt; x[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]]&gt;&gt;&gt; x[0][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; x[0][1]&apos;b&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python] Start Study Python - 序]]></title>
    <url>%2F2013%2F11%2F10%2Fpython-start-study-python%2F</url>
    <content type="text"><![CDATA[因為Visual Studio 2013可以用來寫python, 所以決定開始來學習python看看。看這個語言能帶給我怎樣的驚喜]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ASP.NET MVC] ASP.NET MVC 開啟加速]]></title>
    <url>%2F2013%2F11%2F01%2Faspnet-mvc-aspnet-mvc-open-to-accelerate%2F</url>
    <content type="text"><![CDATA[ASP.NET MVC有一個特性，就是如果第一次使用的時候，會經歷iis需要complie的窘境。 因為上述的關係，所以有需要從寫法和設定上面做調整。 可參閱 http://stackoverflow.com/questions/2246251/how-to-improve-asp-net-mvc-application-performance http://www.slideshare.net/rudib/aspnet-mvc-performance]]></content>
      <categories>
        <category>ASP.NET MVC</category>
      </categories>
      <tags>
        <tag>MVC 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HTML5] Blob]]></title>
    <url>%2F2013%2F10%2F26%2Fhtml5-blob%2F</url>
    <content type="text"><![CDATA[#BEFORE 12345678910111213window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;window.URL = window.URL || window.webkitURL;var bb = new BlobBuilder();bb.append(&apos;body &#123; color: red; &#125;&apos;);var blob = bb.getBlob(&apos;text/css&apos;);var link = document.createElement(&apos;link&apos;);link.rel = &apos;stylesheet&apos;;link.href = window.URL.createObjectURL(blob);document.body.appendChild(link); #NOW 12345678window.URL = window.URL || window.webkitURL;var blob = new Blob([&apos;body &#123; color: red; &#125;&apos;], &#123;type: &apos;text/css&apos;&#125;);var link = document.createElement(&apos;link&apos;);link.rel = &apos;stylesheet&apos;;link.href = window.URL.createObjectURL(blob);document.body.appendChild(link); #SO Just New Blob()…no more BlobBuilder()]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Blade template]]></title>
    <url>%2F2013%2F10%2F26%2Flaravel-blade-template%2F</url>
    <content type="text"><![CDATA[two ways to use it #1 use blade on controller in controller, you need to assign a template for controller. 1protected $layout = 'layouts.master'; and then in each function action. assign whatever need to assign for show content on template. like in blade template. I have a content section. Therefore, i need to set a value or view to 「Content」 1$this-&gt;layout-&gt;content = something or View::make('something'); in blade template. there are 2 ways to define var. @yield(『something』) if use first method; then in view, it needs to create a section something. ex 123@section(&apos;content&apos;)xxxx@endsction for method 2. no need to create a section to contain page content.]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[VFP]Prog Cache]]></title>
    <url>%2F2013%2F10%2F21%2Fvfp-prog-cache%2F</url>
    <content type="text"><![CDATA[From the VFP9 helpfile: Specifies the amount of memory (address space) in pages that Visual FoxPro allocates at startup or a Visual FoxPro MTDLL COM Server allocates per thread for the internal program cache (memory used to run programs). Each page of memory is equal to 64K so the default setting equates to an allocation a little over 9MB. As the cache is filled, Visual FoxPro will try to flush it to remove unused items. It is possible that Visual FoxPro cannot free enough memory in which case an Error 1202 is generated (Program is too large). Adjusting the PROGCACHE setting can prevent this error from occurring. Note: While this setting can be used for the Visual FoxPro development product or normal runtime applications, it is primarily intended for MTDLL COM Servers where many threads are often created for a single server. In Visual FoxPro 9.0, the default value for MTDLL COM Servers is -2. When the value of nMemoryPages is greater than 0, Visual FoxPro allocates a fixed program cache. You can specify between 1 and 65000. If you specify 0 for nMemoryPages, no program cache is used. Instead, Visual FoxPro uses dynamic memory allocation based on determinations made by the operating system. If you pass a value for nMemoryPages that is less than 0, Visual FoxPro uses dynamic memory allocation but is limited to the specified memory (nMemoryPages * 64K). When the limit is reach, Visual FoxPro will flush allocated programs to free memory. You can call SYS(3065) to determine the current PROGCACHE setting. CLEAR PROGRAM will attempt to clear unreferenced code regardless of this setting. Note: The Visual FoxPro OLE DB Provider ignores this setting since it uses dynamic memory allocation (PROGCACHE=0). Default: 144 (-2 for MTDLL) 「The setting is the number of pages of memory you want allocated. Each page is equivalent to 64K of memory. You can set the PROGCACHE from 1 to 65,000 (positive or negative) to designate how much memory is allocated. If you specify zero, no program cache is used and VFP uses dynamic memory allocation determined by the operating system. If you set the PROGCACHE to a negative number, VFP uses dynamic memory allocation, but is limited to the number of memory pages you specified. The default setting is 144 (over 9 megabytes) for single-threaded EXEs and the VFP IDE, and -2 (128 kilobytes) for a multi-threaded DLL. The VFP OLE DB Provider does not use this setting because it uses dynamic memory allocation.」 Ref: http://fox.wikis.com/wc.dll?Wiki~ProgCache]]></content>
      <categories>
        <category>VFP</category>
      </categories>
      <tags>
        <tag>VFP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Controllers]]></title>
    <url>%2F2013%2F10%2F17%2Flaravel-controllers%2F</url>
    <content type="text"><![CDATA[Controller Controllers是用來處理商業邏輯及資料與view之間的介面(負責將資料input//output 給model，與資料庫的溝通就交給model去處理了) controller需要配合route的設定才可被view呼叫使用。 例如: route::get(『something』,『someController@someaction』) 當使用者跑到 http://website/something時, 就會呼叫route內所對應的controller及action. 發現，這種指定的方式，當頁面很多的時候就會變得很麻煩。 所以laravel的route提供另外一種指定的方式 route::controller(『something』,『someController』) 此種設定的方式，適用於restFUL的controller, (get,post,put,delete)四種交換模式的相關動作。 一般而言，只是讀取一個頁面的時候，都是透過 get的method取得回應的。所以在controller內action的命名， 就是用getSomection()為命名的方式，網址就是http://website/something/someaction (小寫, Controller內的action name 是大寫). 如果action的名稱是SomeAction時，注意 是兩個大寫字母 網址就會變成 http://website/something/some-action (破折號作為連結的符號) 同理: 如果遇到form post時, 就是呼叫postSomeaction() 以上為controller的基本呼叫方式。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Laravel] Study Note.]]></title>
    <url>%2F2013%2F10%2F16%2Flaravel-study-note%2F</url>
    <content type="text"><![CDATA[#database config path /app/config/database.php #star up path serverName/laravel/public #php artisan migrate 這裡migrate的觀念與EntityFramework 5 Code First的觀念相同。 migrate:install 安裝Migration table, 會在資料庫中創建一個migrateion table, 紀錄migration版本 migrate:make somethingsomething 建立新版的資料庫異動檔案 migrate 執行資料庫格式升級 --&gt; function up() migrate:rollback 執行資料庫格式降級 --&gt; function down() migrate table file location : app/database/migrations/ 升級動作123456789101112function up()&#123;// create new tableSchema::table('users', function($table) &#123; $table-&gt;create(); $table-&gt;increments('id');//id fields with AUTO_INCREMENT $table-&gt;string('email');//email field with varchar(255) $table-&gt;string('real_name',100);//real_field with varchar(100) $table-&gt;string('password'); $table-&gt;timestamps();// created_at,updated_at timestamps(2 fields) &#125;);&#125; 降級動作1234function down()&#123; //Drop Table Schema::drop('users');&#125;]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel 4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Phalcon] Work with Router]]></title>
    <url>%2F2013%2F10%2F10%2Fphalcon-work-with-router%2F</url>
    <content type="text"><![CDATA[啟動方式 12345678910$di-&gt;set(&apos;router&apos;, function () &#123; $router = new \Phalcon\Mvc\Router(); $router-&gt;add(&quot;/:controller/:action/:params&quot;, array( &apos;controller&apos; =&gt; 1, &apos;action&apos; =&gt; 2, &apos;params&apos; =&gt; 3 )); return $router;&#125;); Defining Route Placeholder Regular Expression Usage /:module /([a-zA-Z0-9_-]+) Matches a valid module name with alpha-numeric characters only /:controller /([a-zA-Z0-9_-]+) Matches a valid controller name with alpha-numeric characters only /:action /([a-zA-Z0-9_]+) Matches a valid action name with alpha-numeric characters only /:params (/.) Matches a list of optional words separated by slashes. Use only this placeholder at the end of a route /:namespace /([a-zA-Z0-9_-]+) Matches a single level namespace name /:int /([0-9]+) Matches an integer parameter /:params : 只能放在router的最後面 #controller內取得route裡面參數的方式 123$this-&gt;dispatcher-&gt;getParam(0);$this-&gt;dispatcher-&gt;getParam(&apos;paraName&apos;);$this-&gt;dispatcher-&gt;getParams(); &lt;=array #如果是/?var=value 就用原本$_GET[’’]的方式取值就可以了]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>Phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Memo]常用git指令]]></title>
    <url>%2F2013%2F10%2F09%2Fmemo-common-git-commands%2F</url>
    <content type="text"><![CDATA[commit your code 12git add .git commit -m &quot;xxxx&quot; merge your branch to master 以master為主要branch 12345git checkout mastergit merge [module name]&lt;= this should be branch name``` 3. update git pull origin master 123檢查是否有conflict要修4. push至origin git push origin master:[module name] 12345. 通知alvin合併6. 拉別人的code git add remote kyo /home/kyo/web/mc2 127. 直接合併於目前的branch EX. 拉KYO的master git pull remote kyo master 128. 拉成新的branch EX. 拉KYO的master為自己的kyo branch git fetch remote kyo master:kyo 12349. git 環境設定###設定個人資訊 git config --global user.name 「Your Name」 git config --global user.email you@example.com ###設定git環境 cd ~ #進入個人home目錄 ex./home/fish vi .gitconfig ####編輯git環境檔，貼上以下環境設定變數 [color] branch = auto diff = auto status = auto [color &quot;branch&quot;] current = yellow reverse local = yellow remote = green [color &quot;diff&quot;] meta = yellow bold frag = magenta bold old = red bold new = green bold [color &quot;status&quot;] added = green changed = red]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Phalcon] Using Model]]></title>
    <url>%2F2013%2F10%2F09%2Fphalcon-using-model%2F</url>
    <content type="text"><![CDATA[In Phalcon Model system. 是根據ORM的架構，讓資料表物件化，讓在資料讀取或是寫入的動作上，可以利用物件的特性去操作。 初始設定 1234567891011/** * Database connection is created based in the parameters defined in the configuration file */$di-&gt;set(&apos;db&apos;, function() use ($config) &#123; return new DbAdapter(array( &apos;host&apos; =&gt; $config-&gt;database-&gt;host, &apos;username&apos; =&gt; $config-&gt;database-&gt;username, &apos;password&apos; =&gt; $config-&gt;database-&gt;password, &apos;dbname&apos; =&gt; $config-&gt;database-&gt;dbname ));&#125;); 上列的動作會開啟與資料庫中間的連線關係，$config會去讀取所指定的設定文件 Model文件預設的命名方式為table名稱，例如: 123class Rebots extends \Phalcon\Mvc\Model&#123;&#125; 官方文件建議，要在Model文件中描述資料表的欄位，以減少使用伺服器的記憶體資源。 如果Model的名稱與資料庫資料表名稱不同時，可以透過以下的方式重新設定所關聯的資料表名稱 123456789public function initialize()&#123; $this-&gt;setSource(&apos;Rebots&apos;);&#125;``` #於Controller中使用Model讀取資料讀取清單的方式有幾種 ModelName::find(condition) 12當找到筆資料時，所回傳的物件可以直接修改後，並儲存(Update) $result = ModelName::find(『id=1』); $result-&gt;fieldName = 「something something」; $result-&gt;save(); &lt;=將資料回傳至資料庫中 12新增動作 $result = new ModelName(); $result-&gt;fieldName = 「something something」; $result-&gt;save(); 12刪除動作 $result = ModelName::find(condition); if ($result != false) { // 執行刪除 if ($result-&gt;delete() == false) { echo 「Delete Failed」; foreach ($result-&gt;getMessages() as $message) { echo $message, 「\n」; } } else { echo 「Deleted successfully!」; } }]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>Phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Phalcon] Using View]]></title>
    <url>%2F2013%2F10%2F08%2Fstudy-note-phalcon-using-view%2F</url>
    <content type="text"><![CDATA[#Hierarchical Rendering Phalcon當在使用View的時候，執行的順序是 app/views/index.volt app/views/layouts/指定.volt(有[指定時][1]，才會發生) app/views/layouts/{{controllerName}}.volt app/views/{{controllerName}}/xxx.volt 依造這種順序， 在index.volt裡面的{{content()}}，就會去呼叫app/views/layouts裡面的內容, 然後再app/views/layouts裡面的{{content()}}就是呼叫app/views/{{controllerName}}/xxx.volt的內容 在Controller裡面所設定的變數，則上述三種xxx.volt都可以用 [1]: 如果要指定template時, 可以用下列的方式設定, 這樣子就會去讀取app/views/layouts/common.volt的內容了, 1234public function initialize() &#123; $this-&gt;view-&gt;setTemplateAfter(&apos;common&apos;); &#125; 這一個指定template的動作，執行順序會插在app/views/index.volt跟app/views/layouts/{{controllerName}}.volt中間 #Using Partials 如果想要在view中間插入partials的方式很簡單 如果是使用volt語法的: 123&#123;&#123; partial(view path) &#125;&#125;//with parameters &#123;&#123; partial(view path, [&apos;links&apos;: $links]) &#125;&#125; 一般的語法 123&lt;?php $this-&gt;partial(view path) ?&gt;//with parameters &lt;?php $this-&gt;partial(view path, array(&apos;id&apos; =&gt; $site-&gt;id, &apos;size&apos; =&gt; &apos;big&apos;)) ?&gt;]]></content>
      <categories>
        <category>Phalcon</category>
      </categories>
      <tags>
        <tag>Phalcon</tag>
      </tags>
  </entry>
</search>
